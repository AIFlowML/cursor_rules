{"version":3,"sources":["../src/index.ts","../src/actions/spaceJoin.ts","../src/spaces.ts","../src/client/api.ts","../src/client/errors.ts","../src/client/platform/platform-interface.ts","../src/client/platform/index.ts","../src/client/requests.ts","../src/client/auth.ts","../src/client/auth-user.ts","../src/client/profile.ts","../src/client/grok.ts","../src/client/messages.ts","../src/client/relationships.ts","../src/client/timeline-async.ts","../src/client/timeline-relationship.ts","../src/client/search.ts","../src/client/type-util.ts","../src/client/timeline-tweet-util.ts","../src/client/timeline-v2.ts","../src/client/timeline-search.ts","../src/client/spaces.ts","../src/client/timeline-following.ts","../src/client/timeline-home.ts","../src/client/trends.ts","../src/client/api-data.ts","../src/client/timeline-list.ts","../src/client/tweets.ts","../src/client/client.ts","../src/client/spaces/core/Space.ts","../src/client/spaces/logger.ts","../src/client/spaces/utils.ts","../src/client/spaces/core/ChatClient.ts","../src/client/spaces/core/JanusClient.ts","../src/client/spaces/core/JanusAudio.ts","../src/client/spaces/core/SpaceParticipant.ts","../src/client/spaces/plugins/SttTtsPlugin.ts","../src/client/spaces/plugins/IdleMonitorPlugin.ts","../src/sttTtsSpaces.ts","../src/utils.ts","../src/base.ts","../src/constants.ts","../src/interactions.ts","../src/post.ts","../src/tests.ts"],"sourcesContent":["import {\n  ChannelType,\n  type Entity,\n  EventType,\n  type IAgentRuntime,\n  type Plugin,\n  Role,\n  type Room,\n  Service,\n  type UUID,\n  type World,\n  createUniqueUuid,\n  logger,\n} from '@elizaos/core';\nimport spaceJoin from './actions/spaceJoin';\nimport { ClientBase } from './base';\nimport { TWITTER_SERVICE_NAME } from './constants';\nimport type { TwitterConfig } from './environment';\nimport { TwitterInteractionClient } from './interactions';\nimport { TwitterPostClient } from './post';\nimport { TwitterSpaceClient } from './spaces';\nimport { ClientBaseTestSuite } from './tests';\nimport { type ITwitterClient, TwitterEventTypes } from './types';\n\n/**\n * A manager that orchestrates all specialized Twitter logic:\n * - client: base operations (login, timeline caching, etc.)\n * - post: autonomous posting logic\n * - search: searching tweets / replying logic\n * - interaction: handling mentions, replies\n * - space: launching and managing Twitter Spaces (optional)\n */\n/**\n * TwitterClientInstance class that implements ITwitterClient interface.\n *\n * @class\n * @implements {ITwitterClient}\n */\n\nexport class TwitterClientInstance implements ITwitterClient {\n  client: ClientBase;\n  post: TwitterPostClient;\n  interaction: TwitterInteractionClient;\n  space?: TwitterSpaceClient;\n  service: TwitterService;\n\n  constructor(runtime: IAgentRuntime, state: any) {\n    // Pass twitterConfig to the base client\n    this.client = new ClientBase(runtime, state);\n\n    // Posting logic\n    this.post = new TwitterPostClient(this.client, runtime, state);\n\n    // Mentions and interactions\n    this.interaction = new TwitterInteractionClient(this.client, runtime, state);\n\n    // Optional Spaces logic (enabled if TWITTER_SPACES_ENABLE is true)\n    if (runtime.getSetting('TWITTER_SPACES_ENABLE') === true) {\n      this.space = new TwitterSpaceClient(this.client, runtime);\n    }\n\n    this.service = TwitterService.getInstance();\n  }\n}\n\nexport class TwitterService extends Service {\n  static serviceType: string = TWITTER_SERVICE_NAME;\n  capabilityDescription = 'The agent is able to send and receive messages on twitter';\n  private static instance: TwitterService;\n  private clients: Map<string, TwitterClientInstance> = new Map();\n\n  static getInstance(): TwitterService {\n    if (!TwitterService.instance) {\n      TwitterService.instance = new TwitterService();\n    }\n    return TwitterService.instance;\n  }\n\n  async createClient(\n    runtime: IAgentRuntime,\n    clientId: string,\n    state: any\n  ): Promise<TwitterClientInstance> {\n    if (runtime.getSetting('TWITTER_2FA_SECRET') === null) {\n      runtime.setSetting('TWITTER_2FA_SECRET', undefined, false);\n    }\n    try {\n      // Check if client already exists\n      const existingClient = this.getClient(clientId, runtime.agentId);\n      if (existingClient) {\n        logger.info(`Twitter client already exists for ${clientId}`);\n        return existingClient;\n      }\n\n      // Create new client instance\n      const client = new TwitterClientInstance(runtime, state);\n\n      // Initialize the client\n      await client.client.init();\n\n      if (client.space) {\n        client.space.startPeriodicSpaceCheck();\n      }\n\n      if (client.post) {\n        client.post.start();\n      }\n\n      if (client.interaction) {\n        client.interaction.start();\n      }\n\n      // Store the client instance\n      this.clients.set(this.getClientKey(clientId, runtime.agentId), client);\n\n      // Emit standardized WORLD_JOINED event once we have client profile\n      await this.emitServerJoinedEvent(runtime, client);\n\n      logger.info(`Created Twitter client for ${clientId}`);\n      return client;\n    } catch (error) {\n      logger.error(`Failed to create Twitter client for ${clientId}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Emits a standardized WORLD_JOINED event for Twitter\n   * @param runtime The agent runtime\n   * @param client The Twitter client instance\n   */\n  private async emitServerJoinedEvent(\n    runtime: IAgentRuntime,\n    client: TwitterClientInstance\n  ): Promise<void> {\n    try {\n      if (!client.client.profile) {\n        logger.warn(\"Twitter profile not available yet, can't emit WORLD_JOINED event\");\n        return;\n      }\n\n      const profile = client.client.profile;\n      const twitterId = profile.id;\n      const username = profile.username;\n\n      // Create the world ID based on the twitter user ID\n      const worldId = createUniqueUuid(runtime, twitterId) as UUID;\n\n      // For Twitter, we create a single world representing the user's Twitter account\n      const world: World = {\n        id: worldId,\n        name: `${username}'s Twitter`,\n        agentId: runtime.agentId,\n        serverId: twitterId,\n        metadata: {\n          ownership: { ownerId: twitterId },\n          roles: {\n            [twitterId]: Role.OWNER,\n          },\n          twitter: {\n            username: username,\n            id: twitterId,\n          },\n        },\n      };\n\n      // We'll create a \"home timeline\" room\n      const homeTimelineRoomId = createUniqueUuid(runtime, `${twitterId}-home`) as UUID;\n      const homeTimelineRoom: Room = {\n        id: homeTimelineRoomId,\n        name: `${username}'s Timeline`,\n        source: 'twitter',\n        type: ChannelType.FEED,\n        channelId: `${twitterId}-home`,\n        serverId: twitterId,\n        worldId: worldId,\n      };\n\n      // Create a \"mentions\" room\n      const mentionsRoomId = createUniqueUuid(runtime, `${twitterId}-mentions`) as UUID;\n      const mentionsRoom: Room = {\n        id: mentionsRoomId,\n        name: `${username}'s Mentions`,\n        source: 'twitter',\n        type: ChannelType.GROUP,\n        channelId: `${twitterId}-mentions`,\n        serverId: twitterId,\n        worldId: worldId,\n      };\n\n      // Create an entity for the Twitter user\n      const twitterUserId = createUniqueUuid(runtime, twitterId) as UUID;\n      const twitterUser: Entity = {\n        id: twitterUserId,\n        names: [profile.screenName || username],\n        agentId: runtime.agentId,\n        metadata: {\n          twitter: {\n            id: twitterId,\n            username: username,\n            screenName: profile.screenName || username,\n            name: profile.screenName || username,\n          },\n        },\n      };\n\n      // Emit the WORLD_JOINED event\n      runtime.emitEvent([TwitterEventTypes.WORLD_JOINED, EventType.WORLD_JOINED], {\n        runtime: runtime,\n        world: world,\n        rooms: [homeTimelineRoom, mentionsRoom],\n        users: [twitterUser],\n        source: 'twitter',\n      });\n\n      logger.info(`Emitted WORLD_JOINED event for Twitter account ${username}`);\n    } catch (error) {\n      logger.error('Failed to emit WORLD_JOINED event for Twitter:', error);\n    }\n  }\n\n  getClient(clientId: string, agentId: UUID): TwitterClientInstance | undefined {\n    return this.clients.get(this.getClientKey(clientId, agentId));\n  }\n\n  async stopClient(clientId: string, agentId: UUID): Promise<void> {\n    const key = this.getClientKey(clientId, agentId);\n    const client = this.clients.get(key);\n    if (client) {\n      try {\n        await client.service.stop();\n        this.clients.delete(key);\n        logger.info(`Stopped Twitter client for ${clientId}`);\n      } catch (error) {\n        logger.error(`Error stopping Twitter client for ${clientId}:`, error);\n      }\n    }\n  }\n\n  static async start(runtime: IAgentRuntime) {\n    const twitterClientManager = TwitterService.getInstance();\n\n    // Check for character-level Twitter credentials\n    const twitterConfig: Partial<TwitterConfig> = {\n      TWITTER_USERNAME:\n        (runtime.getSetting('TWITTER_USERNAME') as string) ||\n        runtime.character.settings?.TWITTER_USERNAME ||\n        runtime.character.secrets?.TWITTER_USERNAME,\n      TWITTER_PASSWORD:\n        (runtime.getSetting('TWITTER_PASSWORD') as string) ||\n        runtime.character.settings?.TWITTER_PASSWORD ||\n        runtime.character.secrets?.TWITTER_PASSWORD,\n      TWITTER_EMAIL:\n        (runtime.getSetting('TWITTER_EMAIL') as string) ||\n        runtime.character.settings?.TWITTER_EMAIL ||\n        runtime.character.secrets?.TWITTER_EMAIL,\n      TWITTER_2FA_SECRET:\n        (runtime.getSetting('TWITTER_2FA_SECRET') as string) ||\n        runtime.character.settings?.TWITTER_2FA_SECRET ||\n        runtime.character.secrets?.TWITTER_2FA_SECRET,\n    };\n\n    // Filter out undefined values\n    const config = Object.fromEntries(\n      Object.entries(twitterConfig).filter(([_, v]) => v !== undefined)\n    ) as TwitterConfig;\n\n    // If we have enough settings to create a client, do so\n    try {\n      if (\n        config.TWITTER_USERNAME &&\n        // Basic auth\n        config.TWITTER_PASSWORD &&\n        config.TWITTER_EMAIL\n        // ||\n        // // API auth\n        // (config.TWITTER_API_KEY && config.TWITTER_API_SECRET &&\n        //  config.TWITTER_ACCESS_TOKEN && config.TWITTER_ACCESS_TOKEN_SECRET)\n      ) {\n        logger.info('Creating default Twitter client from character settings');\n        await twitterClientManager.createClient(runtime, runtime.agentId, config);\n      }\n    } catch (error) {\n      logger.error('Failed to create default Twitter client:', error);\n    }\n\n    return twitterClientManager;\n  }\n\n  async stop(): Promise<void> {\n    await this.stopAllClients();\n  }\n\n  async stopAllClients(): Promise<void> {\n    for (const [key, client] of this.clients.entries()) {\n      try {\n        await client.service.stop();\n        this.clients.delete(key);\n      } catch (error) {\n        logger.error(`Error stopping Twitter client ${key}:`, error);\n      }\n    }\n  }\n\n  private getClientKey(clientId: string, agentId: UUID): string {\n    return `${clientId}-${agentId}`;\n  }\n}\n\nconst twitterPlugin: Plugin = {\n  name: TWITTER_SERVICE_NAME,\n  description: 'Twitter client with per-server instance management',\n  services: [TwitterService],\n  actions: [spaceJoin],\n  tests: [new ClientBaseTestSuite()],\n};\n\nexport default twitterPlugin;\n","import {\n  type Action,\n  type ActionExample,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  logger,\n} from '@elizaos/core';\nimport type { Tweet } from '../client';\nimport { SpaceActivity } from '../spaces';\n\nexport default {\n  name: 'JOIN_TWITTER_SPACE',\n  similes: [\n    'JOIN_TWITTER_SPACE',\n    'JOIN_SPACE',\n    'JOIN_TWITTER_AUDIO',\n    'JOIN_TWITTER_CALL',\n    'JOIN_LIVE_CONVERSATION',\n  ],\n  validate: async (runtime: IAgentRuntime, message: Memory, _state: State) => {\n    if (message?.content?.source !== 'twitter') {\n      return false;\n    }\n\n    if (!message?.content?.tweet) {\n      return false;\n    }\n\n    const spaceEnable = runtime.getSetting('TWITTER_SPACES_ENABLE') === true;\n    return spaceEnable;\n  },\n  description: 'Join a Twitter Space to participate in live audio conversations.',\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n    _options: any,\n    callback: HandlerCallback,\n    responses: Memory[]\n  ): Promise<boolean> => {\n    if (!state) {\n      logger.error('State is not available.');\n      return false;\n    }\n\n    for (const response of responses) {\n      await callback(response.content);\n    }\n\n    const service = runtime.getService('twitter') as any;\n    if (!service) {\n      throw new Error('Twitter service not found');\n    }\n\n    const manager = service.getClient(runtime.agentId, runtime.agentId);\n    const client = manager.client;\n    const spaceManager = manager.space;\n\n    if (!spaceManager) {\n      logger.error('space action - no space manager found');\n      return false;\n    }\n\n    if (spaceManager.spaceStatus !== SpaceActivity.IDLE) {\n      logger.warn('currently hosting/participating a space');\n      return false;\n    }\n\n    const tweet = message.content.tweet as Tweet;\n    if (!tweet) {\n      logger.warn('space action - no tweet found in message');\n      return false;\n    }\n\n    async function joinSpaceByUrls(tweet: Tweet): Promise<boolean> {\n      if (!tweet.urls) return false;\n\n      for (const url of tweet.urls) {\n        const match = url.match(/https:\\/\\/x\\.com\\/i\\/spaces\\/([a-zA-Z0-9]+)/);\n        if (match) {\n          const spaceId = match[1];\n          try {\n            const spaceInfo = await client.twitterClient.getAudioSpaceById(spaceId);\n            if (spaceInfo?.metadata?.state === 'Running') {\n              const spaceJoined = await spaceManager.startParticipant(spaceId);\n              return !!spaceJoined;\n            }\n          } catch (error) {\n            logger.error('Error joining Twitter Space:', error);\n          }\n        }\n      }\n      return false;\n    }\n\n    async function joinSpaceByUserName(userName: string): Promise<boolean> {\n      try {\n        const tweetGenerator = client.twitterClient.getTweets(userName);\n        for await (const userTweet of tweetGenerator) {\n          if (await joinSpaceByUrls(userTweet)) {\n            return true;\n          }\n        }\n      } catch (error) {\n        logger.error(`Error fetching tweets for ${userName}:`, error);\n      }\n      return false;\n    }\n\n    // Attempt to join a Twitter Space from URLs in the tweet\n    const spaceJoined = await joinSpaceByUrls(tweet);\n    if (spaceJoined) return true;\n\n    // If no Space was found in the URLs, check if the tweet author has an active Space\n    const authorJoined = await joinSpaceByUserName(tweet.username);\n    if (authorJoined) return true;\n\n    // If the tweet author isn't hosting a Space, check if any mentioned users are currently hosting one\n    const agentName = client.state.TWITTER_USERNAME;\n    for (const mention of tweet.mentions) {\n      if (mention.username !== agentName) {\n        const mentionJoined = await joinSpaceByUserName(mention.username);\n        if (mentionJoined) return true;\n      }\n    }\n    await callback({\n      text: \"I couldn't determine which Twitter Space to join.\",\n      source: 'twitter',\n    });\n\n    return false;\n  },\n  examples: [\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: \"Hey, let's join the 'Crypto Talk' Twitter Space!\",\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'On my way',\n          actions: ['JOIN_TWITTER_SPACE'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: \"@{{name2}}, jump into the 'AI Revolution' Space!\",\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'Joining now!',\n          actions: ['JOIN_TWITTER_SPACE'],\n        },\n      },\n    ],\n  ] as ActionExample[][],\n} as Action;\n","import {\n  ChannelType,\n  type IAgentRuntime,\n  ModelType,\n  createUniqueUuid,\n  logger,\n} from '@elizaos/core';\nimport type { ClientBase } from './base';\nimport {\n  type Client,\n  IdleMonitorPlugin,\n  Space,\n  type SpaceConfig,\n  SpaceParticipant,\n  type SpeakerRequest,\n} from './client/index';\nimport { SttTtsPlugin } from './sttTtsSpaces';\nimport { generateTopicsIfEmpty, isAgentInSpace, speakFiller } from './utils';\n\n/**\n * Interface representing options for deciding on creating a Twitter Space.\n * @typedef {Object} TwitterSpaceDecisionOptions\n * @property {number} [maxSpeakers] - Maximum number of speakers allowed in the Twitter Space.\n * @property {number} [typicalDurationMinutes] - Typical duration of the Twitter Space in minutes.\n * @property {number} [idleKickTimeoutMs] - Timeout in milliseconds for kicking idle users from the Twitter Space.\n * @property {number} [minIntervalBetweenSpacesMinutes] - Minimum interval between creating new Twitter Spaces in minutes.\n * @property {boolean} [enableIdleMonitor] - Flag to enable or disable idle user monitoring in the Twitter Space.\n * @property {boolean} enableSpaceHosting - Flag to enable or disable space hosting in the Twitter Space.\n * @property {boolean} [enableRecording] - Flag to enable or disable recording of the Twitter Space.\n * @property {number} [speakerMaxDurationMs] - Maximum duration in milliseconds for each speaker in the Twitter Space.\n */\nexport interface TwitterSpaceDecisionOptions {\n  maxSpeakers?: number;\n  typicalDurationMinutes?: number;\n  idleKickTimeoutMs?: number;\n  minIntervalBetweenSpacesMinutes?: number;\n  enableIdleMonitor?: boolean;\n  enableSpaceHosting: boolean;\n  enableRecording?: boolean;\n  speakerMaxDurationMs?: number;\n}\n\n/**\n * Represents the state of the current speaker in a session.\n * @typedef { Object } CurrentSpeakerState\n * @property { string } userId - The unique identifier of the user who is the current speaker.\n * @property { string } sessionUUID - The unique identifier of the session the speaker is in.\n * @property { string } username - The username of the current speaker.\n * @property { number } startTime - The timestamp when the current speaker started speaking.\n */\ninterface CurrentSpeakerState {\n  userId: string;\n  sessionUUID: string;\n  username: string;\n  startTime: number;\n}\n\n/**\n * Enum representing space activity options.\n *\n * @enum {string}\n * @readonly\n * @property {string} HOSTING - Indicates that the space is being used for hosting an event.\n * @property {string} PARTICIPATING - Indicates that the space is being used for participating in an event.\n * @property {string} IDLE - Indicates that the space is not currently being used.\n */\nexport enum SpaceActivity {\n  HOSTING = 'hosting',\n  PARTICIPATING = 'participating',\n  IDLE = 'idle',\n}\n\n/**\n * An enum representing the activity role of a participant.\n * @enum {string}\n * @readonly\n * @property {string} LISTENER - Represents a participant who is a listener.\n * @property {string} SPEAKER - Represents a participant who is a speaker.\n * @property {string} PENDING - Represents a participant whose activity is pending.\n */\nexport enum ParticipantActivity {\n  LISTENER = 'listener',\n  SPEAKER = 'speaker',\n  PENDING = 'pending',\n}\n\n/**\n * Main class: manage a Twitter Space with N speakers max, speaker queue, filler messages, etc.\n */\n/**\n * Represents a client for interacting with Twitter Spaces.\n * * @class\n * @property { IAgentRuntime } runtime - The agent runtime for the client.\n * @property { ClientBase } client - The base client for making requests.\n * @property { Client } twitterClient - The Twitter client for interacting with Twitter API.\n * @property {Space | undefined} currentSpace - The current Twitter Space the client is connected to (if any).\n * @property {string | undefined} spaceId - The ID of the Twitter Space the client is connected to (if any).\n * @property {number | undefined} startedAt - The timestamp when the client was started.\n * @property {NodeJS.Timeout | undefined} checkInterval - The interval for checking the status of the Twitter Space.\n * @property {number | undefined} lastSpaceEndedAt - The timestamp of when the last Twitter Space ended.\n */\nexport class TwitterSpaceClient {\n  private runtime: IAgentRuntime;\n  private client: ClientBase;\n  private twitterClient: Client;\n  private currentSpace?: Space;\n  private spaceId?: string;\n  private startedAt?: number;\n  private checkInterval?: NodeJS.Timeout;\n  private lastSpaceEndedAt?: number;\n  private sttTtsPlugin?: SttTtsPlugin;\n  public spaceStatus: SpaceActivity = SpaceActivity.IDLE;\n  private spaceParticipant: SpaceParticipant | null = null;\n  public participantStatus: ParticipantActivity = ParticipantActivity.LISTENER;\n\n  /**\n   * We now store an array of active speakers, not just 1\n   */\n  private activeSpeakers: CurrentSpeakerState[] = [];\n  private speakerQueue: SpeakerRequest[] = [];\n\n  private decisionOptions: TwitterSpaceDecisionOptions;\n\n  constructor(client: ClientBase, runtime: IAgentRuntime) {\n    this.client = client;\n    this.twitterClient = client.twitterClient;\n    this.runtime = runtime;\n\n    this.sttTtsPlugin = new SttTtsPlugin();\n\n    // TODO: Spaces should be added to and removed from cache probably, and it should be possible to join or leave a space from an action, etc\n    const charSpaces = runtime.character.settings?.twitter?.spaces || {};\n    this.decisionOptions = {\n      maxSpeakers: charSpaces.maxSpeakers ?? 1,\n      typicalDurationMinutes: charSpaces.typicalDurationMinutes ?? 30,\n      idleKickTimeoutMs: charSpaces.idleKickTimeoutMs ?? 5 * 60_000,\n      minIntervalBetweenSpacesMinutes: charSpaces.minIntervalBetweenSpacesMinutes ?? 60,\n      enableIdleMonitor: charSpaces.enableIdleMonitor !== false,\n      enableRecording: charSpaces.enableRecording !== false,\n      enableSpaceHosting: charSpaces.enableSpaceHosting || false,\n      speakerMaxDurationMs: charSpaces.speakerMaxDurationMs ?? 4 * 60_000,\n    };\n  }\n\n  /**\n   * Periodic check to launch or manage space\n   */\n  public async startPeriodicSpaceCheck() {\n    logger.log('[Space] Starting periodic check routine...');\n\n    const interval = 20_000;\n\n    const routine = async () => {\n      try {\n        if (this.spaceStatus === SpaceActivity.IDLE) {\n          if (this.decisionOptions.enableSpaceHosting) {\n            // Space not running => check if we should launch\n            const launch = await this.shouldLaunchSpace();\n            if (launch) {\n              const config = await this.generateSpaceConfig();\n              await this.startSpace(config);\n            }\n          }\n        } else {\n          if (this.spaceStatus === SpaceActivity.HOSTING) {\n            await this.manageCurrentSpace();\n          } else if (this.spaceStatus === SpaceActivity.PARTICIPATING) {\n            await this.manageParticipant();\n          }\n        }\n        this.checkInterval = setTimeout(routine, interval) as any;\n      } catch (error) {\n        logger.error('[Space] Error in routine =>', error);\n        // In case of error, still schedule next iteration\n        this.checkInterval = setTimeout(routine, interval) as any;\n      }\n    };\n\n    routine();\n  }\n\n  stopPeriodicCheck() {\n    if (this.checkInterval) {\n      clearTimeout(this.checkInterval);\n      this.checkInterval = undefined;\n    }\n  }\n\n  private async shouldLaunchSpace(): Promise<boolean> {\n    // Interval\n    const now = Date.now();\n    if (this.lastSpaceEndedAt) {\n      const minIntervalMs = (this.decisionOptions.minIntervalBetweenSpacesMinutes ?? 60) * 60_000;\n      if (now - this.lastSpaceEndedAt < minIntervalMs) {\n        logger.log('[Space] Too soon since last space => skip');\n        return false;\n      }\n    }\n\n    logger.log('[Space] Deciding to launch a new Space...');\n    return true;\n  }\n\n  private async generateSpaceConfig(): Promise<SpaceConfig> {\n    let chosenTopic = 'Random Tech Chat';\n    let topics = this.runtime.character.topics || [];\n    if (!topics.length) {\n      const newTopics = await generateTopicsIfEmpty(this.client.runtime);\n      topics = newTopics;\n    }\n\n    chosenTopic = topics[Math.floor(Math.random() * topics.length)];\n\n    return {\n      record: this.decisionOptions.enableRecording,\n      mode: 'INTERACTIVE',\n      title: chosenTopic,\n      description: `Discussion about ${chosenTopic}`,\n      languages: ['en'],\n    };\n  }\n\n  public async startSpace(config: SpaceConfig) {\n    logger.log('[Space] Starting a new Twitter Space...');\n\n    try {\n      this.currentSpace = new Space(this.twitterClient);\n      this.spaceStatus = SpaceActivity.IDLE;\n      this.spaceId = undefined;\n      this.startedAt = Date.now();\n\n      // Reset states\n      this.activeSpeakers = [];\n      this.speakerQueue = [];\n\n      const broadcastInfo = await this.currentSpace.initialize(config);\n      this.spaceId = broadcastInfo.room_id;\n\n      // Create standardized world and room IDs for the space\n      const userId = this.client.profile.id;\n      const worldId = createUniqueUuid(this.runtime, userId);\n      const spaceRoomId = createUniqueUuid(this.runtime, `${userId}-space-${this.spaceId}`);\n\n      // Ensure world exists first\n      await this.runtime.ensureWorldExists({\n        id: worldId,\n        name: `${this.client.profile.username}'s Twitter`,\n        agentId: this.runtime.agentId,\n        serverId: userId,\n        metadata: {\n          ownership: { ownerId: userId },\n          twitter: {\n            username: this.client.profile.username,\n            id: userId,\n          },\n        },\n      });\n\n      // Ensure space room exists\n      await this.runtime.ensureRoomExists({\n        id: spaceRoomId,\n        name: config.title || 'Twitter Space',\n        source: 'twitter',\n        type: ChannelType.GROUP,\n        channelId: this.spaceId,\n        serverId: userId,\n        worldId: worldId,\n        metadata: {\n          spaceInfo: {\n            title: config.title,\n            description: config.description,\n            startedAt: Date.now(),\n            mode: config.mode,\n            languages: config.languages,\n            isRecording: config.record,\n          },\n        },\n      });\n\n      if (\n        this.runtime.getModel(ModelType.TEXT_TO_SPEECH) &&\n        this.runtime.getModel(ModelType.TRANSCRIPTION)\n      ) {\n        logger.log('[Space] Using SttTtsPlugin');\n        this.currentSpace.use(this.sttTtsPlugin as any, {\n          runtime: this.runtime,\n          spaceId: this.spaceId,\n        });\n      }\n\n      if (this.decisionOptions.enableIdleMonitor) {\n        logger.log('[Space] Using IdleMonitorPlugin');\n        this.currentSpace.use(\n          new IdleMonitorPlugin(this.decisionOptions.idleKickTimeoutMs ?? 60_000, 10_000)\n        );\n      }\n      this.spaceStatus = SpaceActivity.HOSTING;\n\n      // Create tweet announcing the space\n      const spaceUrl = broadcastInfo.share_url.replace('broadcasts', 'spaces');\n      await this.twitterClient.sendTweet(spaceUrl);\n\n      logger.log(`[Space] Space started => ${spaceUrl}`);\n\n      // Greet\n      await speakFiller(this.client.runtime, this.sttTtsPlugin, 'WELCOME');\n\n      // Events\n      this.currentSpace.on('occupancyUpdate', (update) => {\n        logger.log(`[Space] Occupancy => ${update.occupancy} participant(s).`);\n      });\n\n      this.currentSpace.on('speakerRequest', async (req: SpeakerRequest) => {\n        logger.log(`[Space] Speaker request from @${req.username} (${req.userId}).`);\n        await this.handleSpeakerRequest(req);\n      });\n\n      this.currentSpace.on('idleTimeout', async (info) => {\n        logger.log(`[Space] idleTimeout => no audio for ${info.idleMs} ms.`);\n        await speakFiller(this.client.runtime, this.sttTtsPlugin, 'IDLE_ENDING');\n        await this.stopSpace();\n      });\n\n      process.on('SIGINT', async () => {\n        logger.log('[Space] SIGINT => stopping space');\n        await speakFiller(this.client.runtime, this.sttTtsPlugin, 'CLOSING');\n        await this.stopSpace();\n        process.exit(0);\n      });\n    } catch (error) {\n      logger.error('[Space] Error launching Space =>', error);\n      this.spaceStatus = SpaceActivity.IDLE;\n      throw error;\n    }\n  }\n\n  /**\n   * Periodic management: check durations, remove extras, maybe accept new from queue\n   */\n  private async manageCurrentSpace() {\n    if (!this.spaceId || !this.currentSpace) return;\n    try {\n      const audioSpace = await this.twitterClient.getAudioSpaceById(this.spaceId);\n      const { participants } = audioSpace;\n      const numSpeakers = participants.speakers?.length || 0;\n      const totalListeners = participants.listeners?.length || 0;\n\n      // 1) Remove any speaker who exceeded speakerMaxDurationMs\n      const maxDur = this.decisionOptions.speakerMaxDurationMs ?? 240_000;\n      const now = Date.now();\n\n      for (let i = this.activeSpeakers.length - 1; i >= 0; i--) {\n        const speaker = this.activeSpeakers[i];\n        const elapsed = now - speaker.startTime;\n        if (elapsed > maxDur) {\n          logger.log(`[Space] Speaker @${speaker.username} exceeded max duration => removing`);\n          await this.removeSpeaker(speaker.userId);\n          this.activeSpeakers.splice(i, 1);\n\n          // Possibly speak a short \"SPEAKER_LEFT\" filler\n          await speakFiller(this.client.runtime, this.sttTtsPlugin, 'SPEAKER_LEFT');\n        }\n      }\n\n      // 2) If we have capacity for new speakers from the queue, accept them\n      await this.acceptSpeakersFromQueueIfNeeded();\n\n      // 3) If somehow more than maxSpeakers are active, remove the extras\n      if (numSpeakers > (this.decisionOptions.maxSpeakers ?? 1)) {\n        logger.log('[Space] More than maxSpeakers => removing extras...');\n        await this.kickExtraSpeakers(participants.speakers);\n      }\n\n      // 4) Possibly stop the space if empty or time exceeded\n      const elapsedMinutes = (now - (this.startedAt || 0)) / 60000;\n      if (\n        elapsedMinutes > (this.decisionOptions.typicalDurationMinutes ?? 30) ||\n        (numSpeakers === 0 && totalListeners === 0 && elapsedMinutes > 5)\n      ) {\n        logger.log('[Space] Condition met => stopping the Space...');\n        await speakFiller(this.client.runtime, this.sttTtsPlugin, 'CLOSING', 4000);\n        await this.stopSpace();\n      }\n    } catch (error) {\n      logger.error('[Space] Error in manageCurrentSpace =>', error);\n    }\n  }\n\n  /**\n   * If we have available slots, accept new speakers from the queue\n   */\n  private async acceptSpeakersFromQueueIfNeeded() {\n    // while queue not empty and activeSpeakers < maxSpeakers, accept next\n    const ms = this.decisionOptions.maxSpeakers ?? 1;\n    while (this.speakerQueue.length > 0 && this.activeSpeakers.length < ms) {\n      const nextReq = this.speakerQueue.shift();\n      if (nextReq) {\n        await speakFiller(this.client.runtime, this.sttTtsPlugin, 'PRE_ACCEPT');\n        await this.acceptSpeaker(nextReq);\n      }\n    }\n  }\n\n  private async handleSpeakerRequest(req: SpeakerRequest) {\n    if (!this.spaceId || !this.currentSpace) return;\n\n    const audioSpace = await this.twitterClient.getAudioSpaceById(this.spaceId);\n    const janusSpeakers = audioSpace?.participants?.speakers || [];\n\n    // If we haven't reached maxSpeakers, accept immediately\n    if (janusSpeakers.length < (this.decisionOptions.maxSpeakers ?? 1)) {\n      logger.log(`[Space] Accepting speaker @${req.username} now`);\n      await speakFiller(this.client.runtime, this.sttTtsPlugin, 'PRE_ACCEPT');\n      await this.acceptSpeaker(req);\n    } else {\n      logger.log(`[Space] Adding speaker @${req.username} to the queue`);\n      this.speakerQueue.push(req);\n    }\n  }\n\n  private async acceptSpeaker(req: SpeakerRequest) {\n    if (!this.currentSpace) return;\n    try {\n      await this.currentSpace.approveSpeaker(req.userId, req.sessionUUID);\n      this.activeSpeakers.push({\n        userId: req.userId,\n        sessionUUID: req.sessionUUID,\n        username: req.username,\n        startTime: Date.now(),\n      });\n      logger.log(`[Space] Speaker @${req.username} is now live`);\n    } catch (err) {\n      logger.error(`[Space] Error approving speaker @${req.username}:`, err);\n    }\n  }\n\n  private async removeSpeaker(userId: string) {\n    if (!this.currentSpace) return;\n    try {\n      await this.currentSpace.removeSpeaker(userId);\n      logger.log(`[Space] Removed speaker userId=${userId}`);\n    } catch (error) {\n      logger.error(`[Space] Error removing speaker userId=${userId} =>`, error);\n    }\n  }\n\n  /**\n   * If more than maxSpeakers are found, remove extras\n   * Also update activeSpeakers array\n   */\n  private async kickExtraSpeakers(speakers: any[]) {\n    if (!this.currentSpace) return;\n    const ms = this.decisionOptions.maxSpeakers ?? 1;\n\n    // sort by who joined first if needed, or just slice\n    const extras = speakers.slice(ms);\n    for (const sp of extras) {\n      logger.log(`[Space] Removing extra speaker => userId=${sp.user_id}`);\n      await this.removeSpeaker(sp.user_id);\n\n      // remove from activeSpeakers array\n      const idx = this.activeSpeakers.findIndex((s) => s.userId === sp.user_id);\n      if (idx !== -1) {\n        this.activeSpeakers.splice(idx, 1);\n      }\n    }\n  }\n\n  public async stopSpace() {\n    if (!this.currentSpace || this.spaceStatus !== SpaceActivity.HOSTING) return;\n    try {\n      logger.log('[Space] Stopping the current Space...');\n      await this.currentSpace.stop();\n    } catch (err) {\n      logger.error('[Space] Error stopping Space =>', err);\n    } finally {\n      this.spaceStatus = SpaceActivity.IDLE;\n      this.spaceId = undefined;\n      this.currentSpace = undefined;\n      this.startedAt = undefined;\n      this.lastSpaceEndedAt = Date.now();\n      this.activeSpeakers = [];\n      this.speakerQueue = [];\n    }\n  }\n\n  async startParticipant(spaceId: string) {\n    if (this.spaceStatus !== SpaceActivity.IDLE) {\n      logger.warn('currently hosting/participating a space');\n      return null;\n    }\n\n    this.spaceParticipant = new SpaceParticipant(this.client.twitterClient, {\n      spaceId,\n      debug: false,\n    });\n\n    if (this.spaceParticipant) {\n      try {\n        await this.spaceParticipant.joinAsListener();\n\n        this.spaceId = spaceId;\n        this.spaceStatus = SpaceActivity.PARTICIPATING;\n\n        return spaceId;\n      } catch (error) {\n        logger.error(`failed to join space ${error}`);\n        return null;\n      }\n    }\n  }\n\n  async manageParticipant() {\n    if (!this.spaceParticipant || !this.spaceId) {\n      this.stopParticipant();\n      return;\n    }\n\n    const isParticipant = await isAgentInSpace(this.client, this.spaceId);\n\n    if (!isParticipant) {\n      this.stopParticipant();\n      return;\n    }\n\n    // Check if we should request to speak\n    if (this.participantStatus === ParticipantActivity.LISTENER) {\n      logger.log('[SpaceParticipant] Checking if we should request to speak...');\n\n      this.participantStatus = ParticipantActivity.PENDING;\n\n      const { sessionUUID } = await this.spaceParticipant.requestSpeaker();\n\n      const handleSpeakerRemove = async (evt: { sessionUUID: string }) => {\n        if (evt.sessionUUID === sessionUUID) {\n          logger.debug('[SpaceParticipant] Speaker removed:', evt);\n          try {\n            await this.spaceParticipant.removeFromSpeaker();\n          } catch (err) {\n            console.error('[SpaceParticipant] Failed to become speaker:', err);\n          }\n          this.participantStatus = ParticipantActivity.LISTENER;\n          this.spaceParticipant?.off('newSpeakerRemoved', handleSpeakerRemove);\n        }\n      };\n\n      // Attach listener for speaker removal\n      this.spaceParticipant.on('newSpeakerRemoved', handleSpeakerRemove);\n\n      this.waitForApproval(this.spaceParticipant, sessionUUID, 15000)\n        .then(() => {\n          this.participantStatus = ParticipantActivity.SPEAKER;\n          this.spaceParticipant.use(this.sttTtsPlugin as any, {\n            runtime: this.runtime,\n            spaceId: this.spaceId,\n          });\n        })\n        .catch(async (err) => {\n          console.error('[SpaceParticipant] Approval error or timeout =>', err);\n\n          this.participantStatus = ParticipantActivity.LISTENER;\n\n          try {\n            await this.spaceParticipant.cancelSpeakerRequest();\n            logger.debug('[SpaceParticipant] Speaker request canceled after timeout or error.');\n          } catch (cancelErr) {\n            console.error('[SpaceParticipant] Could not cancel the request =>', cancelErr);\n          }\n        });\n    }\n  }\n\n  public async stopParticipant() {\n    if (!this.spaceParticipant || this.spaceStatus !== SpaceActivity.PARTICIPATING) return;\n    try {\n      logger.log('[SpaceParticipant] Stopping the current space participant...');\n      await this.spaceParticipant.leaveSpace();\n    } catch (err) {\n      logger.error('[SpaceParticipant] Error stopping space participant =>', err);\n    } finally {\n      this.spaceStatus = SpaceActivity.IDLE;\n      this.participantStatus = ParticipantActivity.LISTENER;\n      this.spaceId = undefined;\n      this.spaceParticipant = undefined;\n    }\n  }\n\n  /**\n   * waitForApproval waits until \"newSpeakerAccepted\" matches our sessionUUID,\n   * then calls becomeSpeaker() or rejects after a given timeout.\n   */\n  async waitForApproval(\n    participant: SpaceParticipant,\n    sessionUUID: string,\n    timeoutMs = 10000\n  ): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      let resolved = false;\n\n      const handler = async (evt: { sessionUUID: string }) => {\n        if (evt.sessionUUID === sessionUUID) {\n          resolved = true;\n          participant.off('newSpeakerAccepted', handler);\n          try {\n            await participant.becomeSpeaker();\n            logger.debug('[SpaceParticipant] Successfully became speaker!');\n            resolve();\n          } catch (err) {\n            reject(err);\n          }\n        }\n      };\n\n      // Listen to \"newSpeakerAccepted\" from participant\n      participant.on('newSpeakerAccepted', handler);\n\n      // Timeout to reject if not approved in time\n      setTimeout(() => {\n        if (!resolved) {\n          participant.off('newSpeakerAccepted', handler);\n          reject(\n            new Error(\n              `[SpaceParticipant] Timed out waiting for speaker approval after ${timeoutMs}ms.`\n            )\n          );\n        }\n      }, timeoutMs);\n    });\n  }\n}\n","import { Headers } from 'headers-polyfill';\nimport type { TwitterAuth } from './auth';\nimport { ApiError } from './errors';\nimport { Platform, type PlatformExtensions } from './platform';\nimport { updateCookieJar } from './requests';\n\n// For some reason using Parameters<typeof fetch> reduces the request transform function to\n// `(url: string) => string` in tests.\n/**\n * Represents an array type for parameters used in the fetch function,\n * with the first element being input of type RequestInfo or URL,\n * and the second element being init of type RequestInit or optional if not provided.\n */\ntype FetchParameters = [input: RequestInfo | URL, init?: RequestInit];\n\n/**\n * @typedef {Object} FetchTransformOptions\n * @property {Function} request Transforms the request options before a request is made. This executes after all of the default\n * parameters have been configured, and is stateless. It is safe to return new request options\n * objects.\n * @param {FetchParameters} args The request options.\n * @returns {FetchParameters|Promise<FetchParameters>} The transformed request options.\n *\n * @property {Function} response Transforms the response after a request completes. This executes immediately after the request\n * completes, and is stateless. It is safe to return a new response object.\n * @param {Response} response The response object.\n * @returns {Response|Promise<Response>} The transformed response object.\n */\n\nexport interface FetchTransformOptions {\n  /**\n   * Transforms the request options before a request is made. This executes after all of the default\n   * parameters have been configured, and is stateless. It is safe to return new request options\n   * objects.\n   * @param args The request options.\n   * @returns The transformed request options.\n   */\n  request: (...args: FetchParameters) => FetchParameters | Promise<FetchParameters>;\n\n  /**\n   * Transforms the response after a request completes. This executes immediately after the request\n   * completes, and is stateless. It is safe to return a new response object.\n   * @param response The response object.\n   * @returns The transformed response object.\n   */\n  response: (response: Response) => Response | Promise<Response>;\n}\n\nexport const bearerToken =\n  'AAAAAAAAAAAAAAAAAAAAAFQODgEAAAAAVHTp76lzh3rFzcHbmHVvQxYYpTw%3DckAlMINMjmCwxUcaXbAN4XqJVdgMJaHqNOFgPMK0zN1qLqLQCF';\n\n/**\n * An API result container.\n */\nexport type RequestApiResult<T> = { success: true; value: T } | { success: false; err: Error };\n\n/**\n * Used internally to send HTTP requests to the Twitter API.\n * @internal\n * @param url - The URL to send the request to.\n * @param auth - The instance of {@link TwitterAuth} that will be used to authorize this request.\n * @param method - The HTTP method used when sending this request.\n */\nexport async function requestApi<T>(\n  url: string,\n  auth: TwitterAuth,\n  method: 'GET' | 'POST' = 'GET',\n  platform: PlatformExtensions = new Platform(),\n  body?: any\n): Promise<RequestApiResult<T>> {\n  const headers = new Headers();\n  await auth.installTo(headers, url);\n  await platform.randomizeCiphers();\n\n  let res: Response;\n  do {\n    try {\n      res = await auth.fetch(url, {\n        method,\n        headers: headers as any,\n        credentials: 'include',\n        ...(body && { body: JSON.stringify(body) }),\n      });\n    } catch (err) {\n      if (!(err instanceof Error)) {\n        throw err;\n      }\n      return {\n        success: false,\n        err: new Error('Failed to perform request.'),\n      };\n    }\n\n    await updateCookieJar(auth.cookieJar(), res.headers);\n\n    if (res.status === 429) {\n      /*\n      Known headers at this point:\n      - x-rate-limit-limit: Maximum number of requests per time period?\n      - x-rate-limit-reset: UNIX timestamp when the current rate limit will be reset.\n      - x-rate-limit-remaining: Number of requests remaining in current time period?\n      */\n      const xRateLimitRemaining = res.headers.get('x-rate-limit-remaining');\n      const xRateLimitReset = res.headers.get('x-rate-limit-reset');\n      if (xRateLimitRemaining === '0' && xRateLimitReset) {\n        const currentTime = new Date().valueOf() / 1000;\n        const timeDeltaMs = 1000 * (Number.parseInt(xRateLimitReset) - currentTime);\n\n        // I have seen this block for 800s (~13 *minutes*)\n        await new Promise((resolve) => setTimeout(resolve, timeDeltaMs));\n      }\n    }\n  } while (res.status === 429);\n\n  if (!res.ok) {\n    return {\n      success: false,\n      err: await ApiError.fromResponse(res),\n    };\n  }\n\n  // Check if response is chunked\n  const transferEncoding = res.headers.get('transfer-encoding');\n  if (transferEncoding === 'chunked') {\n    // Handle streaming response, if a reader is present\n    const reader = typeof res.body?.getReader === 'function' ? res.body.getReader() : null;\n    if (!reader) {\n      try {\n        const text = await res.text();\n        try {\n          const value = JSON.parse(text);\n          return { success: true, value };\n        } catch (_e) {\n          // Return if just a normal string\n          return { success: true, value: { text } as any };\n        }\n      } catch (_e) {\n        return {\n          success: false,\n          err: new Error('No readable stream available and cant parse'),\n        };\n      }\n    }\n\n    let chunks: any = '';\n    // Read all chunks before attempting to parse\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n\n      // Convert chunk to text and append\n      chunks += new TextDecoder().decode(value);\n    }\n\n    // Now try to parse the complete accumulated response\n    try {\n      const value = JSON.parse(chunks);\n      return { success: true, value };\n    } catch (_e) {\n      // If we can't parse as JSON, return the raw text\n      return { success: true, value: { text: chunks } as any };\n    }\n  }\n\n  // Handle non-streaming responses as before\n  const contentType = res.headers.get('content-type');\n  if (contentType?.includes('application/json')) {\n    const value: T = await res.json();\n    if (res.headers.get('x-rate-limit-incoming') === '0') {\n      auth.deleteToken();\n    }\n    return { success: true, value };\n  }\n\n  return { success: true, value: {} as T };\n}\n\n/** @internal */\nexport function addApiFeatures(o: object) {\n  return {\n    ...o,\n    rweb_lists_timeline_redesign_enabled: true,\n    responsive_web_graphql_exclude_directive_enabled: true,\n    verified_phone_label_enabled: false,\n    creator_subscriptions_tweet_preview_api_enabled: true,\n    responsive_web_graphql_timeline_navigation_enabled: true,\n    responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,\n    tweetypie_unmention_optimization_enabled: true,\n    responsive_web_edit_tweet_api_enabled: true,\n    graphql_is_translatable_rweb_tweet_is_translatable_enabled: true,\n    view_counts_everywhere_api_enabled: true,\n    longform_notetweets_consumption_enabled: true,\n    tweet_awards_web_tipping_enabled: false,\n    freedom_of_speech_not_reach_fetch_enabled: true,\n    standardized_nudges_misinfo: true,\n    longform_notetweets_rich_text_read_enabled: true,\n    responsive_web_enhance_cards_enabled: false,\n    subscriptions_verification_info_enabled: true,\n    subscriptions_verification_info_reason_enabled: true,\n    subscriptions_verification_info_verified_since_enabled: true,\n    super_follow_badge_privacy_enabled: false,\n    super_follow_exclusive_tweet_notifications_enabled: false,\n    super_follow_tweet_api_enabled: false,\n    super_follow_user_api_enabled: false,\n    android_graphql_skip_api_media_color_palette: false,\n    creator_subscriptions_subscription_count_enabled: false,\n    blue_business_profile_image_shape_enabled: false,\n    unified_cards_ad_metadata_container_dynamic_card_content_query_enabled: false,\n  };\n}\n\nexport function addApiParams(\n  params: URLSearchParams,\n  includeTweetReplies: boolean\n): URLSearchParams {\n  params.set('include_profile_interstitial_type', '1');\n  params.set('include_blocking', '1');\n  params.set('include_blocked_by', '1');\n  params.set('include_followed_by', '1');\n  params.set('include_want_retweets', '1');\n  params.set('include_mute_edge', '1');\n  params.set('include_can_dm', '1');\n  params.set('include_can_media_tag', '1');\n  params.set('include_ext_has_nft_avatar', '1');\n  params.set('include_ext_is_blue_verified', '1');\n  params.set('include_ext_verified_type', '1');\n  params.set('skip_status', '1');\n  params.set('cards_platform', 'Web-12');\n  params.set('include_cards', '1');\n  params.set('include_ext_alt_text', 'true');\n  params.set('include_ext_limited_action_results', 'false');\n  params.set('include_quote_count', 'true');\n  params.set('include_reply_count', '1');\n  params.set('tweet_mode', 'extended');\n  params.set('include_ext_collab_control', 'true');\n  params.set('include_ext_views', 'true');\n  params.set('include_entities', 'true');\n  params.set('include_user_entities', 'true');\n  params.set('include_ext_media_color', 'true');\n  params.set('include_ext_media_availability', 'true');\n  params.set('include_ext_sensitive_media_warning', 'true');\n  params.set('include_ext_trusted_friends_metadata', 'true');\n  params.set('send_error_codes', 'true');\n  params.set('simple_quoted_tweet', 'true');\n  params.set('include_tweet_replies', `${includeTweetReplies}`);\n  params.set(\n    'ext',\n    'mediaStats,highlightedLabel,hasNftAvatar,voiceInfo,birdwatchPivot,enrichments,superFollowMetadata,unmentionInfo,editControl,collab_control,vibe'\n  );\n  return params;\n}\n","/**\n * Class representing an API error.\n */\n\nexport class ApiError extends Error {\n  /**\n   * Constructor for creating a new instance of the class.\n   *\n   * @param response The response object.\n   * @param data The data object.\n   * @param message The message string.\n   */\n  private constructor(\n    readonly response: Response,\n    readonly data: any,\n    message: string\n  ) {\n    super(message);\n  }\n\n  /**\n   * Creates an instance of ApiError based on a Response object.\n   *\n   * @param {Response} response The Response object to parse.\n   * @returns {Promise<ApiError>} A new instance of ApiError with the parsed data and status.\n   */\n  static async fromResponse(response: Response) {\n    // Try our best to parse the result, but don't bother if we can't\n    let data: string | object | undefined = undefined;\n    try {\n      data = await response.json();\n    } catch {\n      try {\n        data = await response.text();\n      } catch {}\n    }\n\n    return new ApiError(response, data, `Response status: ${response.status}`);\n  }\n}\n\n/**\n * Represents a position in a file with line and column information.\n * @interface Position\n * @property {number} line - The line number of the position.\n * @property {number} column - The column number of the position.\n */\ninterface Position {\n  line: number;\n  column: number;\n}\n\n/**\n * Interface representing trace information.\n * @property { string } trace_id - The ID of the trace.\n */\ninterface TraceInfo {\n  trace_id: string;\n}\n\n/**\n * Interface representing additional information that can be included in Twitter API error objects.\n * @typedef { Object } TwitterApiErrorExtensions\n * @property { number } [code] - The error code associated with the error.\n * @property { string } [kind] - The kind of error that occurred.\n * @property { string } [name] - The name of the error.\n * @property { string } [source] - The source of the error.\n * @property { TraceInfo } [tracing] - Information about the tracing of the error.\n */\ninterface TwitterApiErrorExtensions {\n  code?: number;\n  kind?: string;\n  name?: string;\n  source?: string;\n  tracing?: TraceInfo;\n}\n\n/**\n * Interface representing a raw Twitter API error object.\n * @interface\n * @extends {TwitterApiErrorExtensions}\n * @property {string} [message] The error message.\n * @property {Position[]} [locations] An array of positions.\n * @property {string[]} [path] An array representing the path of the error.\n * @property {TwitterApiErrorExtensions} [extensions] Additional error extensions.\n */\nexport interface TwitterApiErrorRaw extends TwitterApiErrorExtensions {\n  message?: string;\n  locations?: Position[];\n  path?: string[];\n  extensions?: TwitterApiErrorExtensions;\n}\n","/**\n * Randomizes the runtime's TLS ciphers to bypass TLS client fingerprinting, which\n * hopefully avoids random 404s on some requests.\n *\n * **References:**\n * - https://github.com/imputnet/cobalt/pull/574\n */\nexport interface PlatformExtensions {\n  /**\n   * Randomizes the runtime's TLS ciphers to bypass TLS client fingerprinting, which\n   * hopefully avoids random 404s on some requests.\n   *\n   * **References:**\n   * - https://github.com/imputnet/cobalt/pull/574\n   */\n  randomizeCiphers(): Promise<void>;\n}\n\nexport const genericPlatform = new (class implements PlatformExtensions {\n  randomizeCiphers(): Promise<void> {\n    return Promise.resolve();\n  }\n})();\n","import { type PlatformExtensions, genericPlatform } from './platform-interface.js';\n\nexport * from './platform-interface.js';\n\nconst PLATFORM_NODE: boolean = typeof process !== 'undefined';\n\n/**\n * Class representing a platform with cipher randomization functionality.\n */\nexport class Platform implements PlatformExtensions {\n  /**\n   * Asynchronously generates random ciphers using the imported platform\n   */\n  async randomizeCiphers() {\n    const platform = await Platform.importPlatform();\n    await platform?.randomizeCiphers();\n  }\n\n  /**\n   * Imports and returns the platform extensions based on the current platform.\n   * @returns A Promise that resolves to the platform extensions, or null if the platform is not supported.\n   */\n  private static async importPlatform(): Promise<null | PlatformExtensions> {\n    if (PLATFORM_NODE) {\n      const { platform } = await import('./node/index.js');\n      return platform as PlatformExtensions;\n    }\n\n    return genericPlatform;\n  }\n}\n","import type { Headers as HeadersPolyfill } from 'headers-polyfill';\nimport setCookie from 'set-cookie-parser';\nimport { Cookie, type CookieJar } from 'tough-cookie';\n\n/**\n * Updates a cookie jar with the Set-Cookie headers from the provided Headers instance.\n * @param cookieJar The cookie jar to update.\n * @param headers The response headers to populate the cookie jar with.\n */\n/**\n * Updates the provided CookieJar with cookies from the given Headers or document.cookie.\n * @param {CookieJar} cookieJar - The CookieJar to update.\n * @param {Headers | HeadersPolyfill} headers - The Headers object containing cookie information.\n * @returns {Promise<void>} - A Promise that resolves once the update is complete.\n */\nexport async function updateCookieJar(cookieJar: CookieJar, headers: Headers | HeadersPolyfill) {\n  const setCookieHeader = headers.get('set-cookie');\n  if (setCookieHeader) {\n    const cookies = setCookie.splitCookiesString(setCookieHeader);\n    for (const cookie of cookies.map((c) => Cookie.parse(c))) {\n      if (!cookie) continue;\n      await cookieJar.setCookie(\n        cookie,\n        `${cookie.secure ? 'https' : 'http'}://${cookie.domain}${cookie.path}`\n      );\n    }\n  } else if (typeof document !== 'undefined') {\n    for (const cookie of document.cookie.split(';')) {\n      const hardCookie = Cookie.parse(cookie);\n      if (hardCookie) {\n        await cookieJar.setCookie(hardCookie, document.location.toString());\n      }\n    }\n  }\n}\n","import { Headers } from 'headers-polyfill';\nimport { type Cookie, CookieJar, type MemoryCookieStore } from 'tough-cookie';\nimport { TwitterApi } from 'twitter-api-v2';\nimport type { FetchTransformOptions } from './api';\nimport type { Profile } from './profile';\nimport { updateCookieJar } from './requests';\n\n/**\n * Represents the TwitterAuthOptions interface that defines the properties required for Twitter authentication.\n * @property {typeof fetch} fetch - The fetch function to use for making HTTP requests.\n * @property {Partial<FetchTransformOptions>} transform - The partial options for transforming fetch requests.\n */\nexport interface TwitterAuthOptions {\n  fetch: typeof fetch;\n  transform: Partial<FetchTransformOptions>;\n}\n\n/**\n * Interface for Twitter authentication functionality.\n * @interface\n */\n\nexport interface TwitterAuth {\n  fetch: typeof fetch;\n\n  /**\n   * Returns the current cookie jar.\n   */\n  cookieJar(): CookieJar;\n\n  /**\n   * Logs into a Twitter account using the v2 API\n   */\n  loginWithV2(appKey: string, appSecret: string, accessToken: string, accessSecret: string): void;\n\n  /**\n   * Get v2 API client if it exists\n   */\n  getV2Client(): TwitterApi | null;\n\n  /**\n   * Returns if a user is logged-in to Twitter through this instance.\n   * @returns `true` if a user is logged-in; otherwise `false`.\n   */\n  isLoggedIn(): Promise<boolean>;\n\n  /**\n   * Fetches the current user's profile.\n   */\n  me(): Promise<Profile | undefined>;\n\n  /**\n   * Logs into a Twitter account.\n   * @param username The username to log in with.\n   * @param password The password to log in with.\n   * @param email The email to log in with, if you have email confirmation enabled.\n   * @param twoFactorSecret The secret to generate two factor authentication tokens with, if you have two factor authentication enabled.\n   */\n  login(\n    username: string,\n    password: string,\n    email?: string,\n    twoFactorSecret?: string\n  ): Promise<void>;\n\n  /**\n   * Logs out of the current session.\n   */\n  logout(): Promise<void>;\n\n  /**\n   * Deletes the current guest token token.\n   */\n  deleteToken(): void;\n\n  /**\n   * Returns if the authentication state has a token.\n   * @returns `true` if the authentication state has a token; `false` otherwise.\n   */\n  hasToken(): boolean;\n\n  /**\n   * Returns the time that authentication was performed.\n   * @returns The time at which the authentication token was created, or `null` if it hasn't been created yet.\n   */\n  authenticatedAt(): Date | null;\n\n  /**\n   * Installs the authentication information into a headers-like object. If needed, the\n   * authentication token will be updated from the API automatically.\n   * @param headers A Headers instance representing a request's headers.\n   */\n  installTo(headers: Headers, url: string): Promise<void>;\n}\n\n/**\n * Wraps the provided fetch function with transforms.\n * @param fetchFn The fetch function.\n * @param transform The transform options.\n * @returns The input fetch function, wrapped with the provided transforms.\n */\nfunction withTransform(\n  fetchFn: typeof fetch,\n  transform?: Partial<FetchTransformOptions>\n): typeof fetch {\n  return async (input, init) => {\n    const fetchArgs = (await transform?.request?.(input, init)) ?? [input, init];\n    // @ts-expect-error don't care\n    const res = await fetchFn(...fetchArgs);\n    return (await transform?.response?.(res)) ?? res;\n  };\n}\n\n/**\n * A guest authentication token manager. Automatically handles token refreshes.\n */\nexport class TwitterGuestAuth implements TwitterAuth {\n  protected bearerToken: string;\n  protected jar: CookieJar;\n  protected guestToken?: string;\n  protected guestCreatedAt?: Date;\n  protected v2Client: TwitterApi | null;\n\n  fetch: typeof fetch;\n\n  constructor(\n    bearerToken: string,\n    protected readonly options?: Partial<TwitterAuthOptions>\n  ) {\n    this.fetch = withTransform(options?.fetch ?? fetch, options?.transform);\n    this.bearerToken = bearerToken;\n    this.jar = new CookieJar();\n    this.v2Client = null;\n  }\n\n  cookieJar(): CookieJar {\n    return this.jar;\n  }\n\n  getV2Client(): TwitterApi | null {\n    return this.v2Client ?? null;\n  }\n\n  loginWithV2(appKey: string, appSecret: string, accessToken: string, accessSecret: string): void {\n    const v2Client = new TwitterApi({\n      appKey,\n      appSecret,\n      accessToken,\n      accessSecret,\n    });\n    this.v2Client = v2Client;\n  }\n\n  isLoggedIn(): Promise<boolean> {\n    return Promise.resolve(false);\n  }\n\n  async me(): Promise<Profile | undefined> {\n    return undefined;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  login(_username: string, _password: string, _email?: string): Promise<void> {\n    return this.updateGuestToken();\n  }\n\n  logout(): Promise<void> {\n    this.deleteToken();\n    this.jar = new CookieJar();\n    return Promise.resolve();\n  }\n\n  deleteToken() {\n    this.guestToken = undefined;\n    this.guestCreatedAt = undefined;\n  }\n\n  hasToken(): boolean {\n    return this.guestToken != null;\n  }\n\n  authenticatedAt(): Date | null {\n    if (this.guestCreatedAt == null) {\n      return null;\n    }\n\n    return new Date(this.guestCreatedAt);\n  }\n\n  async installTo(headers: Headers): Promise<void> {\n    if (this.shouldUpdate()) {\n      await this.updateGuestToken();\n    }\n\n    const token = this.guestToken;\n    if (token == null) {\n      throw new Error('Authentication token is null or undefined.');\n    }\n\n    headers.set('authorization', `Bearer ${this.bearerToken}`);\n    headers.set('x-guest-token', token);\n\n    const cookies = await this.getCookies();\n    const xCsrfToken = cookies.find((cookie) => cookie.key === 'ct0');\n    if (xCsrfToken) {\n      headers.set('x-csrf-token', xCsrfToken.value);\n    }\n\n    headers.set('cookie', await this.getCookieString());\n  }\n\n  protected getCookies(): Promise<Cookie[]> {\n    return this.jar.getCookies(this.getCookieJarUrl());\n  }\n\n  protected getCookieString(): Promise<string> {\n    return this.jar.getCookieString(this.getCookieJarUrl());\n  }\n\n  protected async removeCookie(key: string): Promise<void> {\n    const store: MemoryCookieStore = this.jar.store;\n    const cookies = await this.jar.getCookies(this.getCookieJarUrl());\n    for (const cookie of cookies) {\n      if (!cookie.domain || !cookie.path) continue;\n      store.removeCookie(cookie.domain, cookie.path, key);\n\n      if (typeof document !== 'undefined') {\n        document.cookie = `${cookie.key}=; Max-Age=0; path=${cookie.path}; domain=${cookie.domain}`;\n      }\n    }\n  }\n\n  private getCookieJarUrl(): string {\n    return typeof document !== 'undefined' ? document.location.toString() : 'https://twitter.com';\n  }\n\n  /**\n   * Updates the authentication state with a new guest token from the Twitter API.\n   */\n  protected async updateGuestToken() {\n    const guestActivateUrl = 'https://api.twitter.com/1.1/guest/activate.json';\n\n    const headers = new Headers({\n      Authorization: `Bearer ${this.bearerToken}`,\n      Cookie: await this.getCookieString(),\n    });\n\n    const res = await this.fetch(guestActivateUrl, {\n      method: 'POST',\n      headers: headers as any,\n      referrerPolicy: 'no-referrer',\n    });\n\n    await updateCookieJar(this.jar, res.headers);\n\n    if (!res.ok) {\n      throw new Error(await res.text());\n    }\n\n    const o = await res.json();\n    if (o == null || o.guest_token == null) {\n      throw new Error('guest_token not found.');\n    }\n\n    const newGuestToken = o.guest_token;\n    if (typeof newGuestToken !== 'string') {\n      throw new Error('guest_token was not a string.');\n    }\n\n    this.guestToken = newGuestToken;\n    this.guestCreatedAt = new Date();\n  }\n\n  /**\n   * Returns if the authentication token needs to be updated or not.\n   * @returns `true` if the token needs to be updated; `false` otherwise.\n   */\n  private shouldUpdate(): boolean {\n    return (\n      !this.hasToken() ||\n      (this.guestCreatedAt != null &&\n        this.guestCreatedAt < new Date(new Date().valueOf() - 3 * 60 * 60 * 1000))\n    );\n  }\n}\n","import { type Static, Type } from '@sinclair/typebox';\nimport { Check } from '@sinclair/typebox/value';\nimport { Headers } from 'headers-polyfill';\nimport * as OTPAuth from 'otpauth';\nimport { CookieJar } from 'tough-cookie';\nimport { requestApi } from './api';\nimport { type TwitterAuthOptions, TwitterGuestAuth } from './auth';\nimport type { TwitterApiErrorRaw } from './errors';\nimport { type LegacyUserRaw, type Profile, parseProfile } from './profile';\nimport { updateCookieJar } from './requests';\n\n/**\n * Interface representing the init request for a Twitter user authentication flow.\n * @typedef {Object} TwitterUserAuthFlowInitRequest\n * @property {string} flow_name - The name of the flow.\n * @property {Record<string, unknown>} input_flow_data - The input flow data.\n */\ninterface TwitterUserAuthFlowInitRequest {\n  flow_name: string;\n  input_flow_data: Record<string, unknown>;\n}\n\n/**\n * Interface representing a request for a subtask in the Twitter user authentication flow.\n * @typedef {object} TwitterUserAuthFlowSubtaskRequest\n * @property {string} flow_token - The token representing the flow.\n * @property {object[]} subtask_inputs - An array of subtask inputs, each containing a subtask ID and other unknown properties.\n */\ninterface TwitterUserAuthFlowSubtaskRequest {\n  flow_token: string;\n  subtask_inputs: ({\n    subtask_id: string;\n  } & Record<string, unknown>)[];\n}\n\n/**\n * Represents a request for a Twitter user authentication flow, which can be either an init request\n * or a subtask request.\n */\n\ntype TwitterUserAuthFlowRequest =\n  | TwitterUserAuthFlowInitRequest\n  | TwitterUserAuthFlowSubtaskRequest;\n\n/**\n * Interface representing the response object of the Twitter user authentication flow.\n * @property {TwitterApiErrorRaw[]} [errors] The errors occurred during the authentication flow.\n * @property {string} [flow_token] The token associated with the authentication flow.\n * @property {string} [status] The status of the authentication flow.\n * @property {TwitterUserAuthSubtask[]} [subtasks] The subtasks involved in the authentication flow.\n */\ninterface TwitterUserAuthFlowResponse {\n  errors?: TwitterApiErrorRaw[];\n  flow_token?: string;\n  status?: string;\n  subtasks?: TwitterUserAuthSubtask[];\n}\n\n/**\n * Interface representing the response structure for verifying Twitter user authentication credentials.\n *\n * @property {TwitterApiErrorRaw[]} [errors] Optional array of Twitter API errors.\n */\ninterface TwitterUserAuthVerifyCredentials {\n  errors?: TwitterApiErrorRaw[];\n}\n\nconst TwitterUserAuthSubtask = Type.Object({\n  subtask_id: Type.String(),\n  enter_text: Type.Optional(Type.Object({})),\n});\n/**\n * Represents the type of a Twitter user authentication subtask.\n */\ntype TwitterUserAuthSubtask = Static<typeof TwitterUserAuthSubtask>;\n\n/**\n * Represents the result of a successful flow token generation.\n * @typedef {Object} FlowTokenResultSuccess\n * @property {string} status - The status of the result (always \"success\").\n * @property {string} flowToken - The generated flow token.\n * @property {TwitterUserAuthSubtask} [subtask] - Optional subtask related to Twitter user authentication.\n */\ntype FlowTokenResultSuccess = {\n  status: 'success';\n  flowToken: string;\n  subtask?: TwitterUserAuthSubtask;\n};\n\n/**\n * Represents the result of a FlowToken operation, which can either be a success with the token or an error with the error details.\n * @typedef {FlowTokenResultSuccess | { status: \"error\"; err: Error }} FlowTokenResult\n */\ntype FlowTokenResult = FlowTokenResultSuccess | { status: 'error'; err: Error };\n\n/**\n * A user authentication token manager.\n */\n/**\n * Class representing Twitter User Authentication.\n * Extends TwitterGuestAuth class.\n */\nexport class TwitterUserAuth extends TwitterGuestAuth {\n  private userProfile: Profile | undefined;\n\n  async isLoggedIn(): Promise<boolean> {\n    const res = await requestApi<TwitterUserAuthVerifyCredentials>(\n      'https://api.twitter.com/1.1/account/verify_credentials.json',\n      this\n    );\n    if (!res.success) {\n      return false;\n    }\n\n    const { value: verify } = res;\n    this.userProfile = parseProfile(\n      verify as LegacyUserRaw,\n      (verify as unknown as { verified: boolean }).verified\n    );\n    return verify && !verify.errors?.length;\n  }\n\n  async me(): Promise<Profile | undefined> {\n    if (this.userProfile) {\n      return this.userProfile;\n    }\n    await this.isLoggedIn();\n    return this.userProfile;\n  }\n\n  async login(\n    username: string,\n    password: string,\n    email?: string,\n    twoFactorSecret?: string,\n    appKey?: string,\n    appSecret?: string,\n    accessToken?: string,\n    accessSecret?: string\n  ): Promise<void> {\n    await this.updateGuestToken();\n\n    let next = await this.initLogin();\n    while ('subtask' in next && next.subtask) {\n      if (next.subtask.subtask_id === 'LoginJsInstrumentationSubtask') {\n        next = await this.handleJsInstrumentationSubtask(next);\n      } else if (next.subtask.subtask_id === 'LoginEnterUserIdentifierSSO') {\n        next = await this.handleEnterUserIdentifierSSO(next, username);\n      } else if (next.subtask.subtask_id === 'LoginEnterAlternateIdentifierSubtask') {\n        next = await this.handleEnterAlternateIdentifierSubtask(next, email as string);\n      } else if (next.subtask.subtask_id === 'LoginEnterPassword') {\n        next = await this.handleEnterPassword(next, password);\n      } else if (next.subtask.subtask_id === 'AccountDuplicationCheck') {\n        next = await this.handleAccountDuplicationCheck(next);\n      } else if (next.subtask.subtask_id === 'LoginTwoFactorAuthChallenge') {\n        if (twoFactorSecret) {\n          next = await this.handleTwoFactorAuthChallenge(next, twoFactorSecret);\n        } else {\n          throw new Error('Requested two factor authentication code but no secret provided');\n        }\n      } else if (next.subtask.subtask_id === 'LoginAcid') {\n        next = await this.handleAcid(next, email);\n      } else if (next.subtask.subtask_id === 'LoginSuccessSubtask') {\n        next = await this.handleSuccessSubtask(next);\n      } else {\n        throw new Error(`Unknown subtask ${next.subtask.subtask_id}`);\n      }\n    }\n    if (appKey && appSecret && accessToken && accessSecret) {\n      this.loginWithV2(appKey, appSecret, accessToken, accessSecret);\n    }\n    if ('err' in next) {\n      throw next.err;\n    }\n  }\n\n  async logout(): Promise<void> {\n    if (!this.isLoggedIn()) {\n      return;\n    }\n\n    await requestApi<void>('https://api.twitter.com/1.1/account/logout.json', this, 'POST');\n    this.deleteToken();\n    this.jar = new CookieJar();\n  }\n\n  async installCsrfToken(headers: Headers): Promise<void> {\n    const cookies = await this.getCookies();\n    const xCsrfToken = cookies.find((cookie) => cookie.key === 'ct0');\n    if (xCsrfToken) {\n      headers.set('x-csrf-token', xCsrfToken.value);\n    }\n  }\n\n  async installTo(headers: Headers): Promise<void> {\n    headers.set('authorization', `Bearer ${this.bearerToken}`);\n    headers.set('cookie', await this.getCookieString());\n    await this.installCsrfToken(headers);\n  }\n\n  private async initLogin() {\n    // Reset certain session-related cookies because Twitter complains sometimes if we don't\n    this.removeCookie('twitter_ads_id=');\n    this.removeCookie('ads_prefs=');\n    this.removeCookie('_twitter_sess=');\n    this.removeCookie('zipbox_forms_auth_token=');\n    this.removeCookie('lang=');\n    this.removeCookie('bouncer_reset_cookie=');\n    this.removeCookie('twid=');\n    this.removeCookie('twitter_ads_idb=');\n    this.removeCookie('email_uid=');\n    this.removeCookie('external_referer=');\n    this.removeCookie('ct0=');\n    this.removeCookie('aa_u=');\n\n    return await this.executeFlowTask({\n      flow_name: 'login',\n      input_flow_data: {\n        flow_context: {\n          debug_overrides: {},\n          start_location: {\n            location: 'splash_screen',\n          },\n        },\n      },\n    });\n  }\n\n  private async handleJsInstrumentationSubtask(prev: FlowTokenResultSuccess) {\n    return await this.executeFlowTask({\n      flow_token: prev.flowToken,\n      subtask_inputs: [\n        {\n          subtask_id: 'LoginJsInstrumentationSubtask',\n          js_instrumentation: {\n            response: '{}',\n            link: 'next_link',\n          },\n        },\n      ],\n    });\n  }\n\n  private async handleEnterAlternateIdentifierSubtask(prev: FlowTokenResultSuccess, email: string) {\n    return await this.executeFlowTask({\n      flow_token: prev.flowToken,\n      subtask_inputs: [\n        {\n          subtask_id: 'LoginEnterAlternateIdentifierSubtask',\n          enter_text: {\n            text: email,\n            link: 'next_link',\n          },\n        },\n      ],\n    });\n  }\n\n  private async handleEnterUserIdentifierSSO(prev: FlowTokenResultSuccess, username: string) {\n    return await this.executeFlowTask({\n      flow_token: prev.flowToken,\n      subtask_inputs: [\n        {\n          subtask_id: 'LoginEnterUserIdentifierSSO',\n          settings_list: {\n            setting_responses: [\n              {\n                key: 'user_identifier',\n                response_data: {\n                  text_data: { result: username },\n                },\n              },\n            ],\n            link: 'next_link',\n          },\n        },\n      ],\n    });\n  }\n\n  private async handleEnterPassword(prev: FlowTokenResultSuccess, password: string) {\n    return await this.executeFlowTask({\n      flow_token: prev.flowToken,\n      subtask_inputs: [\n        {\n          subtask_id: 'LoginEnterPassword',\n          enter_password: {\n            password,\n            link: 'next_link',\n          },\n        },\n      ],\n    });\n  }\n\n  private async handleAccountDuplicationCheck(prev: FlowTokenResultSuccess) {\n    return await this.executeFlowTask({\n      flow_token: prev.flowToken,\n      subtask_inputs: [\n        {\n          subtask_id: 'AccountDuplicationCheck',\n          check_logged_in_account: {\n            link: 'AccountDuplicationCheck_false',\n          },\n        },\n      ],\n    });\n  }\n\n  private async handleTwoFactorAuthChallenge(prev: FlowTokenResultSuccess, secret: string) {\n    const totp = new OTPAuth.TOTP({ secret });\n    let error;\n    for (let attempts = 1; attempts < 4; attempts += 1) {\n      try {\n        return await this.executeFlowTask({\n          flow_token: prev.flowToken,\n          subtask_inputs: [\n            {\n              subtask_id: 'LoginTwoFactorAuthChallenge',\n              enter_text: {\n                link: 'next_link',\n                text: totp.generate(),\n              },\n            },\n          ],\n        });\n      } catch (err) {\n        error = err;\n        await new Promise((resolve) => setTimeout(resolve, 2000 * attempts));\n      }\n    }\n    throw error;\n  }\n\n  private async handleAcid(prev: FlowTokenResultSuccess, email: string | undefined) {\n    return await this.executeFlowTask({\n      flow_token: prev.flowToken,\n      subtask_inputs: [\n        {\n          subtask_id: 'LoginAcid',\n          enter_text: {\n            text: email,\n            link: 'next_link',\n          },\n        },\n      ],\n    });\n  }\n\n  private async handleSuccessSubtask(prev: FlowTokenResultSuccess) {\n    return await this.executeFlowTask({\n      flow_token: prev.flowToken,\n      subtask_inputs: [],\n    });\n  }\n\n  private async executeFlowTask(data: TwitterUserAuthFlowRequest): Promise<FlowTokenResult> {\n    const onboardingTaskUrl = 'https://api.twitter.com/1.1/onboarding/task.json';\n\n    const token = this.guestToken;\n    if (token == null) {\n      throw new Error('Authentication token is null or undefined.');\n    }\n\n    const headers = new Headers({\n      authorization: `Bearer ${this.bearerToken}`,\n      cookie: await this.getCookieString(),\n      'content-type': 'application/json',\n      'User-Agent':\n        'Mozilla/5.0 (Linux; Android 11; Nokia G20) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.88 Mobile Safari/537.36',\n      'x-guest-token': token,\n      'x-twitter-auth-type': 'OAuth2Client',\n      'x-twitter-active-user': 'yes',\n      'x-twitter-client-language': 'en',\n    });\n    await this.installCsrfToken(headers);\n\n    const res = await this.fetch(onboardingTaskUrl, {\n      credentials: 'include',\n      method: 'POST',\n      headers: headers,\n      body: JSON.stringify(data),\n    });\n\n    await updateCookieJar(this.jar, res.headers);\n\n    if (!res.ok) {\n      return { status: 'error', err: new Error(await res.text()) };\n    }\n\n    const flow: TwitterUserAuthFlowResponse = await res.json();\n    if (flow?.flow_token == null) {\n      return { status: 'error', err: new Error('flow_token not found.') };\n    }\n\n    if (flow.errors?.length) {\n      return {\n        status: 'error',\n        err: new Error(`Authentication error (${flow.errors[0].code}): ${flow.errors[0].message}`),\n      };\n    }\n\n    if (typeof flow.flow_token !== 'string') {\n      return {\n        status: 'error',\n        err: new Error('flow_token was not a string.'),\n      };\n    }\n\n    const subtask = flow.subtasks?.length ? flow.subtasks[0] : undefined;\n    Check(TwitterUserAuthSubtask, subtask);\n\n    if (subtask && subtask.subtask_id === 'DenyLoginSubtask') {\n      return {\n        status: 'error',\n        err: new Error('Authentication error: DenyLoginSubtask'),\n      };\n    }\n\n    return {\n      status: 'success',\n      subtask,\n      flowToken: flow.flow_token,\n    };\n  }\n}\n","import stringify from 'json-stable-stringify';\nimport { type RequestApiResult, requestApi } from './api';\nimport type { TwitterAuth } from './auth';\nimport type { TwitterApiErrorRaw } from './errors';\n\n/**\n * Interface representing a raw user object from a legacy system.\n * @typedef {Object} LegacyUserRaw\n * @property {string} [created_at] - The date the user was created.\n * @property {string} [description] - The user's description.\n * @property {Object} [entities] - Additional entities associated with the user.\n * @property {Object} [url] - The URL associated with the user.\n * @property {Object[]} [urls] - Array of URLs associated with the user.\n * @property {string} [expanded_url] - The expanded URL.\n * @property {number} [favourites_count] - The number of favorited items.\n * @property {number} [followers_count] - The number of followers.\n * @property {number} [friends_count] - The number of friends.\n * @property {number} [media_count] - The number of media items.\n * @property {number} [statuses_count] - The number of statuses.\n * @property {string} [id_str] - The user ID as a string.\n * @property {number} [listed_count] - The number of lists the user is listed in.\n * @property {string} [name] - The user's name.\n * @property {string} location - The user's location.\n * @property {boolean} [geo_enabled] - Indicates if geo locations are enabled.\n * @property {string[]} [pinned_tweet_ids_str] - Array of pinned tweet IDs as strings.\n * @property {string} [profile_background_color] - The background color of the user's profile.\n * @property {string} [profile_banner_url] - The URL of the user's profile banner.\n * @property {string} [profile_image_url_https] - The URL of the user's profile image (HTTPS).\n * @property {boolean} [protected] - Indicates if the user's account is protected.\n * @property {string} [screen_name] - The user's screen name.\n * @property {boolean} [verified] - Indicates if the user is verified.\n * @property {boolean} [has_custom_timelines] - Indicates if the user has custom timelines.\n * @property {boolean} [has_extended_profile] - Indicates if the user has an extended profile.\n * @property {string} [url] - The user's URL.\n * @property {boolean} [can_dm] - Indicates if direct messages are enabled for the user.\n */\nexport interface LegacyUserRaw {\n  created_at?: string;\n  description?: string;\n  entities?: {\n    url?: {\n      urls?: {\n        expanded_url?: string;\n      }[];\n    };\n  };\n  favourites_count?: number;\n  followers_count?: number;\n  friends_count?: number;\n  media_count?: number;\n  statuses_count?: number;\n  id_str?: string;\n  listed_count?: number;\n  name?: string;\n  location: string;\n  geo_enabled?: boolean;\n  pinned_tweet_ids_str?: string[];\n  profile_background_color?: string;\n  profile_banner_url?: string;\n  profile_image_url_https?: string;\n  protected?: boolean;\n  screen_name?: string;\n  verified?: boolean;\n  has_custom_timelines?: boolean;\n  has_extended_profile?: boolean;\n  url?: string;\n  can_dm?: boolean;\n}\n\n/**\n * A parsed profile object.\n */\n/**\n * Interface representing a user profile.\n * @typedef {Object} Profile\n * @property {string} [avatar] - The URL to the user's avatar.\n * @property {string} [banner] - The URL to the user's banner image.\n * @property {string} [biography] - The user's biography.\n * @property {string} [birthday] - The user's birthday.\n * @property {number} [followersCount] - The number of followers the user has.\n * @property {number} [followingCount] - The number of users the user is following.\n * @property {number} [friendsCount] - The number of friends the user has.\n * @property {number} [mediaCount] - The number of media items the user has posted.\n * @property {number} [statusesCount] - The number of statuses the user has posted.\n * @property {boolean} [isPrivate] - Indicates if the user's profile is private.\n * @property {boolean} [isVerified] - Indicates if the user account is verified.\n * @property {boolean} [isBlueVerified] - Indicates if the user account has blue verification badge.\n * @property {Date} [joined] - The date the user joined the platform.\n * @property {number} [likesCount] - The number of likes the user has received.\n * @property {number} [listedCount] - The number of times the user has been listed.\n * @property {string} location - The user's location.\n * @property {string} [name] - The user's name.\n * @property {string[]} [pinnedTweetIds] - The IDs of the user's pinned tweets.\n * @property {number} [tweetsCount] - The number of tweets the user has posted.\n * @property {string} [url] - The user's website URL.\n * @property {string} [userId] - The unique user ID.\n * @property {string} [username] - The user's username.\n * @property {string} [website] - The user's website.\n * @property {boolean} [canDm] - Indicates if the user can receive direct messages.\n */\nexport interface Profile {\n  avatar?: string;\n  banner?: string;\n  biography?: string;\n  birthday?: string;\n  followersCount?: number;\n  followingCount?: number;\n  friendsCount?: number;\n  mediaCount?: number;\n  statusesCount?: number;\n  isPrivate?: boolean;\n  isVerified?: boolean;\n  isBlueVerified?: boolean;\n  joined?: Date;\n  likesCount?: number;\n  listedCount?: number;\n  location: string;\n  name?: string;\n  pinnedTweetIds?: string[];\n  tweetsCount?: number;\n  url?: string;\n  userId?: string;\n  username?: string;\n  website?: string;\n  canDm?: boolean;\n}\n\nexport interface UserRaw {\n  data: {\n    user: {\n      result: {\n        rest_id?: string;\n        is_blue_verified?: boolean;\n        legacy: LegacyUserRaw;\n      };\n    };\n  };\n  errors?: TwitterApiErrorRaw[];\n}\n\nfunction getAvatarOriginalSizeUrl(avatarUrl: string | undefined) {\n  return avatarUrl ? avatarUrl.replace('_normal', '') : undefined;\n}\n\nexport function parseProfile(user: LegacyUserRaw, isBlueVerified?: boolean): Profile {\n  const profile: Profile = {\n    avatar: getAvatarOriginalSizeUrl(user.profile_image_url_https),\n    banner: user.profile_banner_url,\n    biography: user.description,\n    followersCount: user.followers_count,\n    followingCount: user.friends_count,\n    friendsCount: user.friends_count,\n    mediaCount: user.media_count,\n    isPrivate: user.protected ?? false,\n    isVerified: user.verified,\n    likesCount: user.favourites_count,\n    listedCount: user.listed_count,\n    location: user.location,\n    name: user.name,\n    pinnedTweetIds: user.pinned_tweet_ids_str,\n    tweetsCount: user.statuses_count,\n    url: `https://twitter.com/${user.screen_name}`,\n    userId: user.id_str,\n    username: user.screen_name,\n    isBlueVerified: isBlueVerified ?? false,\n    canDm: user.can_dm,\n  };\n\n  if (user.created_at != null) {\n    profile.joined = new Date(Date.parse(user.created_at));\n  }\n\n  const urls = user.entities?.url?.urls;\n  if (urls?.length != null && urls?.length > 0) {\n    profile.website = urls[0].expanded_url;\n  }\n\n  return profile;\n}\n\nexport async function getProfile(\n  username: string,\n  auth: TwitterAuth\n): Promise<RequestApiResult<Profile>> {\n  const params = new URLSearchParams();\n  params.set(\n    'variables',\n    stringify({\n      screen_name: username,\n      withSafetyModeUserFields: true,\n    }) ?? ''\n  );\n\n  params.set(\n    'features',\n    stringify({\n      hidden_profile_likes_enabled: false,\n      hidden_profile_subscriptions_enabled: false, // Auth-restricted\n      responsive_web_graphql_exclude_directive_enabled: true,\n      verified_phone_label_enabled: false,\n      subscriptions_verification_info_is_identity_verified_enabled: false,\n      subscriptions_verification_info_verified_since_enabled: true,\n      highlights_tweets_tab_ui_enabled: true,\n      creator_subscriptions_tweet_preview_api_enabled: true,\n      responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,\n      responsive_web_graphql_timeline_navigation_enabled: true,\n    }) ?? ''\n  );\n\n  params.set('fieldToggles', stringify({ withAuxiliaryUserLabels: false }) ?? '');\n\n  const res = await requestApi<UserRaw>(\n    `https://twitter.com/i/api/graphql/G3KGOASz96M-Qu0nwmGXNg/UserByScreenName?${params.toString()}`,\n    auth\n  );\n  if (!res.success) {\n    return res as any;\n  }\n\n  const { value } = res;\n  const { errors } = value;\n  if (errors != null && errors.length > 0) {\n    return {\n      success: false,\n      err: new Error(errors[0].message),\n    };\n  }\n\n  if (!value.data || !value.data.user || !value.data.user.result) {\n    return {\n      success: false,\n      err: new Error('User not found.'),\n    };\n  }\n  const { result: user } = value.data.user;\n  const { legacy } = user;\n\n  if (user.rest_id == null || user.rest_id.length === 0) {\n    return {\n      success: false,\n      err: new Error('rest_id not found.'),\n    };\n  }\n\n  legacy.id_str = user.rest_id;\n\n  if (legacy.screen_name == null || legacy.screen_name.length === 0) {\n    return {\n      success: false,\n      err: new Error(`Either ${username} does not exist or is private.`),\n    };\n  }\n\n  return {\n    success: true,\n    value: parseProfile(user.legacy, user.is_blue_verified),\n  };\n}\n\nconst idCache = new Map<string, string>();\n\nexport async function getScreenNameByUserId(\n  userId: string,\n  auth: TwitterAuth\n): Promise<RequestApiResult<string>> {\n  const params = new URLSearchParams();\n  params.set(\n    'variables',\n    stringify({\n      userId: userId,\n      withSafetyModeUserFields: true,\n    }) ?? ''\n  );\n\n  params.set(\n    'features',\n    stringify({\n      hidden_profile_subscriptions_enabled: true,\n      rweb_tipjar_consumption_enabled: true,\n      responsive_web_graphql_exclude_directive_enabled: true,\n      verified_phone_label_enabled: false,\n      highlights_tweets_tab_ui_enabled: true,\n      responsive_web_twitter_article_notes_tab_enabled: true,\n      subscriptions_feature_can_gift_premium: false,\n      creator_subscriptions_tweet_preview_api_enabled: true,\n      responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,\n      responsive_web_graphql_timeline_navigation_enabled: true,\n    }) ?? ''\n  );\n\n  const res = await requestApi<UserRaw>(\n    `https://twitter.com/i/api/graphql/xf3jd90KKBCUxdlI_tNHZw/UserByRestId?${params.toString()}`,\n    auth\n  );\n\n  if (!res.success) {\n    return res as any;\n  }\n\n  const { value } = res;\n  const { errors } = value;\n  if (errors != null && errors.length > 0) {\n    return {\n      success: false,\n      err: new Error(errors[0].message),\n    };\n  }\n\n  if (!value.data || !value.data.user || !value.data.user.result) {\n    return {\n      success: false,\n      err: new Error('User not found.'),\n    };\n  }\n\n  const { result: user } = value.data.user;\n  const { legacy } = user;\n\n  if (legacy.screen_name == null || legacy.screen_name.length === 0) {\n    return {\n      success: false,\n      err: new Error(`Either user with ID ${userId} does not exist or is private.`),\n    };\n  }\n\n  return {\n    success: true,\n    value: legacy.screen_name,\n  };\n}\n\nexport async function getEntityIdByScreenName(\n  screenName: string,\n  auth: TwitterAuth\n): Promise<RequestApiResult<string>> {\n  const cached = idCache.get(screenName);\n  if (cached != null) {\n    return { success: true, value: cached };\n  }\n\n  const profileRes = await getProfile(screenName, auth);\n  if (!profileRes.success) {\n    return profileRes as any;\n  }\n\n  const profile = profileRes.value;\n  if (profile.userId != null) {\n    idCache.set(screenName, profile.userId);\n\n    return {\n      success: true,\n      value: profile.userId,\n    };\n  }\n\n  return {\n    success: false,\n    err: new Error('User ID is undefined.'),\n  };\n}\n","import { requestApi } from './api';\nimport type { TwitterAuth } from './auth';\n\n/**\n * Interface representing a Grok conversation object.\n * @interface\n * @property {Object} data - The data object containing information about the conversation.\n * @property {Object} data.create_grok_conversation - The object containing the created Grok conversation.\n * @property {string} data.create_grok_conversation.conversation_id - The ID of the created conversation.\n */\nexport interface GrokConversation {\n  data: {\n    create_grok_conversation: {\n      conversation_id: string;\n    };\n  };\n}\n\n/**\n * Interface representing a Grok request.\n *\n * @property {GrokResponseMessage[]} responses - Array of GrokResponseMessage objects.\n * @property {string} systemPromptName - Name of the system prompt.\n * @property {string} grokModelOptionId - ID of the Grok model option.\n * @property {string} conversationId - ID of the conversation.\n * @property {boolean} returnSearchResults - Indicates if search results should be returned.\n * @property {boolean} returnCitations - Indicates if citations should be returned.\n * @property {Object} promptMetadata - Additional metadata for the prompt.\n * @property {string} promptMetadata.promptSource - Source of the prompt.\n * @property {string} promptMetadata.action - Action related to the prompt.\n * @property {number} imageGenerationCount - Number of image generations.\n * @property {Object} requestFeatures - Additional features requested for the request.\n * @property {boolean} requestFeatures.eagerTweets - Indicates if eager tweets are requested.\n * @property {boolean} requestFeatures.serverHistory - Indicates if server history is requested.\n */\n\nexport interface GrokRequest {\n  responses: GrokResponseMessage[];\n  systemPromptName: string;\n  grokModelOptionId: string;\n  conversationId: string;\n  returnSearchResults: boolean;\n  returnCitations: boolean;\n  promptMetadata: {\n    promptSource: string;\n    action: string;\n  };\n  imageGenerationCount: number;\n  requestFeatures: {\n    eagerTweets: boolean;\n    serverHistory: boolean;\n  };\n}\n\n// Types for the user-facing API\n/**\n * Interface representing a GrokMessage object.\n * @interface\n * @property {string} role - The role of the message, can be either \"user\" or \"assistant\".\n * @property {string} content - The content of the message.\n */\nexport interface GrokMessage {\n  role: 'user' | 'assistant';\n  content: string;\n}\n\n/**\n * Interface for specifying options when using GrokChat.\n * @typedef {Object} GrokChatOptions\n * @property {GrokMessage[]} messages - Array of GrokMessage objects\n * @property {string} [conversationId] - Optional ID for the conversation. Will create new if not provided\n * @property {boolean} [returnSearchResults] - Flag to indicate whether to return search results\n * @property {boolean} [returnCitations] - Flag to indicate whether to return citations\n */\nexport interface GrokChatOptions {\n  messages: GrokMessage[];\n  conversationId?: string; // Optional - will create new if not provided\n  returnSearchResults?: boolean;\n  returnCitations?: boolean;\n}\n\n// Internal types for API requests\n/**\n * Interface for a Grok response message.\n * @property {string} message - The message content.\n * @property {1|2} sender - The sender of the message. 1 = user, 2 = assistant.\n * @property {string} [promptSource] - The source of the prompt (optional).\n * @property {any[]} [fileAttachments] - An array of file attachments (optional).\n */\nexport interface GrokResponseMessage {\n  message: string;\n  sender: 1 | 2; // 1 = user, 2 = assistant\n  promptSource?: string;\n  fileAttachments?: any[];\n}\n\n// Rate limit information\n/**\n * Interface representing a Grok rate limit response.\n * @typedef { Object } GrokRateLimit\n * @property { boolean } isRateLimited - Flag indicating if the rate limit is in effect.\n * @property { string } message - The message associated with the rate limit.\n * @property { Object } upsellInfo - Object containing additional information about the rate limit (optional).\n * @property { string } upsellInfo.usageLimit - The usage limit imposed by the rate limit.\n * @property { string } upsellInfo.quotaDuration - The duration of the quota for the rate limit.\n * @property { string } upsellInfo.title - The title related to the rate limit.\n * @property { string } upsellInfo.message - Additional message related to the rate limit.\n */\nexport interface GrokRateLimit {\n  isRateLimited: boolean;\n  message: string;\n  upsellInfo?: {\n    usageLimit: string;\n    quotaDuration: string;\n    title: string;\n    message: string;\n  };\n}\n\n/**\n * Interface for the response from the GrokChat API.\n * @typedef {object} GrokChatResponse\n * @property {string} conversationId - The ID of the conversation.\n * @property {string} message - The message content.\n * @property {Array<GrokMessage>} messages - An array of GrokMessage objects.\n * @property {Array<any>} [webResults] - Optional array of web results.\n * @property {object} [metadata] - Optional metadata object.\n * @property {object} [rateLimit] - Optional rate limit information.\n */\nexport interface GrokChatResponse {\n  conversationId: string;\n  message: string;\n  messages: GrokMessage[];\n  webResults?: any[];\n  metadata?: any;\n  rateLimit?: GrokRateLimit;\n}\n\n/**\n * Creates a new conversation with Grok.\n * @returns The ID of the newly created conversation\n * @internal\n */\n/**\n * Creates a Grok conversation using the provided Twitter authorization credentials.\n *\n * @param {TwitterAuth} auth - Twitter authorization credentials required to make the API request.\n * @returns {Promise<string>} A promise that resolves with the conversation ID of the newly created Grok conversation.\n */\nexport async function createGrokConversation(auth: TwitterAuth): Promise<string> {\n  const res = await requestApi<GrokConversation>(\n    'https://x.com/i/api/graphql/6cmfJY3d7EPWuCSXWrkOFg/CreateGrokConversation',\n    auth,\n    'POST'\n  );\n\n  if (!res.success) {\n    throw (res as any).err;\n  }\n\n  return res.value.data.create_grok_conversation.conversation_id;\n}\n\n/**\n * Main method for interacting with Grok in a chat-like manner.\n */\nexport async function grokChat(\n  options: GrokChatOptions,\n  auth: TwitterAuth\n): Promise<GrokChatResponse> {\n  let { conversationId, messages } = options;\n\n  // Create new conversation if none provided\n  if (!conversationId) {\n    conversationId = await createGrokConversation(auth);\n  }\n\n  // Convert OpenAI-style messages to Grok's internal format\n  const responses: GrokResponseMessage[] = messages.map((msg: GrokMessage) => ({\n    message: msg.content,\n    sender: msg.role === 'user' ? 1 : 2,\n    ...(msg.role === 'user' && {\n      promptSource: '',\n      fileAttachments: [],\n    }),\n  }));\n\n  const payload: GrokRequest = {\n    responses,\n    systemPromptName: '',\n    grokModelOptionId: 'grok-2a',\n    conversationId,\n    returnSearchResults: options.returnSearchResults ?? true,\n    returnCitations: options.returnCitations ?? true,\n    promptMetadata: {\n      promptSource: 'NATURAL',\n      action: 'INPUT',\n    },\n    imageGenerationCount: 4,\n    requestFeatures: {\n      eagerTweets: true,\n      serverHistory: true,\n    },\n  };\n\n  const res = await requestApi<{ text: string }>(\n    'https://api.x.com/2/grok/add_response.json',\n    auth,\n    'POST',\n    undefined,\n    payload\n  );\n\n  if (!res.success) {\n    throw (res as any).err;\n  }\n\n  // Parse response chunks - Grok may return either a single response or multiple chunks\n  let chunks: any[];\n  if (res.value.text) {\n    // For streaming responses, split text into chunks and parse each JSON chunk\n    chunks = res.value.text\n      .split('\\n')\n      .filter(Boolean)\n      .map((chunk: any) => JSON.parse(chunk));\n  } else {\n    // For single responses (like rate limiting), wrap in array\n    chunks = [res.value];\n  }\n\n  // Check if we hit rate limits by examining first chunk\n  const firstChunk = chunks[0];\n  if (firstChunk.result?.responseType === 'limiter') {\n    return {\n      conversationId,\n      message: firstChunk.result.message,\n      messages: [...messages, { role: 'assistant', content: firstChunk.result.message }],\n      rateLimit: {\n        isRateLimited: true,\n        message: firstChunk.result.message,\n        upsellInfo: firstChunk.result.upsell\n          ? {\n              usageLimit: firstChunk.result.upsell.usageLimit,\n              quotaDuration: `${firstChunk.result.upsell.quotaDurationCount} ${firstChunk.result.upsell.quotaDurationPeriod}`,\n              title: firstChunk.result.upsell.title,\n              message: firstChunk.result.upsell.message,\n            }\n          : undefined,\n      },\n    };\n  }\n\n  // Combine all message chunks into single response\n  const fullMessage = chunks\n    .filter((chunk: any) => chunk.result?.message)\n    .map((chunk: any) => chunk.result.message)\n    .join('');\n\n  // Return complete response with conversation history and metadata\n  return {\n    conversationId,\n    message: fullMessage,\n    messages: [...messages, { role: 'assistant', content: fullMessage }],\n    webResults: chunks.find((chunk: any) => chunk.result?.webResults)?.result.webResults,\n    metadata: chunks[0],\n  };\n}\n","import type { TwitterAuth } from './auth';\nimport { updateCookieJar } from './requests';\n\n/**\n * Represents a direct message object.\n * @typedef {Object} DirectMessage\n * @property {string} id - The unique identifier of the direct message.\n * @property {string} text - The text content of the direct message.\n * @property {string} senderId - The unique identifier of the sender of the direct message.\n * @property {string} recipientId - The unique identifier of the recipient of the direct message.\n * @property {string} createdAt - The timestamp when the direct message was created.\n * @property {string[]} [mediaUrls] - An optional array of URLs for any media included in the direct message.\n * @property {string} [senderScreenName] - The screen name of the sender of the direct message.\n * @property {string} [recipientScreenName] - The screen name of the recipient of the direct message.\n */\n\nexport interface DirectMessage {\n  id: string;\n  text: string;\n  senderId: string;\n  recipientId: string;\n  createdAt: string;\n  mediaUrls?: string[];\n  senderScreenName?: string;\n  recipientScreenName?: string;\n}\n\n/**\n * Represents a direct message conversation.\n * @typedef {Object} DirectMessageConversation\n * @property {string} conversationId - The ID of the conversation.\n * @property {DirectMessage[]} messages - An array of DirectMessage objects representing the messages in the conversation.\n * @property {Object[]} participants - An array of participant objects with IDs and screen names.\n * @property {string} participants.id - The ID of the participant.\n * @property {string} participants.screenName - The screen name of the participant.\n */\nexport interface DirectMessageConversation {\n  conversationId: string;\n  messages: DirectMessage[];\n  participants: {\n    id: string;\n    screenName: string;\n  }[];\n}\n\n/**\n * Represents a direct message event object.\n * @typedef {Object} DirectMessageEvent\n * @property {string} id - The unique identifier of the direct message event.\n * @property {string} type - The type of the direct message event.\n * @property {Object} message_create - Object containing information about the message creation.\n * @property {string} message_create.sender_id - The sender's unique identifier.\n * @property {Object} message_create.target - Object containing information about the message target user.\n * @property {string} message_create.target.recipient_id - The recipient's unique identifier.\n * @property {Object} message_create.message_data - Object containing the message data.\n * @property {string} message_create.message_data.text - The text content of the message.\n * @property {string} message_create.message_data.created_at - The timestamp when the message was created.\n * @property {Object} [message_create.message_data.entities] - Object containing optional entities in the message data.\n * @property {Array<Object>} [message_create.message_data.entities.urls] - Array of URL objects in the message data.\n * @property {string} message_create.message_data.entities.urls.url - The URL in the message.\n * @property {string} message_create.message_data.entities.urls.expanded_url - The expanded URL of the link in the message.\n * @property {string} message_create.message_data.entities.urls.display_url - The display URL of the link in the message.\n * @property {Array<Object>} [message_create.message_data.entities.media] - Array of media objects in the message data.\n * @property {string} message_create.message_data.entities.media.url - The URL of the media in the message.\n * @property {string} message_create.message_data.entities.media.type - The type of media in the message.\n */\nexport interface DirectMessageEvent {\n  id: string;\n  type: string;\n  message_create: {\n    sender_id: string;\n    target: {\n      recipient_id: string;\n    };\n    message_data: {\n      text: string;\n      created_at: string;\n      entities?: {\n        urls?: Array<{\n          url: string;\n          expanded_url: string;\n          display_url: string;\n        }>;\n        media?: Array<{\n          url: string;\n          type: string;\n        }>;\n      };\n    };\n  };\n}\n\n/**\n * Interface representing the response of direct messages.\n * @typedef {Object} DirectMessagesResponse\n * @property {DirectMessageConversation[]} conversations - Array of direct message conversations.\n * @property {TwitterUser[]} users - Array of Twitter users.\n * @property {string} [cursor] - Optional cursor for pagination.\n * @property {string} [lastSeenEventId] - Optional ID of the last seen event.\n * @property {string} [trustedLastSeenEventId] - Optional ID of the last seen trusted event.\n * @property {string} [untrustedLastSeenEventId] - Optional ID of the last seen untrusted event.\n * @property {Object} [inboxTimelines] - Optional object containing trusted and untrusted inbox timelines.\n * @property {Object} [inboxTimelines.trusted] - Object containing status and optional minimum entry ID for trusted inbox timeline.\n * @property {string} inboxTimelines.trusted.status - Status of the trusted inbox timeline.\n * @property {string} [inboxTimelines.trusted.minEntryId] - Optional minimum entry ID for the trusted inbox timeline.\n * @property {Object} [inboxTimelines.untrusted] - Object containing status and optional minimum entry ID for untrusted inbox timeline.\n * @property {string} inboxTimelines.untrusted.status - Status of the untrusted inbox timeline.\n * @property {string} [inboxTimelines.untrusted.minEntryId] - Optional minimum entry ID for the untrusted inbox timeline.\n * @property {string} userId - ID of the user.\n */\nexport interface DirectMessagesResponse {\n  conversations: DirectMessageConversation[];\n  users: TwitterUser[];\n  cursor?: string;\n  lastSeenEventId?: string;\n  trustedLastSeenEventId?: string;\n  untrustedLastSeenEventId?: string;\n  inboxTimelines?: {\n    trusted?: {\n      status: string;\n      minEntryId?: string;\n    };\n    untrusted?: {\n      status: string;\n      minEntryId?: string;\n    };\n  };\n  userId: string;\n}\n\n/**\n * Interface representing a Twitter user.\n * @property {string} id - The unique identifier of the user.\n * @property {string} screenName - The user's screen name.\n * @property {string} name - The user's full name.\n * @property {string} profileImageUrl - The URL of the user's profile image.\n * @property {string} [description] - The user's profile description.\n * @property {boolean} [verified] - Whether the user is a verified account.\n * @property {boolean} [protected] - Whether the user has a protected account.\n * @property {number} [followersCount] - The number of followers the user has.\n * @property {number} [friendsCount] - The number of friends the user has.\n */\nexport interface TwitterUser {\n  id: string;\n  screenName: string;\n  name: string;\n  profileImageUrl: string;\n  description?: string;\n  verified?: boolean;\n  protected?: boolean;\n  followersCount?: number;\n  friendsCount?: number;\n}\n\n/**\n * Interface representing the response of sending a direct message.\n * @typedef {Object} SendDirectMessageResponse\n * @property {Array<{message: {id: string, time: string, affects_sort: boolean, conversation_id: string, message_data: {id: string, time: string, recipient_id: string, sender_id: string, text: string}}}>} entries - Array of message entries.\n * @property {Object.<string, TwitterUser>} users - Record of Twitter users.\n */\nexport interface SendDirectMessageResponse {\n  entries: {\n    message: {\n      id: string;\n      time: string;\n      affects_sort: boolean;\n      conversation_id: string;\n      message_data: {\n        id: string;\n        time: string;\n        recipient_id: string;\n        sender_id: string;\n        text: string;\n      };\n    };\n  }[];\n  users: Record<string, TwitterUser>;\n}\n\n/**\n * Parses direct message conversations from the provided data.\n * @param {any} data - The data containing direct message conversations.\n * @param {string} userId - The user ID for which the conversations should be parsed.\n * @returns {DirectMessagesResponse} The parsed direct message conversations.\n */\nfunction parseDirectMessageConversations(data: any, userId: string): DirectMessagesResponse {\n  try {\n    const inboxState = data?.inbox_initial_state;\n    const conversations = inboxState?.conversations || {};\n    const entries = inboxState?.entries || [];\n    const users = inboxState?.users || {};\n\n    // Parse users first\n    const parsedUsers: TwitterUser[] = Object.values(users).map((user: any) => ({\n      id: user.id_str,\n      screenName: user.screen_name,\n      name: user.name,\n      profileImageUrl: user.profile_image_url_https,\n      description: user.description,\n      verified: user.verified,\n      protected: user.protected,\n      followersCount: user.followers_count,\n      friendsCount: user.friends_count,\n    }));\n\n    // Group messages by conversation_id\n    const messagesByConversation: Record<string, any[]> = {};\n    entries.forEach((entry: any) => {\n      if (entry.message) {\n        const convId = entry.message.conversation_id;\n        if (!messagesByConversation[convId]) {\n          messagesByConversation[convId] = [];\n        }\n        messagesByConversation[convId].push(entry.message);\n      }\n    });\n\n    // Convert to DirectMessageConversation array\n    const parsedConversations = Object.entries(conversations).map(\n      ([convId, conv]: [string, any]) => {\n        const messages = messagesByConversation[convId] || [];\n\n        // Sort messages by time in ascending order\n        messages.sort((a, b) => Number(a.time) - Number(b.time));\n\n        return {\n          conversationId: convId,\n          messages: parseDirectMessages(messages, users),\n          participants: conv.participants.map((p: any) => ({\n            id: p.user_id,\n            screenName: users[p.user_id]?.screen_name || p.user_id,\n          })),\n        };\n      }\n    );\n\n    return {\n      conversations: parsedConversations,\n      users: parsedUsers,\n      cursor: inboxState?.cursor,\n      lastSeenEventId: inboxState?.last_seen_event_id,\n      trustedLastSeenEventId: inboxState?.trusted_last_seen_event_id,\n      untrustedLastSeenEventId: inboxState?.untrusted_last_seen_event_id,\n      inboxTimelines: {\n        trusted: inboxState?.inbox_timelines?.trusted && {\n          status: inboxState.inbox_timelines.trusted.status,\n          minEntryId: inboxState.inbox_timelines.trusted.min_entry_id,\n        },\n        untrusted: inboxState?.inbox_timelines?.untrusted && {\n          status: inboxState.inbox_timelines.untrusted.status,\n          minEntryId: inboxState.inbox_timelines.untrusted.min_entry_id,\n        },\n      },\n      userId,\n    };\n  } catch (error) {\n    console.error('Error parsing DM conversations:', error);\n    return {\n      conversations: [],\n      users: [],\n      userId,\n    };\n  }\n}\n\n/**\n * Parse direct messages and return an array of DirectMessage objects.\n *\n * @param {any[]} messages - Array of messages to parse\n * @param {any} users - Object containing user information\n * @returns {DirectMessage[]} Array of DirectMessage objects\n */\nfunction parseDirectMessages(messages: any[], users: any): DirectMessage[] {\n  try {\n    return messages.map((msg: any) => ({\n      id: msg.message_data.id,\n      text: msg.message_data.text,\n      senderId: msg.message_data.sender_id,\n      recipientId: msg.message_data.recipient_id,\n      createdAt: msg.message_data.time,\n      mediaUrls: extractMediaUrls(msg.message_data),\n      senderScreenName: users[msg.message_data.sender_id]?.screen_name,\n      recipientScreenName: users[msg.message_data.recipient_id]?.screen_name,\n    }));\n  } catch (error) {\n    console.error('Error parsing DMs:', error);\n    return [];\n  }\n}\n\n/**\n * Extracts media URLs from message data.\n * @param {any} messageData - The message data containing entities with URLs and media.\n * @returns {string[] | undefined} - An array of media URLs if found, otherwise undefined.\n */\nfunction extractMediaUrls(messageData: any): string[] | undefined {\n  const urls: string[] = [];\n\n  // Extract URLs from entities if they exist\n  if (messageData.entities?.urls) {\n    messageData.entities.urls.forEach((url: any) => {\n      urls.push(url.expanded_url);\n    });\n  }\n\n  // Extract media URLs if they exist\n  if (messageData.entities?.media) {\n    messageData.entities.media.forEach((media: any) => {\n      urls.push(media.media_url_https || media.media_url);\n    });\n  }\n\n  return urls.length > 0 ? urls : undefined;\n}\n\n/**\n * Retrieves a list of direct message conversations for a specific user.\n *\n * @param {string} userId - The ID of the user for whom to fetch direct message conversations.\n * @param {TwitterAuth} auth - The TwitterAuth object containing authentication information.\n * @param {string} [cursor] - Optional parameter for fetching paginated results.\n * @returns {Promise<DirectMessagesResponse>} A Promise that resolves to the response containing direct message conversations.\n * @throws {Error} If authentication is not available to fetch direct messages or if the response is not successful.\n */\nexport async function getDirectMessageConversations(\n  userId: string,\n  auth: TwitterAuth,\n  cursor?: string\n): Promise<DirectMessagesResponse> {\n  if (!auth.isLoggedIn()) {\n    throw new Error('Authentication required to fetch direct messages');\n  }\n\n  const url = 'https://twitter.com/i/api/graphql/7s3kOODhC5vgXlO0OlqYdA/DMInboxTimeline';\n  const messageListUrl = 'https://x.com/i/api/1.1/dm/inbox_initial_state.json';\n\n  const params = new URLSearchParams();\n\n  if (cursor) {\n    params.append('cursor', cursor);\n  }\n\n  const finalUrl = `${messageListUrl}${params.toString() ? `?${params.toString()}` : ''}`;\n  const cookies = await auth.cookieJar().getCookies(url);\n  const xCsrfToken = cookies.find((cookie) => cookie.key === 'ct0');\n\n  const headers = new Headers({\n    authorization: `Bearer ${(auth as any).bearerToken}`,\n    cookie: await auth.cookieJar().getCookieString(url),\n    'content-type': 'application/json',\n    'User-Agent':\n      'Mozilla/5.0 (Linux; Android 11; Nokia G20) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.88 Mobile Safari/537.36',\n    'x-guest-token': (auth as any).guestToken,\n    'x-twitter-auth-type': 'OAuth2Client',\n    'x-twitter-active-user': 'yes',\n    'x-csrf-token': xCsrfToken?.value as string,\n  });\n\n  const response = await fetch(finalUrl, {\n    method: 'GET',\n    headers,\n  });\n\n  await updateCookieJar(auth.cookieJar(), response.headers);\n\n  if (!response.ok) {\n    throw new Error(await response.text());\n  }\n\n  // parse the response\n  const data = await response.json();\n  return parseDirectMessageConversations(data, userId);\n}\n\n/**\n * Sends a direct message on Twitter.\n *\n * @param {TwitterAuth} auth - The Twitter authentication object.\n * @param {string} conversation_id - The ID of the conversation to send the message to.\n * @param {string} text - The text of the message to send.\n * @returns {Promise<SendDirectMessageResponse>} A Promise that resolves with the response of sending the direct message.\n * @throws {Error} If authentication is required to send direct messages and the user is not logged in.\n */\nexport async function sendDirectMessage(\n  auth: TwitterAuth,\n  conversation_id: string,\n  text: string\n): Promise<SendDirectMessageResponse> {\n  if (!auth.isLoggedIn()) {\n    throw new Error('Authentication required to send direct messages');\n  }\n\n  const url = 'https://twitter.com/i/api/graphql/7s3kOODhC5vgXlO0OlqYdA/DMInboxTimeline';\n  const messageDmUrl = 'https://x.com/i/api/1.1/dm/new2.json';\n\n  const cookies = await auth.cookieJar().getCookies(url);\n  const xCsrfToken = cookies.find((cookie) => cookie.key === 'ct0');\n\n  const headers = new Headers({\n    authorization: `Bearer ${(auth as any).bearerToken}`,\n    cookie: await auth.cookieJar().getCookieString(url),\n    'content-type': 'application/json',\n    'User-Agent':\n      'Mozilla/5.0 (Linux; Android 11; Nokia G20) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.88 Mobile Safari/537.36',\n    'x-guest-token': (auth as any).guestToken,\n    'x-twitter-auth-type': 'OAuth2Client',\n    'x-twitter-active-user': 'yes',\n    'x-csrf-token': xCsrfToken?.value as string,\n  });\n\n  const payload = {\n    conversation_id: `${conversation_id}`,\n    recipient_ids: false,\n    text: text,\n    cards_platform: 'Web-12',\n    include_cards: 1,\n    include_quote_count: true,\n    dm_users: false,\n  };\n\n  const response = await fetch(messageDmUrl, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(payload),\n  });\n\n  await updateCookieJar(auth.cookieJar(), response.headers);\n\n  if (!response.ok) {\n    throw new Error(await response.text());\n  }\n\n  return await response.json();\n}\n","import { Headers } from 'headers-polyfill';\nimport stringify from 'json-stable-stringify';\nimport { addApiFeatures, bearerToken, requestApi } from './api';\nimport type { TwitterAuth } from './auth';\nimport { type Profile, getEntityIdByScreenName } from './profile';\nimport { getUserTimeline } from './timeline-async';\nimport { type RelationshipTimeline, parseRelationshipTimeline } from './timeline-relationship';\nimport type { QueryProfilesResponse } from './timeline-v1';\n\n/**\n * Function to get the following profiles of a user.\n * @param {string} userId - The ID of the user to get the following profiles for.\n * @param {number} maxProfiles - The maximum number of profiles to retrieve.\n * @param {TwitterAuth} auth - The Twitter authentication credentials.\n * @returns {AsyncGenerator<Profile, void>} An async generator that yields Profile objects.\n */\nexport function getFollowing(\n  userId: string,\n  maxProfiles: number,\n  auth: TwitterAuth\n): AsyncGenerator<Profile, void> {\n  return getUserTimeline(userId, maxProfiles, (q, mt, c) => {\n    return fetchProfileFollowing(q, mt, auth, c);\n  });\n}\n\n/**\n * Get followers for a specific user.\n * @param {string} userId - The user ID for which to retrieve followers.\n * @param {number} maxProfiles - The maximum number of profiles to retrieve.\n * @param {TwitterAuth} auth - The authentication credentials for the Twitter API.\n * @returns {AsyncGenerator<Profile, void>} - An async generator that yields Profile objects representing followers.\n */\nexport function getFollowers(\n  userId: string,\n  maxProfiles: number,\n  auth: TwitterAuth\n): AsyncGenerator<Profile, void> {\n  return getUserTimeline(userId, maxProfiles, (q, mt, c) => {\n    return fetchProfileFollowers(q, mt, auth, c);\n  });\n}\n\n/**\n * Fetches the profiles that a user is following.\n * @param {string} userId - The ID of the user whose following profiles are to be fetched.\n * @param {number} maxProfiles - The maximum number of profiles to fetch.\n * @param {TwitterAuth} auth - The Twitter authentication details.\n * @param {string} [cursor] - Optional cursor for pagination.\n * @returns {Promise<QueryProfilesResponse>} A Promise that resolves with the response containing profiles the user is following.\n */\nexport async function fetchProfileFollowing(\n  userId: string,\n  maxProfiles: number,\n  auth: TwitterAuth,\n  cursor?: string\n): Promise<QueryProfilesResponse> {\n  const timeline = await getFollowingTimeline(userId, maxProfiles, auth, cursor);\n\n  return parseRelationshipTimeline(timeline);\n}\n\n/**\n * Fetches the profile followers for a given user ID.\n *\n * @param {string} userId - The user ID for which to fetch profile followers.\n * @param {number} maxProfiles - The maximum number of profiles to fetch.\n * @param {TwitterAuth} auth - The Twitter authentication credentials.\n * @param {string} [cursor] - Optional cursor for paginating results.\n * @returns {Promise<QueryProfilesResponse>} A promise that resolves with the parsed profile followers timeline.\n */\nexport async function fetchProfileFollowers(\n  userId: string,\n  maxProfiles: number,\n  auth: TwitterAuth,\n  cursor?: string\n): Promise<QueryProfilesResponse> {\n  const timeline = await getFollowersTimeline(userId, maxProfiles, auth, cursor);\n\n  return parseRelationshipTimeline(timeline);\n}\n\n/**\n * Asynchronously fetches the timeline of accounts that a user is following.\n *\n * @param {string} userId - The ID of the user whose following timeline is to be retrieved.\n * @param {number} maxItems - The maximum number of items to fetch (limited to 50).\n * @param {TwitterAuth} auth - The authentication information for making the API request.\n * @param {string} [cursor] - Optional cursor to paginate the results.\n * @returns {Promise<RelationshipTimeline>} A Promise that resolves to the RelationshipTimeline object representing the following timeline.\n * @throws {Error} If the client is not logged-in for profile following.\n */\nasync function getFollowingTimeline(\n  userId: string,\n  maxItems: number,\n  auth: TwitterAuth,\n  cursor?: string\n): Promise<RelationshipTimeline> {\n  if (!auth.isLoggedIn()) {\n    throw new Error('Client is not logged-in for profile following.');\n  }\n\n  if (maxItems > 50) {\n    maxItems = 50;\n  }\n\n  const variables: Record<string, any> = {\n    userId,\n    count: maxItems,\n    includePromotedContent: false,\n  };\n\n  const features = addApiFeatures({\n    responsive_web_twitter_article_tweet_consumption_enabled: false,\n    tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: true,\n    longform_notetweets_inline_media_enabled: true,\n    responsive_web_media_download_video_enabled: false,\n  });\n\n  if (cursor != null && cursor !== '') {\n    variables.cursor = cursor;\n  }\n\n  const params = new URLSearchParams();\n  params.set('features', stringify(features) ?? '');\n  params.set('variables', stringify(variables) ?? '');\n\n  const res = await requestApi<RelationshipTimeline>(\n    `https://twitter.com/i/api/graphql/iSicc7LrzWGBgDPL0tM_TQ/Following?${params.toString()}`,\n    auth\n  );\n\n  if (!res.success) {\n    throw res.err;\n  }\n\n  return res.value;\n}\n\n/**\n * Retrieves the followers timeline for a specific user.\n * @param userId The ID of the user whose followers timeline will be retrieved.\n * @param maxItems The maximum number of items to retrieve (up to 50).\n * @param auth The Twitter authentication credentials.\n * @param cursor (Optional) The cursor for pagination.\n * @returns A Promise that resolves with the RelationshipTimeline object.\n * @throws Error if the client is not logged in or if the API request fails.\n */\nasync function getFollowersTimeline(\n  userId: string,\n  maxItems: number,\n  auth: TwitterAuth,\n  cursor?: string\n): Promise<RelationshipTimeline> {\n  if (!auth.isLoggedIn()) {\n    throw new Error('Client is not logged-in for profile followers.');\n  }\n\n  if (maxItems > 50) {\n    maxItems = 50;\n  }\n\n  const variables: Record<string, any> = {\n    userId,\n    count: maxItems,\n    includePromotedContent: false,\n  };\n\n  const features = addApiFeatures({\n    responsive_web_twitter_article_tweet_consumption_enabled: false,\n    tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: true,\n    longform_notetweets_inline_media_enabled: true,\n    responsive_web_media_download_video_enabled: false,\n  });\n\n  if (cursor != null && cursor !== '') {\n    variables.cursor = cursor;\n  }\n\n  const params = new URLSearchParams();\n  params.set('features', stringify(features) ?? '');\n  params.set('variables', stringify(variables) ?? '');\n\n  const res = await requestApi<RelationshipTimeline>(\n    `https://twitter.com/i/api/graphql/rRXFSG5vR6drKr5M37YOTw/Followers?${params.toString()}`,\n    auth\n  );\n\n  if (!res.success) {\n    throw res.err;\n  }\n\n  return res.value;\n}\n\n/**\n * Makes a request to follow a user on Twitter.\n *\n * @param {string} username - The username of the user to follow.\n * @param {TwitterAuth} auth - Twitter authentication object.\n * @returns {Promise<Response>} - A Promise that resolves with the response data.\n * @throws {Error} - If the user is not logged in, or if an error occurs during the follow process.\n */\nexport async function followUser(username: string, auth: TwitterAuth): Promise<Response> {\n  // Check if the user is logged in\n  if (!(await auth.isLoggedIn())) {\n    throw new Error('Must be logged in to follow users');\n  }\n  // Get user ID from username\n  const userIdResult = await getEntityIdByScreenName(username, auth);\n\n  if (!userIdResult.success) {\n    throw new Error(`Failed to get user ID: ${userIdResult.err.message}`);\n  }\n\n  const userId = userIdResult.value;\n\n  // Prepare the request body\n  const requestBody = {\n    include_profile_interstitial_type: '1',\n    skip_status: 'true',\n    user_id: userId,\n  };\n\n  // Prepare the headers\n  const headers = new Headers({\n    'Content-Type': 'application/x-www-form-urlencoded',\n    Referer: `https://twitter.com/${username}`,\n    'X-Twitter-Active-User': 'yes',\n    'X-Twitter-Auth-Type': 'OAuth2Session',\n    'X-Twitter-Client-Language': 'en',\n    Authorization: `Bearer ${bearerToken}`,\n  });\n\n  // Install auth headers\n  await auth.installTo(headers, 'https://api.twitter.com/1.1/friendships/create.json');\n\n  // Make the follow request using auth.fetch\n  const res = await auth.fetch('https://api.twitter.com/1.1/friendships/create.json', {\n    method: 'POST',\n    headers,\n    body: new URLSearchParams(requestBody).toString(),\n    credentials: 'include',\n  });\n\n  if (!res.ok) {\n    throw new Error(`Failed to follow user: ${res.statusText}`);\n  }\n\n  const data = await res.json();\n\n  return new Response(JSON.stringify(data), {\n    status: 200,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n}\n","import type { Profile } from './profile';\nimport type { Tweet } from './tweets';\n\n/**\n * Interface representing the response when fetching profiles.\n * @typedef {Object} FetchProfilesResponse\n * @property {Profile[]} profiles - An array of profiles.\n * @property {string} [next] - Optional: A string representing the next page to fetch.\n */\nexport interface FetchProfilesResponse {\n  profiles: Profile[];\n  next?: string;\n}\n\n/**\n * Function type for fetching profiles.\n *\n * @param {string} query - The search query for profiles.\n * @param {number} maxProfiles - The maximum number of profiles to retrieve.\n * @param {string | undefined} cursor - The cursor for fetching the next set of profiles.\n * @returns {Promise<FetchProfilesResponse>} - A promise that resolves to a FetchProfilesResponse object.\n */\nexport type FetchProfiles = (\n  query: string,\n  maxProfiles: number,\n  cursor: string | undefined\n) => Promise<FetchProfilesResponse>;\n\n/**\n * Interface representing the response from a fetch tweets API request.\n * @typedef {Object} FetchTweetsResponse\n * @property {Tweet[]} tweets - An array of Tweet objects.\n * @property {string} [next] - Optional: a string representing the next page token.\n */\nexport interface FetchTweetsResponse {\n  tweets: Tweet[];\n  next?: string;\n}\n\n/**\n * Function to fetch tweets based on a query and maximum number of tweets.\n * @param {string} query - The search query for tweets.\n * @param {number} maxTweets - The maximum number of tweets to fetch.\n * @param {string | undefined} cursor - The cursor for pagination, if any.\n * @returns {Promise<FetchTweetsResponse>} A promise that resolves to the response containing fetched tweets.\n */\nexport type FetchTweets = (\n  query: string,\n  maxTweets: number,\n  cursor: string | undefined\n) => Promise<FetchTweetsResponse>;\n\n/**\n * Asynchronously generates user profiles from a timeline based on the specified query and maximum number of profiles to fetch.\n * @param {string} query - The query string to search for profiles.\n * @param {number} maxProfiles - The maximum number of profiles to return.\n * @param {FetchProfiles} fetchFunc - The function to fetch profiles based on the query, maxProfiles, and cursor.\n * @returns {AsyncGenerator<Profile, void>} An asynchronous generator that yields profiles from the timeline.\n */\nexport async function* getUserTimeline(\n  query: string,\n  maxProfiles: number,\n  fetchFunc: FetchProfiles\n): AsyncGenerator<Profile, void> {\n  let nProfiles = 0;\n  let cursor: string | undefined = undefined;\n  let consecutiveEmptyBatches = 0;\n  while (nProfiles < maxProfiles) {\n    const batch: FetchProfilesResponse = await fetchFunc(query, maxProfiles, cursor);\n\n    const { profiles, next } = batch;\n    cursor = next;\n\n    if (profiles.length === 0) {\n      consecutiveEmptyBatches++;\n      if (consecutiveEmptyBatches > 5) break;\n    } else consecutiveEmptyBatches = 0;\n\n    for (const profile of profiles) {\n      if (nProfiles < maxProfiles) yield profile;\n      else break;\n      nProfiles++;\n    }\n\n    if (!next) break;\n  }\n}\n\n/**\n * Async generator function that fetches and yields tweets from a timeline based on\n * the provided query and maximum number of tweets to retrieve.\n * @param {string} query - The search query for retrieving tweets.\n * @param {number} maxTweets - The maximum number of tweets to retrieve.\n * @param {FetchTweets} fetchFunc - The function to fetch tweets based on the query, maxTweets, and cursor.\n * @returns {AsyncGenerator<Tweet, void>} An async generator that yields retrieved tweets.\n */\nexport async function* getTweetTimeline(\n  query: string,\n  maxTweets: number,\n  fetchFunc: FetchTweets\n): AsyncGenerator<Tweet, void> {\n  let nTweets = 0;\n  let cursor: string | undefined = undefined;\n  while (nTweets < maxTweets) {\n    const batch: FetchTweetsResponse = await fetchFunc(query, maxTweets, cursor);\n\n    const { tweets, next } = batch;\n\n    if (tweets.length === 0) {\n      break;\n    }\n\n    for (const tweet of tweets) {\n      if (nTweets < maxTweets) {\n        cursor = next;\n        yield tweet;\n      } else {\n        break;\n      }\n\n      nTweets++;\n    }\n  }\n}\n","import { type Profile, parseProfile } from './profile';\nimport type { QueryProfilesResponse } from './timeline-v1';\nimport type { TimelineUserResultRaw } from './timeline-v2';\n\n/**\n * Interface for raw content of a relationship entry item.\n * @typedef { Object } RelationshipEntryItemContentRaw\n * @property { string } [itemType] - The type of item.\n * @property { string } [userDisplayType] - The display type for the user.\n * @property { Object } [user_results] - The results of the user.\n * @property { Object } [user_results.result] - The raw data of the timeline user result.\n */\nexport interface RelationshipEntryItemContentRaw {\n  itemType?: string;\n  userDisplayType?: string;\n  user_results?: {\n    result?: TimelineUserResultRaw;\n  };\n}\n\n/**\n * Interface representing a raw relationship entry.\n * @interface\n * @property {string} entryId - The unique identifier for the entry.\n * @property {string} sortIndex - The sorting index for the entry.\n * @property {Object} [content] - Additional content for the entry.\n * @property {string} [content.cursorType] - The type of cursor.\n * @property {string} [content.entryType] - The type of entry.\n * @property {string} [content.__typename] - The typename of the content.\n * @property {string} [content.value] - The value of the content.\n * @property {RelationshipEntryItemContentRaw} [content.itemContent] - The raw item content for the entry.\n */\n\nexport interface RelationshipEntryRaw {\n  entryId: string;\n  sortIndex: string;\n  content?: {\n    cursorType?: string;\n    entryType?: string;\n    __typename?: string;\n    value?: string;\n    itemContent?: RelationshipEntryItemContentRaw;\n  };\n}\n\n/**\n * Interface representing a relationship timeline.\n * @property {object} data - Optional property containing user result timeline instructions.\n * @property {object} data.user - Optional property containing user information.\n * @property {object} data.user.result - Optional property containing result information.\n * @property {object} data.user.result.timeline - Optional property containing timeline instructions.\n * @property {object} data.user.result.timeline.timeline - Optional property containing timeline instructions.\n * @property {object[]} data.user.result.timeline.timeline.instructions - Optional array of relationship entries.\n * @property {object} data.user.result.timeline.timeline.instructions.entry - Optional relationship entry object.\n * @property {object[]} data.user.result.timeline.timeline.instructions.type - Optional string representing type of timeline instructions.\n */\nexport interface RelationshipTimeline {\n  data?: {\n    user?: {\n      result?: {\n        timeline?: {\n          timeline?: {\n            instructions?: {\n              entries?: RelationshipEntryRaw[];\n              entry?: RelationshipEntryRaw;\n              type?: string;\n            }[];\n          };\n        };\n      };\n    };\n  };\n}\n\n/**\n * Parses the given RelationshipTimeline data to extract profiles and cursors.\n * @param timeline The RelationshipTimeline data to parse.\n * @returns The QueryProfilesResponse object containing profiles, next cursor, and previous cursor.\n */\nexport function parseRelationshipTimeline(timeline: RelationshipTimeline): QueryProfilesResponse {\n  let bottomCursor: string | undefined;\n  let topCursor: string | undefined;\n  const profiles: Profile[] = [];\n  const instructions = timeline.data?.user?.result?.timeline?.timeline?.instructions ?? [];\n\n  for (const instruction of instructions) {\n    if (instruction.type === 'TimelineAddEntries' || instruction.type === 'TimelineReplaceEntry') {\n      if (instruction.entry?.content?.cursorType === 'Bottom') {\n        bottomCursor = instruction.entry.content.value;\n        continue;\n      }\n\n      if (instruction.entry?.content?.cursorType === 'Top') {\n        topCursor = instruction.entry.content.value;\n        continue;\n      }\n\n      const entries = instruction.entries ?? [];\n      for (const entry of entries) {\n        const itemContent = entry.content?.itemContent;\n        if (itemContent?.userDisplayType === 'User') {\n          const userResultRaw = itemContent.user_results?.result;\n\n          if (userResultRaw?.legacy) {\n            const profile = parseProfile(userResultRaw.legacy, userResultRaw.is_blue_verified);\n\n            if (!profile.userId) {\n              profile.userId = userResultRaw.rest_id;\n            }\n\n            profiles.push(profile);\n          }\n        } else if (entry.content?.cursorType === 'Bottom') {\n          bottomCursor = entry.content.value;\n        } else if (entry.content?.cursorType === 'Top') {\n          topCursor = entry.content.value;\n        }\n      }\n    }\n  }\n\n  return { profiles, next: bottomCursor, previous: topCursor };\n}\n","import stringify from 'json-stable-stringify';\nimport { addApiFeatures, requestApi } from './api';\nimport type { TwitterAuth } from './auth';\nimport type { Profile } from './profile';\nimport { getTweetTimeline, getUserTimeline } from './timeline-async';\nimport {\n  type SearchTimeline,\n  parseSearchTimelineTweets,\n  parseSearchTimelineUsers,\n} from './timeline-search';\nimport type { QueryProfilesResponse, QueryTweetsResponse } from './timeline-v1';\nimport type { Tweet } from './tweets';\n\n/**\n * The categories that can be used in Twitter searches.\n */\n/**\n * Enum representing different search modes.\n * @enum {number}\n */\n\nexport enum SearchMode {\n  Top = 0,\n  Latest = 1,\n  Photos = 2,\n  Videos = 3,\n  Users = 4,\n}\n\nexport function searchTweets(\n  query: string,\n  maxTweets: number,\n  searchMode: SearchMode,\n  auth: TwitterAuth\n): AsyncGenerator<Tweet, void> {\n  return getTweetTimeline(query, maxTweets, (q, mt, c) => {\n    return fetchSearchTweets(q, mt, searchMode, auth, c);\n  });\n}\n\nexport function searchProfiles(\n  query: string,\n  maxProfiles: number,\n  auth: TwitterAuth\n): AsyncGenerator<Profile, void> {\n  return getUserTimeline(query, maxProfiles, (q, mt, c) => {\n    return fetchSearchProfiles(q, mt, auth, c);\n  });\n}\n\nexport async function fetchSearchTweets(\n  query: string,\n  maxTweets: number,\n  searchMode: SearchMode,\n  auth: TwitterAuth,\n  cursor?: string\n): Promise<QueryTweetsResponse> {\n  const timeline = await getSearchTimeline(query, maxTweets, searchMode, auth, cursor);\n\n  return parseSearchTimelineTweets(timeline);\n}\n\nexport async function fetchSearchProfiles(\n  query: string,\n  maxProfiles: number,\n  auth: TwitterAuth,\n  cursor?: string\n): Promise<QueryProfilesResponse> {\n  const timeline = await getSearchTimeline(query, maxProfiles, SearchMode.Users, auth, cursor);\n\n  return parseSearchTimelineUsers(timeline);\n}\n\nasync function getSearchTimeline(\n  query: string,\n  maxItems: number,\n  searchMode: SearchMode,\n  auth: TwitterAuth,\n  cursor?: string\n): Promise<SearchTimeline> {\n  if (!auth.isLoggedIn()) {\n    throw new Error('Client is not logged-in for search.');\n  }\n\n  if (maxItems > 50) {\n    maxItems = 50;\n  }\n\n  const variables: Record<string, any> = {\n    rawQuery: query,\n    count: maxItems,\n    querySource: 'typed_query',\n    product: 'Top',\n  };\n\n  const features = addApiFeatures({\n    longform_notetweets_inline_media_enabled: true,\n    responsive_web_enhance_cards_enabled: false,\n    responsive_web_media_download_video_enabled: false,\n    responsive_web_twitter_article_tweet_consumption_enabled: false,\n    tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: true,\n    interactive_text_enabled: false,\n    responsive_web_text_conversations_enabled: false,\n    vibe_api_enabled: false,\n  });\n\n  const fieldToggles: Record<string, any> = {\n    withArticleRichContentState: false,\n  };\n\n  if (cursor != null && cursor !== '') {\n    variables.cursor = cursor;\n  }\n\n  switch (searchMode) {\n    case SearchMode.Latest:\n      variables.product = 'Latest';\n      break;\n    case SearchMode.Photos:\n      variables.product = 'Photos';\n      break;\n    case SearchMode.Videos:\n      variables.product = 'Videos';\n      break;\n    case SearchMode.Users:\n      variables.product = 'People';\n      break;\n    default:\n      break;\n  }\n\n  const params = new URLSearchParams();\n  params.set('features', stringify(features) ?? '');\n  params.set('fieldToggles', stringify(fieldToggles) ?? '');\n  params.set('variables', stringify(variables) ?? '');\n\n  const res = await requestApi<SearchTimeline>(\n    `https://api.twitter.com/graphql/gkjsKepM6gl_HmFWoWKfgg/SearchTimeline?${params.toString()}`,\n    auth\n  );\n\n  if (!res.success) {\n    throw (res as any).err;\n  }\n\n  return res.value;\n}\n\n/**\n * Fetches one page of tweets that quote a given tweet ID.\n * This function does not handle pagination.\n * All comments must remain in English.\n *\n * @param quotedTweetId The tweet ID you want quotes of.\n * @param maxTweets Maximum number of tweets to return in one page.\n * @param auth The TwitterAuth object.\n * @param cursor Optional pagination cursor for fetching further pages.\n * @returns A promise that resolves to a QueryTweetsResponse containing tweets and the next cursor.\n */\nexport async function fetchQuotedTweetsPage(\n  quotedTweetId: string,\n  maxTweets: number,\n  auth: TwitterAuth,\n  cursor?: string\n): Promise<QueryTweetsResponse> {\n  if (maxTweets > 50) {\n    maxTweets = 50;\n  }\n\n  // Build the rawQuery and variables\n  const variables: Record<string, any> = {\n    rawQuery: `quoted_tweet_id:${quotedTweetId}`,\n    count: maxTweets,\n    querySource: 'tdqt',\n    product: 'Top',\n  };\n\n  if (cursor && cursor !== '') {\n    variables.cursor = cursor;\n  }\n\n  const features = addApiFeatures({\n    profile_label_improvements_pcf_label_in_post_enabled: true,\n    rweb_tipjar_consumption_enabled: true,\n    responsive_web_graphql_exclude_directive_enabled: true,\n    verified_phone_label_enabled: false,\n    creator_subscriptions_tweet_preview_api_enabled: true,\n    responsive_web_graphql_timeline_navigation_enabled: true,\n    responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,\n    premium_content_api_read_enabled: false,\n    communities_web_enable_tweet_community_results_fetch: true,\n    c9s_tweet_anatomy_moderator_badge_enabled: true,\n    responsive_web_grok_analyze_button_fetch_trends_enabled: false,\n    responsive_web_grok_analyze_post_followups_enabled: true,\n    responsive_web_jetfuel_frame: false,\n    responsive_web_grok_share_attachment_enabled: true,\n    articles_preview_enabled: true,\n    responsive_web_edit_tweet_api_enabled: true,\n    graphql_is_translatable_rweb_tweet_is_translatable_enabled: true,\n    view_counts_everywhere_api_enabled: true,\n    longform_notetweets_consumption_enabled: true,\n    responsive_web_twitter_article_tweet_consumption_enabled: true,\n    tweet_awards_web_tipping_enabled: false,\n    creator_subscriptions_quote_tweet_preview_enabled: false,\n    freedom_of_speech_not_reach_fetch_enabled: true,\n    standardized_nudges_misinfo: true,\n    tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: true,\n    rweb_video_timestamps_enabled: true,\n    longform_notetweets_rich_text_read_enabled: true,\n    longform_notetweets_inline_media_enabled: true,\n    responsive_web_grok_image_annotation_enabled: false,\n    responsive_web_enhance_cards_enabled: false,\n  });\n\n  const fieldToggles: Record<string, any> = {\n    withArticleRichContentState: false,\n  };\n\n  const params = new URLSearchParams();\n  params.set('features', stringify(features) ?? '');\n  params.set('fieldToggles', stringify(fieldToggles) ?? '');\n  params.set('variables', stringify(variables) ?? '');\n\n  const url = `https://x.com/i/api/graphql/1BP5aKg8NvTNvRCyyCyq8g/SearchTimeline?${params.toString()}`;\n\n  // Perform the request\n  const res = await requestApi(url, auth);\n  if (!res.success) {\n    throw (res as any).err;\n  }\n\n  // Force cast for TypeScript\n  const timeline = res.value as any;\n  // Use parseSearchTimelineTweets to convert timeline data\n  return parseSearchTimelineTweets(timeline);\n}\n\n/**\n * Creates an async generator, yielding pages of quotes for a given tweet ID.\n * It prevents infinite loop by checking if the next cursor hasn't changed.\n */\nexport async function* searchQuotedTweets(\n  quotedTweetId: string,\n  maxTweets: number,\n  auth: TwitterAuth\n): AsyncGenerator<QueryTweetsResponse> {\n  let cursor: string | undefined;\n\n  while (true) {\n    const response = await fetchQuotedTweetsPage(quotedTweetId, maxTweets, auth, cursor);\n    yield response;\n\n    // Prevent infinite loop if the API keeps returning the same cursor\n    if (!response.next || response.next === cursor) {\n      break;\n    }\n\n    // Update cursor for the next iteration\n    cursor = response.next;\n  }\n}\n","/**\n * Defines a type that ensures a specified property in an object is\n * not nullable or undefined.\n * @template T - The type of the object.\n * @template K - The keyof type representing the keys of the object.\n * @param {T} T - The object type.\n * @param {K} K - The key type of the object.\n * @returns {Object} - Returns a new type that includes all properties of the\n * original object with the specified key set to be non-nullable.\n */\nexport type NonNullableField<T, K extends keyof T> = {\n  [P in K]-?: T[P];\n} & T;\n\n/**\n * Checks if the specified field is defined in the object.\n *\n * @template T - The type of the object\n * @template K - The key of the field\n * @param {K} key - The key of the field to check\n * @returns {(value: T) => value is NonNullableField<T, K>} A function that checks if the field is defined\n */\nexport function isFieldDefined<T, K extends keyof T>(key: K) {\n  return (value: T): value is NonNullableField<T, K> => isDefined(value[key]);\n}\n\n/**\n * Check if a value is defined (not null or undefined).\n * @template T\n * @param {T | null | undefined} value - The value to check.\n * @return {value is T} Returns true if the value is defined, false otherwise.\n */\nexport function isDefined<T>(value: T | null | undefined): value is T {\n  return value != null;\n}\n","import type { LegacyTweetRaw, TimelineMediaExtendedRaw } from './timeline-v1';\nimport type { Photo, Video } from './tweets';\nimport { type NonNullableField, isFieldDefined } from './type-util';\n\nconst reHashtag = /\\B(\\#\\S+\\b)/g;\nconst reCashtag = /\\B(\\$\\S+\\b)/g;\nconst reTwitterUrl = /https:(\\/\\/t\\.co\\/([A-Za-z0-9]|[A-Za-z]){10})/g;\nconst reUsername = /\\B(\\@\\S{1,15}\\b)/g;\n\n/**\n * Parses the media groups from the provided array of TimelineMediaExtendedRaw objects\n * to extract photos and videos along with the sensitive content information.\n *\n * @param {TimelineMediaExtendedRaw[]} media - The array of TimelineMediaExtendedRaw objects to parse\n * @returns {{ sensitiveContent?: boolean, photos: Photo[], videos: Video[] }} - An object containing\n * the sensitive content boolean flag, an array of photos, and an array of videos\n */\nexport function parseMediaGroups(media: TimelineMediaExtendedRaw[]): {\n  sensitiveContent?: boolean;\n  photos: Photo[];\n  videos: Video[];\n} {\n  const photos: Photo[] = [];\n  const videos: Video[] = [];\n  let sensitiveContent: boolean | undefined = undefined;\n\n  for (const m of media\n    .filter(isFieldDefined('id_str'))\n    .filter(isFieldDefined('media_url_https'))) {\n    if (m.type === 'photo') {\n      photos.push({\n        id: m.id_str,\n        url: m.media_url_https,\n        alt_text: m.ext_alt_text,\n      });\n    } else if (m.type === 'video') {\n      videos.push(parseVideo(m));\n    }\n\n    const sensitive = m.ext_sensitive_media_warning;\n    if (sensitive != null) {\n      sensitiveContent = sensitive.adult_content || sensitive.graphic_violence || sensitive.other;\n    }\n  }\n\n  return { sensitiveContent, photos, videos };\n}\n\n/**\n * Parses the video information from the given raw media object.\n *\n * @param {NonNullableField<TimelineMediaExtendedRaw, \"id_str\" | \"media_url_https\">} m The raw media object containing the video information.\n * @returns {Video} The parsed video object with id, preview, and URL.\n */\nfunction parseVideo(\n  m: NonNullableField<TimelineMediaExtendedRaw, 'id_str' | 'media_url_https'>\n): Video {\n  const video: Video = {\n    id: m.id_str,\n    preview: m.media_url_https,\n  };\n\n  let maxBitrate = 0;\n  const variants = m.video_info?.variants ?? [];\n  for (const variant of variants) {\n    const bitrate = variant.bitrate;\n    if (bitrate != null && bitrate > maxBitrate && variant.url != null) {\n      let variantUrl = variant.url;\n      const stringStart = 0;\n      const tagSuffixIdx = variantUrl.indexOf('?tag=10');\n      if (tagSuffixIdx !== -1) {\n        variantUrl = variantUrl.substring(stringStart, tagSuffixIdx + 1);\n      }\n\n      video.url = variantUrl;\n      maxBitrate = bitrate;\n    }\n  }\n\n  return video;\n}\n\n/**\n * Reconstructs the tweet HTML by parsing the tweet text and adding links to hashtags, cashtags, usernames,\n * and converting Twitter URLs. Also adds images and videos to the HTML.\n *\n * @param {LegacyTweetRaw} tweet The raw tweet object containing the full text of the tweet.\n * @param {Photo[]} photos Array of photo objects associated with the tweet.\n * @param {Video[]} videos Array of video objects associated with the tweet.\n * @returns {string} The reconstructed HTML for the tweet.\n */\nexport function reconstructTweetHtml(\n  tweet: LegacyTweetRaw,\n  photos: Photo[],\n  videos: Video[]\n): string {\n  const media: string[] = [];\n\n  // HTML parsing with regex :)\n  let html = tweet.full_text ?? '';\n\n  html = html.replace(reHashtag, linkHashtagHtml);\n  html = html.replace(reCashtag, linkCashtagHtml);\n  html = html.replace(reUsername, linkUsernameHtml);\n  html = html.replace(reTwitterUrl, unwrapTcoUrlHtml(tweet, media));\n\n  for (const { url } of photos) {\n    if (media.indexOf(url) !== -1) {\n      continue;\n    }\n\n    html += `<br><img src=\"${url}\"/>`;\n  }\n\n  for (const { preview: url } of videos) {\n    if (media.indexOf(url) !== -1) {\n      continue;\n    }\n\n    html += `<br><img src=\"${url}\"/>`;\n  }\n\n  html = html.replace(/\\n/g, '<br>');\n\n  return html;\n}\n\n/**\n * Generates an HTML link for a hashtag by removing the '#' symbol\n * and creating a Twitter hashtag link.\n *\n * @param hashtag - The hashtag to generate the link for\n * @returns The HTML link for the specified hashtag\n */\nfunction linkHashtagHtml(hashtag: string) {\n  return `<a href=\"https://twitter.com/hashtag/${hashtag.replace('#', '')}\">${hashtag}</a>`;\n}\n\n/**\n * Generates HTML anchor link for a cashtag.\n * @param {string} cashtag - The cashtag to link.\n * @returns {string} The HTML anchor link for the cashtag.\n */\nfunction linkCashtagHtml(cashtag: string) {\n  return `<a href=\"https://twitter.com/search?q=%24${cashtag.replace('$', '')}\">${cashtag}</a>`;\n}\n\n/**\n * Generates HTML for linking a Twitter username.\n *\n * @param {string} username - The Twitter username to generate link for.\n * @returns {string} - The HTML string for the linked username.\n */\nfunction linkUsernameHtml(username: string) {\n  return `<a href=\"https://twitter.com/${username.replace('@', '')}\">${username}</a>`;\n}\n\n/**\n * Unwraps the t.co URL in a tweet HTML based on the provided tweet object and founded media URLs.\n * @param {LegacyTweetRaw} tweet - The tweet object containing URLs and media entities.\n * @param {string[]} foundedMedia - An array to store the founded media URLs.\n * @returns {function(string): string} - A function that takes a t.co URL and returns the corresponding HTML representation.\n */\nfunction unwrapTcoUrlHtml(tweet: LegacyTweetRaw, foundedMedia: string[]) {\n  return (tco: string) => {\n    for (const entity of tweet.entities?.urls ?? []) {\n      if (tco === entity.url && entity.expanded_url != null) {\n        return `<a href=\"${entity.expanded_url}\">${tco}</a>`;\n      }\n    }\n\n    for (const entity of tweet.extended_entities?.media ?? []) {\n      if (tco === entity.url && entity.media_url_https != null) {\n        foundedMedia.push(entity.media_url_https);\n        return `<br><a href=\"${tco}\"><img src=\"${entity.media_url_https}\"/></a>`;\n      }\n    }\n\n    return tco;\n  };\n}\n","import type { LegacyUserRaw } from './profile';\nimport { parseMediaGroups, reconstructTweetHtml } from './timeline-tweet-util';\nimport type {\n  LegacyTweetRaw,\n  ParseTweetResult,\n  QueryTweetsResponse,\n  SearchResultRaw,\n  TimelineResultRaw,\n} from './timeline-v1';\nimport type { Tweet } from './tweets';\nimport { isFieldDefined } from './type-util';\n\n/**\n * Interface representing raw data for a user result in a timeline.\n * @property {string} [rest_id] - The REST ID of the user.\n * @property {LegacyUserRaw} [legacy] - The legacy user data.\n * @property {boolean} [is_blue_verified] - Indicates if the user is blue verified.\n */\nexport interface TimelineUserResultRaw {\n  rest_id?: string;\n  legacy?: LegacyUserRaw;\n  is_blue_verified?: boolean;\n}\n\n/**\n * Interface representing the raw content of a timeline entry item.\n * @typedef {Object} TimelineEntryItemContentRaw\n * @property {string} [itemType] - The type of the item.\n * @property {string} [tweetDisplayType] - The display type of the tweet.\n * @property {Object} [tweetResult] - The result of the tweet.\n * @property {Object} [tweet_results] - The results of the tweet.\n * @property {string} [userDisplayType] - The display type of the user.\n * @property {Object} [user_results] - The results of the user.\n */\n\nexport interface TimelineEntryItemContentRaw {\n  itemType?: string;\n  tweetDisplayType?: string;\n  tweetResult?: {\n    result?: TimelineResultRaw;\n  };\n  tweet_results?: {\n    result?: TimelineResultRaw;\n  };\n  userDisplayType?: string;\n  user_results?: {\n    result?: TimelineUserResultRaw;\n  };\n}\n\n/**\n * Interface representing a raw Timeline Entry.\n * @typedef { Object } TimelineEntryRaw\n * @property { string } entryId - The unique identifier of the entry.\n * @property { Object } [content] - The content of the entry.\n * @property { string } [content.cursorType] - The cursor type of the content.\n * @property { string } [content.value] - The value of the content.\n * @property {Object[]} [content.items] - An array of items within the content.\n * @property { string } [content.items.entryId] - The unique identifier of an item.\n * @property { Object } [content.items.item] - The item within the content.\n * @property { Object } [content.items.item.content] - The content of the item.\n * @property { Object } [content.items.item.itemContent] - The item content of the item.\n */\nexport interface TimelineEntryRaw {\n  entryId: string;\n  content?: {\n    cursorType?: string;\n    value?: string;\n    items?: {\n      entryId?: string;\n      item?: {\n        content?: TimelineEntryItemContentRaw;\n        itemContent?: SearchEntryItemContentRaw;\n      };\n    }[];\n    itemContent?: TimelineEntryItemContentRaw;\n  };\n}\n\n/**\n * Interface representing the raw content of a search entry item.\n * @interface\n * @property {string} [tweetDisplayType] - The display type of the tweet.\n * @property {Object} [tweet_results] - The results of the tweet search.\n * @property {Object} [tweet_results.result] - The raw search result of the tweet.\n * @property {string} [userDisplayType] - The display type of the user.\n * @property {Object} [user_results] - The results of the user search.\n * @property {Object} [user_results.result] - The raw search result of the user timeline.\n */\nexport interface SearchEntryItemContentRaw {\n  tweetDisplayType?: string;\n  tweet_results?: {\n    result?: SearchResultRaw;\n  };\n  userDisplayType?: string;\n  user_results?: {\n    result?: TimelineUserResultRaw;\n  };\n}\n\n/**\n * Interface representing a raw search entry.\n * @typedef { Object } SearchEntryRaw\n * @property { string } entryId - The unique identifier of the entry.\n * @property { string } sortIndex - The sorting index of the entry.\n * @property { Object } [content] - The content details of the entry.\n * @property { string } [content.cursorType] - The type of cursor associated with the entry content.\n * @property { string } [content.entryType] - The type of entry.\n * @property { string } [content.__typename] - The typename of the content.\n * @property { string } [content.value] - The value associated with the entry content.\n * @property {Array<Object>} [content.items] - An array of items associated with the entry.\n * @property { Object } [content.items.item] - An item object associated with the entry.\n * @property { Object } [content.items.item.content] - The content details of the item associated with the entry.\n * @property { Object } [content.itemContent] - The content details of the item associated with the entry.\n */\nexport interface SearchEntryRaw {\n  entryId: string;\n  sortIndex: string;\n  content?: {\n    cursorType?: string;\n    entryType?: string;\n    __typename?: string;\n    value?: string;\n    items?: {\n      item?: {\n        content?: SearchEntryItemContentRaw;\n      };\n    }[];\n    itemContent?: SearchEntryItemContentRaw;\n  };\n}\n\n/**\n * Interface representing a timeline instruction.\n * @typedef {Object} TimelineInstruction\n * @property {TimelineEntryRaw[]} [entries] - An array of timeline entry raw objects.\n * @property {TimelineEntryRaw} [entry] - A single timeline entry raw object.\n * @property {string} [type] - The type of the timeline instruction.\n */\nexport interface TimelineInstruction {\n  entries?: TimelineEntryRaw[];\n  entry?: TimelineEntryRaw;\n  type?: string;\n}\n\n/**\n * Interface representing version 2 of a timeline object.\n * @typedef {Object} TimelineV2\n * @property {Object} data - Data object containing user information.\n * @property {Object} data.user - User object containing result information.\n * @property {Object} data.user.result - Result object containing timeline_v2 information.\n * @property {Object} data.user.result.timeline_v2 - Timeline_v2 object containing timeline information.\n * @property {Object} data.user.result.timeline_v2.timeline - Timeline object containing instructions.\n * @property {Array<TimelineInstruction>} data.user.result.timeline_v2.timeline.instructions - Array of timeline instructions.\n */\nexport interface TimelineV2 {\n  data?: {\n    user?: {\n      result?: {\n        timeline_v2?: {\n          timeline?: {\n            instructions?: TimelineInstruction[];\n          };\n        };\n      };\n    };\n  };\n}\n\n/**\n * Represents a threaded conversation with optional data.\n * @interface\n * @property {Object} data - Optional data for the conversation.\n * @property {Object} data.threaded_conversation_with_injections_v2 - Optional object containing instructions.\n * @property {TimelineInstruction[]} data.threaded_conversation_with_injections_v2.instructions - Array of timeline instructions.\n */\nexport interface ThreadedConversation {\n  data?: {\n    threaded_conversation_with_injections_v2?: {\n      instructions?: TimelineInstruction[];\n    };\n  };\n}\n\n/**\n * Parses a legacy tweet object and returns a ParseTweetResult.\n * @param {LegacyUserRaw} [user] - The legacy user object.\n * @param {LegacyTweetRaw} [tweet] - The legacy tweet object.\n * @returns {ParseTweetResult} The result of parsing the legacy tweet.\n */\nexport function parseLegacyTweet(user?: LegacyUserRaw, tweet?: LegacyTweetRaw): ParseTweetResult {\n  if (tweet == null) {\n    return {\n      success: false,\n      err: new Error('Tweet was not found in the timeline object.'),\n    };\n  }\n\n  if (user == null) {\n    return {\n      success: false,\n      err: new Error('User was not found in the timeline object.'),\n    };\n  }\n\n  if (!tweet.id_str) {\n    if (!tweet.conversation_id_str) {\n      return {\n        success: false,\n        err: new Error('Tweet ID was not found in object.'),\n      };\n    }\n\n    tweet.id_str = tweet.conversation_id_str;\n  }\n\n  const hashtags = tweet.entities?.hashtags ?? [];\n  const mentions = tweet.entities?.user_mentions ?? [];\n  const media = tweet.extended_entities?.media ?? [];\n  const pinnedTweets = new Set<string | undefined>(user.pinned_tweet_ids_str ?? []);\n  const urls = tweet.entities?.urls ?? [];\n  const { photos, videos, sensitiveContent } = parseMediaGroups(media);\n\n  const tw: Tweet = {\n    bookmarkCount: tweet.bookmark_count,\n    conversationId: tweet.conversation_id_str,\n    id: tweet.id_str,\n    hashtags: hashtags.filter(isFieldDefined('text')).map((hashtag) => hashtag.text),\n    likes: tweet.favorite_count,\n    mentions: mentions.filter(isFieldDefined('id_str')).map((mention) => ({\n      id: mention.id_str,\n      username: mention.screen_name,\n      name: mention.name,\n    })),\n    name: user.name,\n    permanentUrl: `https://twitter.com/${user.screen_name}/status/${tweet.id_str}`,\n    photos,\n    replies: tweet.reply_count,\n    retweets: tweet.retweet_count,\n    text: tweet.full_text,\n    thread: [],\n    urls: urls.filter(isFieldDefined('expanded_url')).map((url) => url.expanded_url),\n    userId: tweet.user_id_str,\n    username: user.screen_name,\n    videos,\n    isQuoted: false,\n    isReply: false,\n    isRetweet: false,\n    isPin: false,\n    sensitiveContent: false,\n  };\n\n  if (tweet.created_at) {\n    tw.timeParsed = new Date(Date.parse(tweet.created_at));\n    tw.timestamp = Math.floor(tw.timeParsed.valueOf() / 1000);\n  }\n\n  if (tweet.place?.id) {\n    tw.place = tweet.place;\n  }\n\n  const quotedStatusIdStr = tweet.quoted_status_id_str;\n  const inReplyToStatusIdStr = tweet.in_reply_to_status_id_str;\n  const retweetedStatusIdStr = tweet.retweeted_status_id_str;\n  const retweetedStatusResult = tweet.retweeted_status_result?.result;\n\n  if (quotedStatusIdStr) {\n    tw.isQuoted = true;\n    tw.quotedStatusId = quotedStatusIdStr;\n  }\n\n  if (inReplyToStatusIdStr) {\n    tw.isReply = true;\n    tw.inReplyToStatusId = inReplyToStatusIdStr;\n  }\n\n  if (retweetedStatusIdStr || retweetedStatusResult) {\n    tw.isRetweet = true;\n    tw.retweetedStatusId = retweetedStatusIdStr;\n\n    if (retweetedStatusResult) {\n      const parsedResult = parseLegacyTweet(\n        retweetedStatusResult?.core?.user_results?.result?.legacy,\n        retweetedStatusResult?.legacy\n      );\n\n      if (parsedResult.success) {\n        tw.retweetedStatus = parsedResult.tweet;\n      }\n    }\n  }\n\n  const views = Number.parseInt(tweet.ext_views?.count ?? '');\n  if (!Number.isNaN(views)) {\n    tw.views = views;\n  }\n\n  if (pinnedTweets.has(tweet.id_str)) {\n    // TODO: Update tests so this can be assigned at the tweet declaration\n    tw.isPin = true;\n  }\n\n  if (sensitiveContent) {\n    // TODO: Update tests so this can be assigned at the tweet declaration\n    tw.sensitiveContent = true;\n  }\n\n  tw.html = reconstructTweetHtml(tweet, tw.photos, tw.videos);\n\n  return { success: true, tweet: tw };\n}\n\n/**\n * Parses a raw timeline result object into a ParseTweetResult object.\n *\n * @param {TimelineResultRaw} result - The raw timeline result object to parse.\n * @returns {ParseTweetResult} The parsed tweet result object.\n */\nfunction parseResult(result?: TimelineResultRaw): ParseTweetResult {\n  const noteTweetResultText = result?.note_tweet?.note_tweet_results?.result?.text;\n\n  if (result?.legacy && noteTweetResultText) {\n    result.legacy.full_text = noteTweetResultText;\n  }\n\n  const tweetResult = parseLegacyTweet(result?.core?.user_results?.result?.legacy, result?.legacy);\n  if (!tweetResult.success) {\n    return tweetResult;\n  }\n\n  if (!tweetResult.tweet.views && result?.views?.count) {\n    const views = Number.parseInt(result.views.count);\n    if (!Number.isNaN(views)) {\n      tweetResult.tweet.views = views;\n    }\n  }\n\n  const quotedResult = result?.quoted_status_result?.result;\n  if (quotedResult) {\n    if (quotedResult.legacy && quotedResult.rest_id) {\n      quotedResult.legacy.id_str = quotedResult.rest_id;\n    }\n\n    const quotedTweetResult = parseResult(quotedResult);\n    if (quotedTweetResult.success) {\n      tweetResult.tweet.quotedStatus = quotedTweetResult.tweet;\n    }\n  }\n\n  return tweetResult;\n}\n\nconst expectedEntryTypes = ['tweet', 'profile-conversation'];\n\n/**\n * Parses the timeline tweets from a TimelineV2 object and returns the QueryTweetsResponse.\n * @param {TimelineV2} timeline The timeline object containing the tweet data.\n * @returns {QueryTweetsResponse} The parsed tweets along with the next and previous cursors.\n */\nexport function parseTimelineTweetsV2(timeline: TimelineV2): QueryTweetsResponse {\n  let bottomCursor: string | undefined;\n  let topCursor: string | undefined;\n  const tweets: Tweet[] = [];\n  const instructions = timeline.data?.user?.result?.timeline_v2?.timeline?.instructions ?? [];\n  for (const instruction of instructions) {\n    const entries = instruction.entries ?? [];\n\n    for (const entry of entries) {\n      const entryContent = entry.content;\n      if (!entryContent) continue;\n\n      // Handle pagination\n      if (entryContent.cursorType === 'Bottom') {\n        bottomCursor = entryContent.value;\n        continue;\n      }\n      if (entryContent.cursorType === 'Top') {\n        topCursor = entryContent.value;\n        continue;\n      }\n\n      const idStr = entry.entryId;\n      if (!expectedEntryTypes.some((entryType) => idStr.startsWith(entryType))) {\n        continue;\n      }\n\n      if (entryContent.itemContent) {\n        // Typically TimelineTimelineTweet entries\n        parseAndPush(tweets, entryContent.itemContent, idStr);\n      } else if (entryContent.items) {\n        // Typically TimelineTimelineModule entries\n        for (const item of entryContent.items) {\n          if (item.item?.itemContent) {\n            parseAndPush(tweets, item.item.itemContent, idStr);\n          }\n        }\n      }\n    }\n  }\n\n  return { tweets, next: bottomCursor, previous: topCursor };\n}\n\n/**\n * Parses the raw content of a timeline entry item to extract the tweet data.\n * @param {TimelineEntryItemContentRaw} content - The raw content of the timeline entry item\n * @param {string} entryId - The entry ID of the timeline entry\n * @param {boolean} [isConversation=false] - Indicates if the timeline entry is part of a conversation\n * @returns {Tweet | null} The parsed tweet data or null if the parsing was unsuccessful\n */\nexport function parseTimelineEntryItemContentRaw(\n  content: TimelineEntryItemContentRaw,\n  entryId: string,\n  isConversation = false\n) {\n  let result = content.tweet_results?.result ?? content.tweetResult?.result;\n  if (\n    result?.__typename === 'Tweet' ||\n    (result?.__typename === 'TweetWithVisibilityResults' && result?.tweet)\n  ) {\n    if (result?.__typename === 'TweetWithVisibilityResults') result = result.tweet;\n\n    if (result?.legacy) {\n      result.legacy.id_str =\n        result.rest_id ?? entryId.replace('conversation-', '').replace('tweet-', '');\n    }\n\n    const tweetResult = parseResult(result);\n    if (tweetResult.success) {\n      if (isConversation) {\n        if (content?.tweetDisplayType === 'SelfThread') {\n          tweetResult.tweet.isSelfThread = true;\n        }\n      }\n\n      return tweetResult.tweet;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Parses the given content and pushes the resulting Tweet object to the specified array.\n *\n * @param {Tweet[]} tweets - The array to push the parsed Tweet object to.\n * @param {TimelineEntryItemContentRaw} content - The raw content to parse.\n * @param {string} entryId - The ID of the timeline entry.\n * @param {boolean} [isConversation=false] - Indicates if the tweet is part of a conversation.\n */\nexport function parseAndPush(\n  tweets: Tweet[],\n  content: TimelineEntryItemContentRaw,\n  entryId: string,\n  isConversation = false\n) {\n  const tweet = parseTimelineEntryItemContentRaw(content, entryId, isConversation);\n\n  if (tweet) {\n    tweets.push(tweet);\n  }\n}\n\n/**\n * Parses a threaded conversation object and returns an array of Tweets.\n * @param conversation The threaded conversation object to parse\n * @returns An array of Tweet objects parsed from the conversation\n */\nexport function parseThreadedConversation(conversation: ThreadedConversation): Tweet[] {\n  const tweets: Tweet[] = [];\n  const instructions =\n    conversation.data?.threaded_conversation_with_injections_v2?.instructions ?? [];\n\n  for (const instruction of instructions) {\n    const entries = instruction.entries ?? [];\n    for (const entry of entries) {\n      const entryContent = entry.content?.itemContent;\n      if (entryContent) {\n        parseAndPush(tweets, entryContent, entry.entryId, true);\n      }\n\n      for (const item of entry.content?.items ?? []) {\n        const itemContent = item.item?.itemContent;\n        if (itemContent) {\n          parseAndPush(tweets, itemContent, entry.entryId, true);\n        }\n      }\n    }\n  }\n\n  for (const tweet of tweets) {\n    if (tweet.inReplyToStatusId) {\n      for (const parentTweet of tweets) {\n        if (parentTweet.id === tweet.inReplyToStatusId) {\n          tweet.inReplyToStatus = parentTweet;\n          break;\n        }\n      }\n    }\n\n    if (tweet.isSelfThread && tweet.conversationId === tweet.id) {\n      for (const childTweet of tweets) {\n        if (childTweet.isSelfThread && childTweet.id !== tweet.id) {\n          tweet.thread.push(childTweet);\n        }\n      }\n\n      if (tweet.thread.length === 0) {\n        tweet.isSelfThread = false;\n      }\n    }\n  }\n\n  return tweets;\n}\n\n/**\n * Interface representing a timeline article.\n * @typedef {Object} TimelineArticle\n * @property {string} id - The unique identifier for the article.\n * @property {string} articleId - The identifier for the article.\n * @property {string} title - The title of the article.\n * @property {string} previewText - The preview text of the article.\n * @property {string} [coverMediaUrl] - The URL of the cover media for the article. (Optional)\n * @property {string} text - The main text content of the article.\n */\nexport interface TimelineArticle {\n  id: string;\n  articleId: string;\n  title: string;\n  previewText: string;\n  coverMediaUrl?: string;\n  text: string;\n}\n\n/**\n * Parses a ThreadedConversation object to extract TimelineArticle objects.\n *\n * @param {ThreadedConversation} conversation - The ThreadedConversation object to parse.\n * @returns {TimelineArticle[]} The extracted TimelineArticle objects.\n */\nexport function parseArticle(conversation: ThreadedConversation): TimelineArticle[] {\n  const articles: TimelineArticle[] = [];\n  for (const instruction of conversation.data?.threaded_conversation_with_injections_v2\n    ?.instructions ?? []) {\n    for (const entry of instruction.entries ?? []) {\n      const id = entry.content?.itemContent?.tweet_results?.result?.rest_id;\n      const article =\n        entry.content?.itemContent?.tweet_results?.result?.article?.article_results?.result;\n      if (!id || !article) continue;\n      const text = article.content_state?.blocks?.map((block) => block.text).join('\\n\\n') ?? '';\n      articles.push({\n        id,\n        articleId: article.rest_id || '',\n        coverMediaUrl: article.cover_media?.media_info?.original_img_url,\n        previewText: article.preview_text || '',\n        text,\n        title: article.title || '',\n      });\n    }\n  }\n  return articles;\n}\n","import { type Profile, parseProfile } from './profile';\nimport type { QueryProfilesResponse, QueryTweetsResponse } from './timeline-v1';\nimport { type SearchEntryRaw, parseLegacyTweet } from './timeline-v2';\nimport type { Tweet } from './tweets';\n\n/**\n * Represents a search timeline object.\n * * @typedef { Object } SearchTimeline\n * @property { Object } [data] - Optional data object containing search information.\n * @property { Object } [data.search_by_raw_query] - Optional object containing search timeline information.\n * @property { Object } [data.search_by_raw_query.search_timeline] - Optional object containing search timeline details.\n * @property { Object } [data.search_by_raw_query.search_timeline.timeline] - Optional object containing timeline instructions.\n * @property {Array<Object>} [data.search_by_raw_query.search_timeline.timeline.instructions] - Optional array of search entry instructions.\n * @property {Array<SearchEntryRaw>} [data.search_by_raw_query.search_timeline.timeline.instructions.entries] - Optional array of raw search entries.\n * @property { SearchEntryRaw } [data.search_by_raw_query.search_timeline.timeline.instructions.entry] - Optional raw search entry.\n * @property { string } [data.search_by_raw_query.search_timeline.timeline.instructions.type] - Optional type of search instructions.\n */\nexport interface SearchTimeline {\n  data?: {\n    search_by_raw_query?: {\n      search_timeline?: {\n        timeline?: {\n          instructions?: {\n            entries?: SearchEntryRaw[];\n            entry?: SearchEntryRaw;\n            type?: string;\n          }[];\n        };\n      };\n    };\n  };\n}\n\n/**\n * Parses the search timeline tweets from the provided SearchTimeline object.\n *\n * @param {SearchTimeline} timeline The SearchTimeline object containing the data to be parsed.\n * @returns {QueryTweetsResponse} An object containing an array of parsed Tweet objects, as well as the next and previous cursors for pagination.\n */\nexport function parseSearchTimelineTweets(timeline: SearchTimeline): QueryTweetsResponse {\n  let bottomCursor: string | undefined;\n  let topCursor: string | undefined;\n  const tweets: Tweet[] = [];\n  const instructions =\n    timeline.data?.search_by_raw_query?.search_timeline?.timeline?.instructions ?? [];\n  for (const instruction of instructions) {\n    if (instruction.type === 'TimelineAddEntries' || instruction.type === 'TimelineReplaceEntry') {\n      if (instruction.entry?.content?.cursorType === 'Bottom') {\n        bottomCursor = instruction.entry.content.value;\n        continue;\n      }\n      if (instruction.entry?.content?.cursorType === 'Top') {\n        topCursor = instruction.entry.content.value;\n        continue;\n      }\n\n      const entries = instruction.entries ?? [];\n      for (const entry of entries) {\n        const itemContent = entry.content?.itemContent;\n        if (itemContent?.tweetDisplayType === 'Tweet') {\n          const tweetResultRaw = itemContent.tweet_results?.result;\n          const tweetResult = parseLegacyTweet(\n            tweetResultRaw?.core?.user_results?.result?.legacy,\n            tweetResultRaw?.legacy\n          );\n\n          if (tweetResult.success) {\n            if (!tweetResult.tweet.views && tweetResultRaw?.views?.count) {\n              const views = Number.parseInt(tweetResultRaw.views.count);\n              if (!Number.isNaN(views)) {\n                tweetResult.tweet.views = views;\n              }\n            }\n\n            tweets.push(tweetResult.tweet);\n          }\n        } else if (entry.content?.cursorType === 'Bottom') {\n          bottomCursor = entry.content.value;\n        } else if (entry.content?.cursorType === 'Top') {\n          topCursor = entry.content.value;\n        }\n      }\n    }\n  }\n\n  return { tweets, next: bottomCursor, previous: topCursor };\n}\n\n/**\n * Parses the search timeline users from the provided SearchTimeline.\n * @param {SearchTimeline} timeline The search timeline to parse users from.\n * @returns {QueryProfilesResponse} An object containing the parsed profiles along with next and previous cursors.\n */\nexport function parseSearchTimelineUsers(timeline: SearchTimeline): QueryProfilesResponse {\n  let bottomCursor: string | undefined;\n  let topCursor: string | undefined;\n  const profiles: Profile[] = [];\n  const instructions =\n    timeline.data?.search_by_raw_query?.search_timeline?.timeline?.instructions ?? [];\n\n  for (const instruction of instructions) {\n    if (instruction.type === 'TimelineAddEntries' || instruction.type === 'TimelineReplaceEntry') {\n      if (instruction.entry?.content?.cursorType === 'Bottom') {\n        bottomCursor = instruction.entry.content.value;\n        continue;\n      }\n      if (instruction.entry?.content?.cursorType === 'Top') {\n        topCursor = instruction.entry.content.value;\n        continue;\n      }\n\n      const entries = instruction.entries ?? [];\n      for (const entry of entries) {\n        const itemContent = entry.content?.itemContent;\n        if (itemContent?.userDisplayType === 'User') {\n          const userResultRaw = itemContent.user_results?.result;\n\n          if (userResultRaw?.legacy) {\n            const profile = parseProfile(userResultRaw.legacy, userResultRaw.is_blue_verified);\n\n            if (!profile.userId) {\n              profile.userId = userResultRaw.rest_id;\n            }\n\n            profiles.push(profile);\n          }\n        } else if (entry.content?.cursorType === 'Bottom') {\n          bottomCursor = entry.content.value;\n        } else if (entry.content?.cursorType === 'Top') {\n          topCursor = entry.content.value;\n        }\n      }\n    }\n  }\n\n  return { profiles, next: bottomCursor, previous: topCursor };\n}\n","import type { TwitterAuth } from './auth';\nimport { updateCookieJar } from './requests';\nimport type {\n  AudioSpace,\n  AudioSpaceByIdResponse,\n  AudioSpaceByIdVariables,\n  AuthenticatePeriscopeResponse,\n  BrowseSpaceTopicsResponse,\n  Community,\n  CommunitySelectQueryResponse,\n  LiveVideoStreamStatus,\n  LoginTwitterTokenResponse,\n  Subtopic,\n} from './types/spaces';\n\n/**\n * Generates a random string that mimics a UUID v4.\n */\n// TODO: install and replace with uuidv4\n/**\n * Generates a random UUID (Universally Unique Identifier) in the form of \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".\n * @returns {string} A randomly generated UUID.\n */\nfunction generateRandomId(): string {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\n/**\n * Fetches details of an Audio Space by its ID.\n * @param variables The variables required for the GraphQL query.\n * @param auth The authentication object.\n * @returns The details of the Audio Space.\n */\nexport async function fetchAudioSpaceById(\n  variables: AudioSpaceByIdVariables,\n  auth: TwitterAuth\n): Promise<AudioSpace> {\n  const queryId = 'Tvv_cNXCbtTcgdy1vWYPMw'; // Specific to the AudioSpaceById GraphQL query\n  const operationName = 'AudioSpaceById';\n\n  // URL encode the variables and features\n  const variablesEncoded = encodeURIComponent(JSON.stringify(variables));\n  const features = {\n    spaces_2022_h2_spaces_communities: true,\n    spaces_2022_h2_clipping: true,\n    creator_subscriptions_tweet_preview_api_enabled: true,\n    profile_label_improvements_pcf_label_in_post_enabled: false,\n    rweb_tipjar_consumption_enabled: true,\n    responsive_web_graphql_exclude_directive_enabled: true,\n    verified_phone_label_enabled: false,\n    premium_content_api_read_enabled: false,\n    communities_web_enable_tweet_community_results_fetch: true,\n    c9s_tweet_anatomy_moderator_badge_enabled: true,\n    responsive_web_grok_analyze_button_fetch_trends_enabled: true,\n    articles_preview_enabled: true,\n    responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,\n    responsive_web_edit_tweet_api_enabled: true,\n    graphql_is_translatable_rweb_tweet_is_translatable_enabled: true,\n    view_counts_everywhere_api_enabled: true,\n    longform_notetweets_consumption_enabled: true,\n    responsive_web_twitter_article_tweet_consumption_enabled: true,\n    tweet_awards_web_tipping_enabled: false,\n    creator_subscriptions_quote_tweet_preview_enabled: false,\n    freedom_of_speech_not_reach_fetch_enabled: true,\n    standardized_nudges_misinfo: true,\n    tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: true,\n    rweb_video_timestamps_enabled: true,\n    longform_notetweets_rich_text_read_enabled: true,\n    longform_notetweets_inline_media_enabled: true,\n    responsive_web_graphql_timeline_navigation_enabled: true,\n    responsive_web_enhance_cards_enabled: false,\n  };\n  const featuresEncoded = encodeURIComponent(JSON.stringify(features));\n\n  const url = `https://x.com/i/api/graphql/${queryId}/${operationName}?variables=${variablesEncoded}&features=${featuresEncoded}`;\n\n  const onboardingTaskUrl = 'https://api.twitter.com/1.1/onboarding/task.json';\n\n  // Retrieve necessary cookies and tokens\n  const cookies = await auth.cookieJar().getCookies(onboardingTaskUrl);\n  const xCsrfToken = cookies.find((cookie) => cookie.key === 'ct0');\n\n  const headers = new Headers({\n    Accept: '*/*',\n    Authorization: `Bearer ${(auth as any).bearerToken}`,\n    'Content-Type': 'application/json',\n    Cookie: await auth.cookieJar().getCookieString(onboardingTaskUrl),\n    'User-Agent':\n      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\n    'x-guest-token': (auth as any).guestToken,\n    'x-twitter-auth-type': 'OAuth2Client',\n    'x-twitter-active-user': 'yes',\n    'x-csrf-token': xCsrfToken?.value as string,\n  });\n\n  const response = await auth.fetch(url, {\n    headers,\n    method: 'GET',\n  });\n\n  // Update the cookie jar with any new cookies from the response\n  await updateCookieJar(auth.cookieJar(), response.headers);\n\n  // Check for errors in the response\n  if (!response.ok) {\n    throw new Error(`Failed to fetch Audio Space: ${await response.text()}`);\n  }\n\n  const data: AudioSpaceByIdResponse = await response.json();\n\n  if (data.errors && data.errors.length > 0) {\n    throw new Error(`API Errors: ${JSON.stringify(data.errors)}`);\n  }\n\n  return data.data.audioSpace;\n}\n\n/**\n * Fetches available space topics from Twitter.\n * @param auth The authentication object.\n * @returns An array of space topics.\n */\nexport async function fetchBrowseSpaceTopics(auth: TwitterAuth): Promise<Subtopic[]> {\n  const queryId = 'TYpVV9QioZfViHqEqRZxJA';\n  const operationName = 'BrowseSpaceTopics';\n\n  const variables = {};\n  const features = {};\n\n  const variablesEncoded = encodeURIComponent(JSON.stringify(variables));\n  const featuresEncoded = encodeURIComponent(JSON.stringify(features));\n\n  const url = `https://x.com/i/api/graphql/${queryId}/${operationName}?variables=${variablesEncoded}&features=${featuresEncoded}`;\n\n  const onboardingTaskUrl = 'https://api.twitter.com/1.1/onboarding/task.json';\n\n  // Retrieve necessary cookies and tokens\n  const cookies = await auth.cookieJar().getCookies(onboardingTaskUrl);\n  const xCsrfToken = cookies.find((cookie) => cookie.key === 'ct0');\n\n  const headers = new Headers({\n    Accept: '*/*',\n    Authorization: `Bearer ${(auth as any).bearerToken}`,\n    'Content-Type': 'application/json',\n    Cookie: await auth.cookieJar().getCookieString(onboardingTaskUrl),\n    'User-Agent':\n      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\n    'x-guest-token': (auth as any).guestToken,\n    'x-twitter-auth-type': 'OAuth2Client',\n    'x-twitter-active-user': 'yes',\n    'x-csrf-token': xCsrfToken?.value as string,\n  });\n\n  const response = await auth.fetch(url, {\n    headers,\n    method: 'GET',\n  });\n\n  // Update the cookie jar with any new cookies from the response\n  await updateCookieJar(auth.cookieJar(), response.headers);\n\n  // Check for errors in the response\n  if (!response.ok) {\n    throw new Error(`Failed to fetch Space Topics: ${await response.text()}`);\n  }\n\n  const data: BrowseSpaceTopicsResponse = await response.json();\n\n  if (data.errors && data.errors.length > 0) {\n    throw new Error(`API Errors: ${JSON.stringify(data.errors)}`);\n  }\n\n  // Flatten the subtopics from all categories into a single array\n  return data.data.browse_space_topics.categories.flatMap((category) => category.subtopics);\n}\n\n/**\n * Fetches available communities from Twitter.\n * @param auth The authentication object.\n * @returns An array of communities.\n */\nexport async function fetchCommunitySelectQuery(auth: TwitterAuth): Promise<Community[]> {\n  const queryId = 'Lue1DfmoW2cc0225t_8z1w'; // Specific to the CommunitySelectQuery GraphQL query\n  const operationName = 'CommunitySelectQuery';\n\n  const variables = {};\n  const features = {};\n\n  const variablesEncoded = encodeURIComponent(JSON.stringify(variables));\n  const featuresEncoded = encodeURIComponent(JSON.stringify(features));\n\n  const url = `https://x.com/i/api/graphql/${queryId}/${operationName}?variables=${variablesEncoded}&features=${featuresEncoded}`;\n\n  const onboardingTaskUrl = 'https://api.twitter.com/1.1/onboarding/task.json';\n\n  // Retrieve necessary cookies and tokens\n  const cookies = await auth.cookieJar().getCookies(onboardingTaskUrl);\n  const xCsrfToken = cookies.find((cookie) => cookie.key === 'ct0');\n\n  const headers = new Headers({\n    Accept: '*/*',\n    Authorization: `Bearer ${(auth as any).bearerToken}`,\n    'Content-Type': 'application/json',\n    Cookie: await auth.cookieJar().getCookieString(onboardingTaskUrl),\n    'User-Agent':\n      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\n    'x-guest-token': (auth as any).guestToken,\n    'x-twitter-auth-type': 'OAuth2Client',\n    'x-twitter-active-user': 'yes',\n    'x-csrf-token': xCsrfToken?.value as string,\n  });\n\n  const response = await auth.fetch(url, {\n    headers,\n    method: 'GET',\n  });\n\n  // Update the cookie jar with any new cookies from the response\n  await updateCookieJar(auth.cookieJar(), response.headers);\n\n  // Check for errors in the response\n  if (!response.ok) {\n    throw new Error(`Failed to fetch Community Select Query: ${await response.text()}`);\n  }\n\n  const data: CommunitySelectQueryResponse = await response.json();\n\n  if (data.errors && data.errors.length > 0) {\n    throw new Error(`API Errors: ${JSON.stringify(data.errors)}`);\n  }\n\n  // Return the space_hostable_communities array, which may be empty\n  return data.data.space_hostable_communities;\n}\n\n/**\n * Fetches the status of an Audio Space stream by its media key.\n * @param mediaKey The media key of the Audio Space.\n * @param auth The authentication object.\n * @returns The status of the Audio Space stream.\n */\nexport async function fetchLiveVideoStreamStatus(\n  mediaKey: string,\n  auth: TwitterAuth\n): Promise<LiveVideoStreamStatus> {\n  const baseUrl = `https://x.com/i/api/1.1/live_video_stream/status/${mediaKey}`;\n  const queryParams = new URLSearchParams({\n    client: 'web',\n    use_syndication_guest_id: 'false',\n    cookie_set_host: 'x.com',\n  });\n\n  const url = `${baseUrl}?${queryParams.toString()}`;\n\n  const onboardingTaskUrl = 'https://api.twitter.com/1.1/onboarding/task.json';\n\n  // Retrieve necessary cookies and tokens\n  const cookies = await auth.cookieJar().getCookies(onboardingTaskUrl);\n  const xCsrfToken = cookies.find((cookie) => cookie.key === 'ct0');\n\n  const headers = new Headers({\n    Accept: '*/*',\n    Authorization: `Bearer ${(auth as any).bearerToken}`,\n    'Content-Type': 'application/json',\n    Cookie: await auth.cookieJar().getCookieString(onboardingTaskUrl),\n    'User-Agent':\n      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\n    'x-guest-token': (auth as any).guestToken,\n    'x-twitter-auth-type': 'OAuth2Client',\n    'x-twitter-active-user': 'yes',\n    'x-csrf-token': xCsrfToken?.value as string,\n  });\n\n  try {\n    const response = await auth.fetch(url, {\n      method: 'GET',\n      headers: headers,\n    });\n\n    // Update the cookie jar with any new cookies from the response\n    await updateCookieJar(auth.cookieJar(), response.headers);\n\n    // Check for errors in the response\n    if (!response.ok) {\n      throw new Error(`Failed to fetch live video stream status: ${await response.text()}`);\n    }\n\n    return await response.json();\n  } catch (error) {\n    console.error(`Error fetching live video stream status for mediaKey ${mediaKey}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Authenticates Periscope to obtain a token.\n * @param auth The authentication object.\n * @returns The Periscope authentication token.\n */\nexport async function fetchAuthenticatePeriscope(auth: TwitterAuth): Promise<string> {\n  const queryId = 'r7VUmxbfqNkx7uwjgONSNw';\n  const operationName = 'AuthenticatePeriscope';\n\n  const variables = {};\n  const features = {};\n\n  const variablesEncoded = encodeURIComponent(JSON.stringify(variables));\n  const featuresEncoded = encodeURIComponent(JSON.stringify(features));\n\n  const url = `https://x.com/i/api/graphql/${queryId}/${operationName}?variables=${variablesEncoded}&features=${featuresEncoded}`;\n\n  const onboardingTaskUrl = 'https://api.twitter.com/1.1/onboarding/task.json';\n\n  const cookies = await auth.cookieJar().getCookies(onboardingTaskUrl);\n  const xCsrfToken = cookies.find((cookie) => cookie.key === 'ct0');\n\n  if (!xCsrfToken) {\n    throw new Error('CSRF Token (ct0) not found in cookies.');\n  }\n\n  const clientTransactionId = generateRandomId();\n\n  const headers = new Headers({\n    Accept: '*/*',\n    Authorization: `Bearer ${(auth as any).bearerToken}`,\n    'Content-Type': 'application/json',\n    Cookie: await auth.cookieJar().getCookieString(onboardingTaskUrl),\n    'User-Agent':\n      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',\n    'x-guest-token': (auth as any).guestToken,\n    'x-twitter-auth-type': 'OAuth2Session',\n    'x-twitter-active-user': 'yes',\n    'x-csrf-token': xCsrfToken.value,\n    'x-client-transaction-id': clientTransactionId,\n    'sec-ch-ua-platform': '\"Windows\"',\n    'sec-ch-ua': '\"Google Chrome\";v=\"131\", \"Chromium\";v=\"131\", \"Not_A Brand\";v=\"24\"',\n    'x-twitter-client-language': 'en',\n    'sec-ch-ua-mobile': '?0',\n    Referer: 'https://x.com/i/spaces/start',\n  });\n\n  try {\n    const response = await auth.fetch(url, {\n      method: 'GET',\n      headers: headers,\n    });\n\n    await updateCookieJar(auth.cookieJar(), response.headers);\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`Error ${response.status}: ${errorText}`);\n    }\n\n    const data: AuthenticatePeriscopeResponse = await response.json();\n\n    if (data.errors && data.errors.length > 0) {\n      throw new Error(`API Errors: ${JSON.stringify(data.errors)}`);\n    }\n\n    if (!data.data.authenticate_periscope) {\n      throw new Error('Periscope authentication failed, no data returned.');\n    }\n\n    return data.data.authenticate_periscope;\n  } catch (error) {\n    console.error('Error during Periscope authentication:', error);\n    throw error;\n  }\n}\n\n/**\n * Logs in to Twitter via Proxsee using the Periscope JWT to obtain a login cookie.\n * @param jwt The JWT obtained via AuthenticatePeriscope.\n * @param auth The authentication object.\n * @returns The response containing the cookie and user information.\n */\nexport async function fetchLoginTwitterToken(\n  jwt: unknown,\n  auth: TwitterAuth\n): Promise<LoginTwitterTokenResponse> {\n  const url = 'https://proxsee.pscp.tv/api/v2/loginTwitterToken';\n\n  const idempotenceKey = generateRandomId();\n\n  const payload = {\n    jwt: jwt,\n    vendor_id: 'm5-proxsee-login-a2011357b73e',\n    create_user: true,\n  };\n\n  const headers = new Headers({\n    'Content-Type': 'application/json',\n    'User-Agent':\n      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',\n    Referer: 'https://x.com/',\n    'sec-ch-ua': '\"Google Chrome\";v=\"131\", \"Chromium\";v=\"131\", \"Not_A Brand\";v=\"24\"',\n    'sec-ch-ua-platform': '\"Windows\"',\n    'sec-ch-ua-mobile': '?0',\n    'X-Periscope-User-Agent': 'Twitter/m5',\n    'X-Idempotence': idempotenceKey,\n    'X-Attempt': '1',\n  });\n\n  try {\n    const response = await auth.fetch(url, {\n      method: 'POST',\n      headers: headers,\n      body: JSON.stringify(payload),\n    });\n\n    // Update the cookie jar with any new cookies from the response\n    await updateCookieJar(auth.cookieJar(), response.headers);\n\n    // Check if the response is successful\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`Error ${response.status}: ${errorText}`);\n    }\n\n    const data: LoginTwitterTokenResponse = await response.json();\n\n    if (!data.cookie || !data.user) {\n      throw new Error('Twitter authentication failed, missing data.');\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Error logging into Twitter via Proxsee:', error);\n    throw error;\n  }\n}\n","import { type RequestApiResult, requestApi } from './api';\nimport type { TwitterAuth } from './auth';\nimport { ApiError } from './errors';\nimport type { TimelineInstruction } from './timeline-v2';\n\n/**\n * Interface for the response data of the latest timeline for the home page.\n * @property {object} data - The response data object.\n * @property {object} data.home - The home object within the response data.\n * @property {array} data.home.home_timeline_urt - The array of timeline instructions for the home page.\n */\nexport interface HomeLatestTimelineResponse {\n  data?: {\n    home: {\n      home_timeline_urt: {\n        instructions: TimelineInstruction[];\n      };\n    };\n  };\n}\n\n/**\n * Fetches the following timeline from Twitter API.\n *\n * @param {number} count - The number of tweets to fetch\n * @param {string[]} seenTweetIds - Array of IDs of tweets that have been seen\n * @param {TwitterAuth} auth - The authentication credentials\n * @returns {Promise<any[]>} - Array of tweets in the following timeline\n */\nexport async function fetchFollowingTimeline(\n  count: number,\n  seenTweetIds: string[],\n  auth: TwitterAuth\n): Promise<any[]> {\n  const variables = {\n    count,\n    includePromotedContent: true,\n    latestControlAvailable: true,\n    requestContext: 'launch',\n    seenTweetIds,\n  };\n\n  const features = {\n    profile_label_improvements_pcf_label_in_post_enabled: true,\n    rweb_tipjar_consumption_enabled: true,\n    responsive_web_graphql_exclude_directive_enabled: true,\n    verified_phone_label_enabled: false,\n    creator_subscriptions_tweet_preview_api_enabled: true,\n    responsive_web_graphql_timeline_navigation_enabled: true,\n    responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,\n    communities_web_enable_tweet_community_results_fetch: true,\n    c9s_tweet_anatomy_moderator_badge_enabled: true,\n    articles_preview_enabled: true,\n    responsive_web_edit_tweet_api_enabled: true,\n    graphql_is_translatable_rweb_tweet_is_translatable_enabled: true,\n    view_counts_everywhere_api_enabled: true,\n    longform_notetweets_consumption_enabled: true,\n    responsive_web_twitter_article_tweet_consumption_enabled: true,\n    tweet_awards_web_tipping_enabled: false,\n    creator_subscriptions_quote_tweet_preview_enabled: false,\n    freedom_of_speech_not_reach_fetch_enabled: true,\n    standardized_nudges_misinfo: true,\n    tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: true,\n    rweb_video_timestamps_enabled: true,\n    longform_notetweets_rich_text_read_enabled: true,\n    longform_notetweets_inline_media_enabled: true,\n    responsive_web_enhance_cards_enabled: false,\n  };\n\n  const res = (await requestApi<HomeLatestTimelineResponse>(\n    `https://x.com/i/api/graphql/K0X1xbCZUjttdK8RazKAlw/HomeLatestTimeline?variables=${encodeURIComponent(\n      JSON.stringify(variables)\n    )}&features=${encodeURIComponent(JSON.stringify(features))}`,\n    auth,\n    'GET'\n  )) as RequestApiResult<HomeLatestTimelineResponse>;\n\n  if (!res.success) {\n    if ((res as any).err instanceof ApiError) {\n      console.error('Error details:', (res as any).err.data);\n    }\n    throw (res as any).err;\n  }\n\n  const home = res.value?.data?.home.home_timeline_urt?.instructions;\n\n  if (!home) {\n    return [];\n  }\n\n  const entries: any[] = [];\n\n  for (const instruction of home) {\n    if (instruction.type === 'TimelineAddEntries') {\n      for (const entry of instruction.entries ?? []) {\n        entries.push(entry);\n      }\n    }\n  }\n  // get the itemContnent from each entry\n  const tweets = entries\n    .map((entry) => entry.content.itemContent?.tweet_results?.result)\n    .filter((tweet) => tweet !== undefined);\n\n  return tweets;\n}\n","import { requestApi } from './api';\nimport type { TwitterAuth } from './auth';\nimport { ApiError } from './errors';\nimport type { TimelineInstruction } from './timeline-v2';\n\n/**\n * Interface representing the response object for the home timeline API endpoint.\n * @property {object} data - The data object containing the response data.\n * @property {object} data.home - The home object containing the home timeline data.\n * @property {object} data.home.home_timeline_urt - The object containing the timeline instructions.\n * @property {TimelineInstruction[]} data.home.home_timeline_urt.instructions - An array of timeline instructions.\n */\nexport interface HomeTimelineResponse {\n  data?: {\n    home: {\n      home_timeline_urt: {\n        instructions: TimelineInstruction[];\n      };\n    };\n  };\n}\n\n/**\n * Fetches the home timeline for a Twitter user.\n *\n * @param {number} count - The number of tweets to fetch.\n * @param {string[]} seenTweetIds - An array of ids of tweets that the user has already seen.\n * @param {TwitterAuth} auth - The authentication credentials for the Twitter API.\n * @returns {Promise<any[]>} - A promise that resolves to an array of tweets from the home timeline.\n */\nexport async function fetchHomeTimeline(\n  count: number,\n  seenTweetIds: string[],\n  auth: TwitterAuth\n): Promise<any[]> {\n  const variables = {\n    count,\n    includePromotedContent: true,\n    latestControlAvailable: true,\n    requestContext: 'launch',\n    withCommunity: true,\n    seenTweetIds,\n  };\n\n  const features = {\n    rweb_tipjar_consumption_enabled: true,\n    responsive_web_graphql_exclude_directive_enabled: true,\n    verified_phone_label_enabled: false,\n    creator_subscriptions_tweet_preview_api_enabled: true,\n    responsive_web_graphql_timeline_navigation_enabled: true,\n    responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,\n    communities_web_enable_tweet_community_results_fetch: true,\n    c9s_tweet_anatomy_moderator_badge_enabled: true,\n    articles_preview_enabled: true,\n    responsive_web_edit_tweet_api_enabled: true,\n    graphql_is_translatable_rweb_tweet_is_translatable_enabled: true,\n    view_counts_everywhere_api_enabled: true,\n    longform_notetweets_consumption_enabled: true,\n    responsive_web_twitter_article_tweet_consumption_enabled: true,\n    tweet_awards_web_tipping_enabled: false,\n    creator_subscriptions_quote_tweet_preview_enabled: false,\n    freedom_of_speech_not_reach_fetch_enabled: true,\n    standardized_nudges_misinfo: true,\n    tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: true,\n    rweb_video_timestamps_enabled: true,\n    longform_notetweets_rich_text_read_enabled: true,\n    longform_notetweets_inline_media_enabled: true,\n    responsive_web_enhance_cards_enabled: false,\n  };\n\n  const res = await requestApi<HomeTimelineResponse>(\n    `https://x.com/i/api/graphql/HJFjzBgCs16TqxewQOeLNg/HomeTimeline?variables=${encodeURIComponent(\n      JSON.stringify(variables)\n    )}&features=${encodeURIComponent(JSON.stringify(features))}`,\n    auth,\n    'GET'\n  );\n\n  if (!res.success) {\n    if (res.err instanceof ApiError) {\n      console.error('Error details:', res.err.data);\n    }\n    throw res.err;\n  }\n\n  const home = res.value?.data?.home.home_timeline_urt?.instructions;\n\n  if (!home) {\n    return [];\n  }\n\n  const entries: any[] = [];\n\n  for (const instruction of home) {\n    if (instruction.type === 'TimelineAddEntries') {\n      for (const entry of instruction.entries ?? []) {\n        entries.push(entry);\n      }\n    }\n  }\n  // get the itemContnent from each entry\n  const tweets = entries\n    .map((entry) => entry.content.itemContent?.tweet_results?.result)\n    .filter((tweet) => tweet !== undefined);\n\n  return tweets;\n}\n","import { addApiParams, requestApi } from './api';\nimport type { TwitterAuth } from './auth';\nimport type { TimelineV1 } from './timeline-v1';\n\n/**\n * Retrieves the current trends from the Twitter API.\n *\n * @param {TwitterAuth} auth - The authentication credentials for accessing the Twitter API.\n * @returns {Promise<string[]>} An array of strings representing the current trends.\n * @throws {Error} If no trend entries are found in the response.\n */\nexport async function getTrends(auth: TwitterAuth): Promise<string[]> {\n  const params = new URLSearchParams();\n  addApiParams(params, false);\n\n  params.set('count', '20');\n  params.set('candidate_source', 'trends');\n  params.set('include_page_configuration', 'false');\n  params.set('entity_tokens', 'false');\n\n  const res = await requestApi<TimelineV1>(\n    `https://api.twitter.com/2/guide.json?${params.toString()}`,\n    auth\n  );\n  if (!res.success) {\n    throw res.err;\n  }\n\n  const instructions = res.value.timeline?.instructions ?? [];\n  if (instructions.length < 2) {\n    throw new Error('No trend entries found.');\n  }\n\n  // Some of this is silly, but for now we're assuming we know nothing about the\n  // data, and that anything can be missing. Go has non-nilable strings and empty\n  // slices are nil, so it largely doesn't need to worry about this.\n  const entries = instructions[1].addEntries?.entries ?? [];\n  if (entries.length < 2) {\n    throw new Error('No trend entries found.');\n  }\n\n  const items = entries[1].content?.timelineModule?.items ?? [];\n  const trends: string[] = [];\n  for (const item of items) {\n    const trend =\n      item.item?.clientEventInfo?.details?.guideDetails?.transparentGuideDetails?.trendMetadata\n        ?.trendName;\n    if (trend != null) {\n      trends.push(trend);\n    }\n  }\n\n  return trends;\n}\n","import stringify from 'json-stable-stringify';\n\n/**\n * Examples of requests to API endpoints. These are parsed at runtime and used\n * as templates for requests to a particular endpoint. Please ensure these do\n * not contain any information that you do not want published to NPM.\n */\n/**\n * Object containing various endpoint URLs for Twitter API.\n *\n * @type {Object}\n */\nconst endpoints = {\n  // TODO: Migrate other endpoint URLs here\n  UserTweets:\n    'https://twitter.com/i/api/graphql/V7H0Ap3_Hh2FyS75OCDO3Q/UserTweets?variables=%7B%22userId%22%3A%224020276615%22%2C%22count%22%3A20%2C%22includePromotedContent%22%3Atrue%2C%22withQuickPromoteEligibilityTweetFields%22%3Atrue%2C%22withVoice%22%3Atrue%2C%22withV2Timeline%22%3Atrue%7D&features=%7B%22rweb_tipjar_consumption_enabled%22%3Atrue%2C%22responsive_web_graphql_exclude_directive_enabled%22%3Atrue%2C%22verified_phone_label_enabled%22%3Afalse%2C%22creator_subscriptions_tweet_preview_api_enabled%22%3Atrue%2C%22responsive_web_graphql_timeline_navigation_enabled%22%3Atrue%2C%22responsive_web_graphql_skip_user_profile_image_extensions_enabled%22%3Afalse%2C%22communities_web_enable_tweet_community_results_fetch%22%3Atrue%2C%22c9s_tweet_anatomy_moderator_badge_enabled%22%3Atrue%2C%22articles_preview_enabled%22%3Atrue%2C%22tweetypie_unmention_optimization_enabled%22%3Atrue%2C%22responsive_web_edit_tweet_api_enabled%22%3Atrue%2C%22graphql_is_translatable_rweb_tweet_is_translatable_enabled%22%3Atrue%2C%22view_counts_everywhere_api_enabled%22%3Atrue%2C%22longform_notetweets_consumption_enabled%22%3Atrue%2C%22responsive_web_twitter_article_tweet_consumption_enabled%22%3Atrue%2C%22tweet_awards_web_tipping_enabled%22%3Afalse%2C%22creator_subscriptions_quote_tweet_preview_enabled%22%3Afalse%2C%22freedom_of_speech_not_reach_fetch_enabled%22%3Atrue%2C%22standardized_nudges_misinfo%22%3Atrue%2C%22tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled%22%3Atrue%2C%22rweb_video_timestamps_enabled%22%3Atrue%2C%22longform_notetweets_rich_text_read_enabled%22%3Atrue%2C%22longform_notetweets_inline_media_enabled%22%3Atrue%2C%22responsive_web_enhance_cards_enabled%22%3Afalse%7D&fieldToggles=%7B%22withArticlePlainText%22%3Afalse%7D',\n  UserTweetsAndReplies:\n    'https://twitter.com/i/api/graphql/E4wA5vo2sjVyvpliUffSCw/UserTweetsAndReplies?variables=%7B%22userId%22%3A%224020276615%22%2C%22count%22%3A40%2C%22cursor%22%3A%22DAABCgABGPWl-F-ATiIKAAIY9YfiF1rRAggAAwAAAAEAAA%22%2C%22includePromotedContent%22%3Atrue%2C%22withCommunity%22%3Atrue%2C%22withVoice%22%3Atrue%2C%22withV2Timeline%22%3Atrue%7D&features=%7B%22rweb_tipjar_consumption_enabled%22%3Atrue%2C%22responsive_web_graphql_exclude_directive_enabled%22%3Atrue%2C%22verified_phone_label_enabled%22%3Afalse%2C%22creator_subscriptions_tweet_preview_api_enabled%22%3Atrue%2C%22responsive_web_graphql_timeline_navigation_enabled%22%3Atrue%2C%22responsive_web_graphql_skip_user_profile_image_extensions_enabled%22%3Afalse%2C%22communities_web_enable_tweet_community_results_fetch%22%3Atrue%2C%22c9s_tweet_anatomy_moderator_badge_enabled%22%3Atrue%2C%22articles_preview_enabled%22%3Atrue%2C%22tweetypie_unmention_optimization_enabled%22%3Atrue%2C%22responsive_web_edit_tweet_api_enabled%22%3Atrue%2C%22graphql_is_translatable_rweb_tweet_is_translatable_enabled%22%3Atrue%2C%22view_counts_everywhere_api_enabled%22%3Atrue%2C%22longform_notetweets_consumption_enabled%22%3Atrue%2C%22responsive_web_twitter_article_tweet_consumption_enabled%22%3Atrue%2C%22tweet_awards_web_tipping_enabled%22%3Afalse%2C%22creator_subscriptions_quote_tweet_preview_enabled%22%3Afalse%2C%22freedom_of_speech_not_reach_fetch_enabled%22%3Atrue%2C%22standardized_nudges_misinfo%22%3Atrue%2C%22tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled%22%3Atrue%2C%22rweb_video_timestamps_enabled%22%3Atrue%2C%22longform_notetweets_rich_text_read_enabled%22%3Atrue%2C%22longform_notetweets_inline_media_enabled%22%3Atrue%2C%22responsive_web_enhance_cards_enabled%22%3Afalse%7D&fieldToggles=%7B%22withArticlePlainText%22%3Afalse%7D',\n  UserLikedTweets:\n    'https://twitter.com/i/api/graphql/eSSNbhECHHWWALkkQq-YTA/Likes?variables=%7B%22userId%22%3A%222244196397%22%2C%22count%22%3A20%2C%22includePromotedContent%22%3Afalse%2C%22withClientEventToken%22%3Afalse%2C%22withBirdwatchNotes%22%3Afalse%2C%22withVoice%22%3Atrue%2C%22withV2Timeline%22%3Atrue%7D&features=%7B%22responsive_web_graphql_exclude_directive_enabled%22%3Atrue%2C%22verified_phone_label_enabled%22%3Afalse%2C%22creator_subscriptions_tweet_preview_api_enabled%22%3Atrue%2C%22responsive_web_graphql_timeline_navigation_enabled%22%3Atrue%2C%22responsive_web_graphql_skip_user_profile_image_extensions_enabled%22%3Afalse%2C%22c9s_tweet_anatomy_moderator_badge_enabled%22%3Atrue%2C%22tweetypie_unmention_optimization_enabled%22%3Atrue%2C%22responsive_web_edit_tweet_api_enabled%22%3Atrue%2C%22graphql_is_translatable_rweb_tweet_is_translatable_enabled%22%3Atrue%2C%22view_counts_everywhere_api_enabled%22%3Atrue%2C%22longform_notetweets_consumption_enabled%22%3Atrue%2C%22responsive_web_twitter_article_tweet_consumption_enabled%22%3Atrue%2C%22tweet_awards_web_tipping_enabled%22%3Afalse%2C%22freedom_of_speech_not_reach_fetch_enabled%22%3Atrue%2C%22standardized_nudges_misinfo%22%3Atrue%2C%22tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled%22%3Atrue%2C%22rweb_video_timestamps_enabled%22%3Atrue%2C%22longform_notetweets_rich_text_read_enabled%22%3Atrue%2C%22longform_notetweets_inline_media_enabled%22%3Atrue%2C%22responsive_web_enhance_cards_enabled%22%3Afalse%7D',\n  TweetDetail:\n    'https://twitter.com/i/api/graphql/xOhkmRac04YFZmOzU9PJHg/TweetDetail?variables=%7B%22focalTweetId%22%3A%221237110546383724547%22%2C%22with_rux_injections%22%3Afalse%2C%22includePromotedContent%22%3Atrue%2C%22withCommunity%22%3Atrue%2C%22withQuickPromoteEligibilityTweetFields%22%3Atrue%2C%22withBirdwatchNotes%22%3Atrue%2C%22withVoice%22%3Atrue%2C%22withV2Timeline%22%3Atrue%7D&features=%7B%22responsive_web_graphql_exclude_directive_enabled%22%3Atrue%2C%22verified_phone_label_enabled%22%3Afalse%2C%22creator_subscriptions_tweet_preview_api_enabled%22%3Atrue%2C%22responsive_web_graphql_timeline_navigation_enabled%22%3Atrue%2C%22responsive_web_graphql_skip_user_profile_image_extensions_enabled%22%3Afalse%2C%22tweetypie_unmention_optimization_enabled%22%3Atrue%2C%22responsive_web_edit_tweet_api_enabled%22%3Atrue%2C%22graphql_is_translatable_rweb_tweet_is_translatable_enabled%22%3Atrue%2C%22view_counts_everywhere_api_enabled%22%3Atrue%2C%22longform_notetweets_consumption_enabled%22%3Atrue%2C%22responsive_web_twitter_article_tweet_consumption_enabled%22%3Afalse%2C%22tweet_awards_web_tipping_enabled%22%3Afalse%2C%22freedom_of_speech_not_reach_fetch_enabled%22%3Atrue%2C%22standardized_nudges_misinfo%22%3Atrue%2C%22tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled%22%3Atrue%2C%22longform_notetweets_rich_text_read_enabled%22%3Atrue%2C%22longform_notetweets_inline_media_enabled%22%3Atrue%2C%22responsive_web_media_download_video_enabled%22%3Afalse%2C%22responsive_web_enhance_cards_enabled%22%3Afalse%7D&fieldToggles=%7B%22withArticleRichContentState%22%3Afalse%7D',\n  TweetDetailArticle:\n    'https://twitter.com/i/api/graphql/GtcBtFhtQymrpxAs5MALVA/TweetDetail?variables=%7B%22focalTweetId%22%3A%221765884209527394325%22%2C%22with_rux_injections%22%3Atrue%2C%22rankingMode%22%3A%22Relevance%22%2C%22includePromotedContent%22%3Atrue%2C%22withCommunity%22%3Atrue%2C%22withQuickPromoteEligibilityTweetFields%22%3Atrue%2C%22withBirdwatchNotes%22%3Atrue%2C%22withVoice%22%3Atrue%7D&features=%7B%22profile_label_improvements_pcf_label_in_post_enabled%22%3Afalse%2C%22rweb_tipjar_consumption_enabled%22%3Atrue%2C%22responsive_web_graphql_exclude_directive_enabled%22%3Atrue%2C%22verified_phone_label_enabled%22%3Afalse%2C%22creator_subscriptions_tweet_preview_api_enabled%22%3Atrue%2C%22responsive_web_graphql_timeline_navigation_enabled%22%3Atrue%2C%22responsive_web_graphql_skip_user_profile_image_extensions_enabled%22%3Afalse%2C%22premium_content_api_read_enabled%22%3Afalse%2C%22communities_web_enable_tweet_community_results_fetch%22%3Atrue%2C%22c9s_tweet_anatomy_moderator_badge_enabled%22%3Atrue%2C%22responsive_web_grok_analyze_button_fetch_trends_enabled%22%3Atrue%2C%22responsive_web_grok_analyze_post_followups_enabled%22%3Afalse%2C%22responsive_web_grok_share_attachment_enabled%22%3Atrue%2C%22articles_preview_enabled%22%3Atrue%2C%22responsive_web_edit_tweet_api_enabled%22%3Atrue%2C%22graphql_is_translatable_rweb_tweet_is_translatable_enabled%22%3Atrue%2C%22view_counts_everywhere_api_enabled%22%3Atrue%2C%22longform_notetweets_consumption_enabled%22%3Atrue%2C%22responsive_web_twitter_article_tweet_consumption_enabled%22%3Atrue%2C%22tweet_awards_web_tipping_enabled%22%3Afalse%2C%22creator_subscriptions_quote_tweet_preview_enabled%22%3Afalse%2C%22freedom_of_speech_not_reach_fetch_enabled%22%3Atrue%2C%22standardized_nudges_misinfo%22%3Atrue%2C%22tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled%22%3Atrue%2C%22rweb_video_timestamps_enabled%22%3Atrue%2C%22longform_notetweets_rich_text_read_enabled%22%3Atrue%2C%22longform_notetweets_inline_media_enabled%22%3Atrue%2C%22responsive_web_enhance_cards_enabled%22%3Afalse%7D&fieldToggles=%7B%22withArticleRichContentState%22%3Atrue%2C%22withArticlePlainText%22%3Afalse%2C%22withGrokAnalyze%22%3Afalse%2C%22withDisallowedReplyControls%22%3Afalse%7D',\n  TweetResultByRestId:\n    'https://twitter.com/i/api/graphql/DJS3BdhUhcaEpZ7B7irJDg/TweetResultByRestId?variables=%7B%22tweetId%22%3A%221237110546383724547%22%2C%22withCommunity%22%3Afalse%2C%22includePromotedContent%22%3Afalse%2C%22withVoice%22%3Afalse%7D&features=%7B%22creator_subscriptions_tweet_preview_api_enabled%22%3Atrue%2C%22tweetypie_unmention_optimization_enabled%22%3Atrue%2C%22responsive_web_edit_tweet_api_enabled%22%3Atrue%2C%22graphql_is_translatable_rweb_tweet_is_translatable_enabled%22%3Atrue%2C%22view_counts_everywhere_api_enabled%22%3Atrue%2C%22longform_notetweets_consumption_enabled%22%3Atrue%2C%22responsive_web_twitter_article_tweet_consumption_enabled%22%3Afalse%2C%22tweet_awards_web_tipping_enabled%22%3Afalse%2C%22freedom_of_speech_not_reach_fetch_enabled%22%3Atrue%2C%22standardized_nudges_misinfo%22%3Atrue%2C%22tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled%22%3Atrue%2C%22longform_notetweets_rich_text_read_enabled%22%3Atrue%2C%22longform_notetweets_inline_media_enabled%22%3Atrue%2C%22responsive_web_graphql_exclude_directive_enabled%22%3Atrue%2C%22verified_phone_label_enabled%22%3Afalse%2C%22responsive_web_media_download_video_enabled%22%3Afalse%2C%22responsive_web_graphql_skip_user_profile_image_extensions_enabled%22%3Afalse%2C%22responsive_web_graphql_timeline_navigation_enabled%22%3Atrue%2C%22responsive_web_enhance_cards_enabled%22%3Afalse%7D',\n  ListTweets:\n    'https://twitter.com/i/api/graphql/whF0_KH1fCkdLLoyNPMoEw/ListLatestTweetsTimeline?variables=%7B%22listId%22%3A%221736495155002106192%22%2C%22count%22%3A20%7D&features=%7B%22responsive_web_graphql_exclude_directive_enabled%22%3Atrue%2C%22verified_phone_label_enabled%22%3Afalse%2C%22creator_subscriptions_tweet_preview_api_enabled%22%3Atrue%2C%22responsive_web_graphql_timeline_navigation_enabled%22%3Atrue%2C%22responsive_web_graphql_skip_user_profile_image_extensions_enabled%22%3Afalse%2C%22c9s_tweet_anatomy_moderator_badge_enabled%22%3Atrue%2C%22tweetypie_unmention_optimization_enabled%22%3Atrue%2C%22responsive_web_edit_tweet_api_enabled%22%3Atrue%2C%22graphql_is_translatable_rweb_tweet_is_translatable_enabled%22%3Atrue%2C%22view_counts_everywhere_api_enabled%22%3Atrue%2C%22longform_notetweets_consumption_enabled%22%3Atrue%2C%22responsive_web_twitter_article_tweet_consumption_enabled%22%3Afalse%2C%22tweet_awards_web_tipping_enabled%22%3Afalse%2C%22freedom_of_speech_not_reach_fetch_enabled%22%3Atrue%2C%22standardized_nudges_misinfo%22%3Atrue%2C%22tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled%22%3Atrue%2C%22rweb_video_timestamps_enabled%22%3Atrue%2C%22longform_notetweets_rich_text_read_enabled%22%3Atrue%2C%22longform_notetweets_inline_media_enabled%22%3Atrue%2C%22responsive_web_media_download_video_enabled%22%3Afalse%2C%22responsive_web_enhance_cards_enabled%22%3Afalse%7D',\n} as const;\n\nexport interface EndpointFieldInfo {\n  /**\n   * Request variables, used for providing arguments such as user IDs or result counts.\n   */\n  variables: Record<string, unknown>;\n\n  /**\n   * Request features, used for encoding feature flags into the request. These may either be\n   * boolean values or numerically-encoded booleans (1 or 0). It is possible this may change\n   * to include other representations of booleans as Twitter's backend evolves.\n   */\n  features: Record<string, unknown>;\n\n  /**\n   * Request field toggles, used for limiting how returned fields are represented. This is\n   * rarely used.\n   */\n  fieldToggles: Record<string, unknown>;\n}\n\ntype SomePartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\ntype EndpointVersion = string;\ntype EndpointName = string;\ntype EncodedVariables = string;\ntype EncodedFeatures = string;\ntype EncodedFieldToggles = string;\n\n// TODO: Set up field-level Intellisense for the QraphQL parameters in these?\ntype EndpointFields<EndpointUrl> =\n  EndpointUrl extends `https://twitter.com/i/api/graphql/${EndpointVersion}/${EndpointName}?variables=${EncodedVariables}&features=${EncodedFeatures}&fieldToggles=${EncodedFieldToggles}`\n    ? EndpointFieldInfo\n    : EndpointUrl extends `https://twitter.com/i/api/graphql/${EndpointVersion}/${EndpointName}?variables=${EncodedVariables}&features=${EncodedFeatures}`\n      ? SomePartial<EndpointFieldInfo, 'fieldToggles'>\n      : EndpointUrl extends `https://twitter.com/i/api/graphql/${EndpointVersion}/${EndpointName}?variables=${EncodedVariables}`\n        ? SomePartial<EndpointFieldInfo, 'features' | 'fieldToggles'>\n        : Partial<EndpointFieldInfo>;\n\nexport type ApiRequestInfo<EndpointUrl> = EndpointFields<EndpointUrl> & {\n  /**\n   * The URL, without any GraphQL query parameters.\n   */\n  url: string;\n\n  /**\n   * Converts the request back into a URL to be sent to the Twitter API.\n   */\n  toRequestUrl(): string;\n};\n\n/** Wrapper class for API request information. */\nclass ApiRequest<EndpointUrl> {\n  url: string;\n  variables?: Record<string, unknown> | undefined;\n  features?: Record<string, unknown> | undefined;\n  fieldToggles?: Record<string, unknown> | undefined;\n\n  constructor(info: Omit<ApiRequestInfo<EndpointUrl>, 'toRequestUrl'>) {\n    this.url = info.url;\n    this.variables = info.variables;\n    this.features = info.features;\n    this.fieldToggles = info.fieldToggles;\n  }\n\n  toRequestUrl(): string {\n    const params = new URLSearchParams();\n\n    // Only include query parameters with values\n    if (this.variables) {\n      // Stringify with the query keys in sorted order like the Go package\n      params.set('variables', stringify(this.variables) ?? '');\n    }\n\n    if (this.features) {\n      params.set('features', stringify(this.features) ?? '');\n    }\n\n    if (this.fieldToggles) {\n      params.set('fieldToggles', stringify(this.fieldToggles) ?? '');\n    }\n\n    return `${this.url}?${params.toString()}`;\n  }\n}\n\n/**\n * Parses information from a Twitter API endpoint using an example request\n * URL against that endpoint. This can be used to extract GraphQL parameters\n * in order to easily reuse and/or override them later.\n * @param example An example of the endpoint to analyze.\n * @returns The parsed endpoint information.\n */\nfunction parseEndpointExample<Endpoints, Endpoint extends string & keyof Endpoints>(\n  example: Endpoint\n): ApiRequestInfo<Endpoints[Endpoint]> {\n  const { protocol, host, pathname, searchParams: query } = new URL(example);\n\n  const base = `${protocol}//${host}${pathname}`;\n  const variables = query.get('variables');\n  const features = query.get('features');\n  const fieldToggles = query.get('fieldToggles');\n\n  return new ApiRequest<Endpoints[Endpoint]>({\n    url: base,\n    variables: variables ? JSON.parse(variables) : undefined,\n    features: features ? JSON.parse(features) : undefined,\n    fieldToggles: fieldToggles ? JSON.parse(fieldToggles) : undefined,\n  } as Omit<ApiRequestInfo<Endpoints[Endpoint]>, 'toRequestUrl'>) as ApiRequestInfo<\n    Endpoints[Endpoint]\n  >;\n}\n\ntype ApiRequestFactory<Endpoints> = {\n  [Endpoint in keyof Endpoints as `create${string & Endpoint}Request`]: () => ApiRequestInfo<\n    Endpoints[Endpoint]\n  >;\n};\n\nfunction createApiRequestFactory<Endpoints extends Record<string, string>>(\n  endpoints: Endpoints\n): ApiRequestFactory<Endpoints> {\n  type UntypedApiRequestFactory = ApiRequestFactory<Record<string, string>>;\n\n  return Object.entries(endpoints)\n    .map<UntypedApiRequestFactory>(([endpointName, endpointExample]) => {\n      // Create a partial factory for only one endpoint\n      return {\n        [`create${endpointName}Request`]: () => {\n          // Create a new instance on each invocation so that we can safely\n          // mutate requests before sending them off\n          return parseEndpointExample<Endpoints, any>(endpointExample);\n        },\n      };\n    })\n    .reduce((agg, next) => {\n      // Merge all of our factories into one that includes every endpoint\n      return Object.assign(agg, next);\n    }) as ApiRequestFactory<Endpoints>;\n}\n\nexport const apiRequestFactory = createApiRequestFactory(endpoints);\n","import type { QueryTweetsResponse } from './timeline-v1';\nimport { type TimelineEntryRaw, parseAndPush } from './timeline-v2';\nimport type { Tweet } from './tweets';\n\n/**\n * Interface representing a list timeline with optional data.\n *\n * @property {Object} data - Optional object containing list timeline data.\n * @property {Object} data.list - Optional object containing list information.\n * @property {Object} data.list.tweets_timeline - Optional object containing tweets timeline information.\n * @property {Object} data.list.tweets_timeline.timeline - Optional object containing timeline instructions.\n * @property {Object[]} data.list.tweets_timeline.timeline.instructions - Optional array of timeline instructions.\n * @property {Object[]} data.list.tweets_timeline.timeline.instructions.entries - Optional array of timeline entry objects.\n * @property {Object} data.list.tweets_timeline.timeline.instructions.entry - Optional single timeline entry object.\n * @property {string} data.list.tweets_timeline.timeline.instructions.type - Optional string indicating the type of timeline entry.\n */\n\nexport interface ListTimeline {\n  data?: {\n    list?: {\n      tweets_timeline?: {\n        timeline?: {\n          instructions?: {\n            entries?: TimelineEntryRaw[];\n            entry?: TimelineEntryRaw;\n            type?: string;\n          }[];\n        };\n      };\n    };\n  };\n}\n\n/**\n * Parses the list timeline tweets from the provided ListTimeline object.\n *\n * @param {ListTimeline} timeline The ListTimeline object to parse tweets from.\n * @returns {QueryTweetsResponse} An object containing the parsed tweets, next cursor, and previous cursor.\n */\nexport function parseListTimelineTweets(timeline: ListTimeline): QueryTweetsResponse {\n  let bottomCursor: string | undefined;\n  let topCursor: string | undefined;\n  const tweets: Tweet[] = [];\n  const instructions = timeline.data?.list?.tweets_timeline?.timeline?.instructions ?? [];\n  for (const instruction of instructions) {\n    const entries = instruction.entries ?? [];\n\n    for (const entry of entries) {\n      const entryContent = entry.content;\n      if (!entryContent) continue;\n\n      if (entryContent.cursorType === 'Bottom') {\n        bottomCursor = entryContent.value;\n        continue;\n      }\n      if (entryContent.cursorType === 'Top') {\n        topCursor = entryContent.value;\n        continue;\n      }\n\n      const idStr = entry.entryId;\n      if (!idStr.startsWith('tweet') && !idStr.startsWith('list-conversation')) {\n        continue;\n      }\n\n      if (entryContent.itemContent) {\n        parseAndPush(tweets, entryContent.itemContent, idStr);\n      } else if (entryContent.items) {\n        for (const contentItem of entryContent.items) {\n          if (contentItem.item?.itemContent && contentItem.entryId) {\n            parseAndPush(\n              tweets,\n              contentItem.item.itemContent,\n              contentItem.entryId.split('tweet-')[1]\n            );\n          }\n        }\n      }\n    }\n  }\n\n  return { tweets, next: bottomCursor, previous: topCursor };\n}\n","import type {\n  ApiV2Includes,\n  MediaObjectV2,\n  PlaceV2,\n  PollV2,\n  TTweetv2Expansion,\n  TTweetv2MediaField,\n  TTweetv2PlaceField,\n  TTweetv2PollField,\n  TTweetv2TweetField,\n  TTweetv2UserField,\n  TweetV2,\n  UserV2,\n} from 'twitter-api-v2';\nimport { addApiFeatures, requestApi } from './api';\nimport { apiRequestFactory } from './api-data';\nimport type { TwitterAuth } from './auth';\nimport { getEntityIdByScreenName } from './profile';\nimport { updateCookieJar } from './requests';\nimport { getTweetTimeline } from './timeline-async';\nimport { type ListTimeline, parseListTimelineTweets } from './timeline-list';\nimport type { QueryTweetsResponse } from './timeline-v1';\nimport {\n  type ThreadedConversation,\n  type TimelineArticle,\n  type TimelineEntryItemContentRaw,\n  type TimelineV2,\n  parseArticle,\n  parseThreadedConversation,\n  parseTimelineEntryItemContentRaw,\n  parseTimelineTweetsV2,\n} from './timeline-v2';\n\n/**\n * Default options for Twitter API v2 request parameters.\n * @typedef {Object} defaultOptions\n * @property {TTweetv2Expansion[]} expansions - List of expansions to include in the request.\n * @property {TTweetv2TweetField[]} tweetFields - List of tweet fields to include in the request.\n * @property {TTweetv2PollField[]} pollFields - List of poll fields to include in the request.\n * @property {TTweetv2MediaField[]} mediaFields - List of media fields to include in the request.\n * @property {TTweetv2UserField[]} userFields - List of user fields to include in the request.\n * @property {TTweetv2PlaceField[]} placeFields - List of place fields to include in the request.\n */\nexport const defaultOptions = {\n  expansions: [\n    'attachments.poll_ids',\n    'attachments.media_keys',\n    'author_id',\n    'referenced_tweets.id',\n    'in_reply_to_user_id',\n    'edit_history_tweet_ids',\n    'geo.place_id',\n    'entities.mentions.username',\n    'referenced_tweets.id.author_id',\n  ] as TTweetv2Expansion[],\n  tweetFields: [\n    'attachments',\n    'author_id',\n    'context_annotations',\n    'conversation_id',\n    'created_at',\n    'entities',\n    'geo',\n    'id',\n    'in_reply_to_user_id',\n    'lang',\n    'public_metrics',\n    'edit_controls',\n    'possibly_sensitive',\n    'referenced_tweets',\n    'reply_settings',\n    'source',\n    'text',\n    'withheld',\n    'note_tweet',\n  ] as TTweetv2TweetField[],\n  pollFields: [\n    'duration_minutes',\n    'end_datetime',\n    'id',\n    'options',\n    'voting_status',\n  ] as TTweetv2PollField[],\n  mediaFields: [\n    'duration_ms',\n    'height',\n    'media_key',\n    'preview_image_url',\n    'type',\n    'url',\n    'width',\n    'public_metrics',\n    'alt_text',\n    'variants',\n  ] as TTweetv2MediaField[],\n  userFields: [\n    'created_at',\n    'description',\n    'entities',\n    'id',\n    'location',\n    'name',\n    'profile_image_url',\n    'protected',\n    'public_metrics',\n    'url',\n    'username',\n    'verified',\n    'withheld',\n  ] as TTweetv2UserField[],\n  placeFields: [\n    'contained_within',\n    'country',\n    'country_code',\n    'full_name',\n    'geo',\n    'id',\n    'name',\n    'place_type',\n  ] as TTweetv2PlaceField[],\n};\n/**\n * Interface representing a mention.\n * @typedef {Object} Mention\n * @property {string} id - The unique identifier for the mention.\n * @property {string} [username] - The username associated with the mention.\n * @property {string} [name] - The name associated with the mention.\n */\nexport interface Mention {\n  id: string;\n  username?: string;\n  name?: string;\n}\n\n/**\n * Interface representing a photo object.\n * @interface\n * @property {string} id - The unique identifier for the photo.\n * @property {string} url - The URL for the photo image.\n * @property {string} [alt_text] - The alternative text for the photo image. Optional.\n */\nexport interface Photo {\n  id: string;\n  url: string;\n  alt_text: string | undefined;\n}\n\n/**\n * Interface representing a video object.\n * @typedef {Object} Video\n * @property {string} id - The unique identifier for the video.\n * @property {string} preview - The URL for the preview image of the video.\n * @property {string} [url] - The optional URL for the video.\n */\n\nexport interface Video {\n  id: string;\n  preview: string;\n  url?: string;\n}\n\n/**\n * Interface representing a raw place object.\n * @typedef {Object} PlaceRaw\n * @property {string} [id] - The unique identifier of the place.\n * @property {string} [place_type] - The type of the place.\n * @property {string} [name] - The name of the place.\n * @property {string} [full_name] - The full name of the place.\n * @property {string} [country_code] - The country code of the place.\n * @property {string} [country] - The country name of the place.\n * @property {Object} [bounding_box] - The bounding box coordinates of the place.\n * @property {string} [bounding_box.type] - The type of the bounding box.\n * @property {number[][][]} [bounding_box.coordinates] - The coordinates of the bounding box in an array format.\n */\nexport interface PlaceRaw {\n  id?: string;\n  place_type?: string;\n  name?: string;\n  full_name?: string;\n  country_code?: string;\n  country?: string;\n  bounding_box?: {\n    type?: string;\n    coordinates?: number[][][];\n  };\n}\n\n/**\n * Interface representing poll data.\n *\n * @property {string} [id] - The unique identifier for the poll.\n * @property {string} [end_datetime] - The end date and time for the poll.\n * @property {string} [voting_status] - The status of the voting process.\n * @property {number} duration_minutes - The duration of the poll in minutes.\n * @property {PollOption[]} options - An array of poll options.\n */\nexport interface PollData {\n  id?: string;\n  end_datetime?: string;\n  voting_status?: string;\n  duration_minutes: number;\n  options: PollOption[];\n}\n\n/**\n * Interface representing a poll option.\n * @typedef {Object} PollOption\n * @property {number} [position] - The position of the option.\n * @property {string} label - The label of the option.\n * @property {number} [votes] - The number of votes for the option.\n */\nexport interface PollOption {\n  position?: number;\n  label: string;\n  votes?: number;\n}\n\n/**\n * A parsed Tweet object.\n */\n/**\n * Represents a Tweet on Twitter.\n * @typedef { Object } Tweet\n * @property { number } [bookmarkCount] - The number of times this Tweet has been bookmarked.\n * @property { string } [conversationId] - The ID of the conversation this Tweet is a part of.\n * @property {string[]} hashtags - An array of hashtags mentioned in the Tweet.\n * @property { string } [html] - The HTML content of the Tweet.\n * @property { string } [id] - The unique ID of the Tweet.\n * @property { Tweet } [inReplyToStatus] - The Tweet that this Tweet is in reply to.\n * @property { string } [inReplyToStatusId] - The ID of the Tweet that this Tweet is in reply to.\n * @property { boolean } [isQuoted] - Indicates if this Tweet is a quote of another Tweet.\n * @property { boolean } [isPin] - Indicates if this Tweet is pinned.\n * @property { boolean } [isReply] - Indicates if this Tweet is a reply to another Tweet.\n * @property { boolean } [isRetweet] - Indicates if this Tweet is a retweet.\n * @property { boolean } [isSelfThread] - Indicates if this Tweet is part of a self thread.\n * @property { string } [language] - The language of the Tweet.\n * @property { number } [likes] - The number of likes on the Tweet.\n * @property { string } [name] - The name associated with the Tweet.\n * @property {Mention[]} mentions - An array of mentions in the Tweet.\n * @property { string } [permanentUrl] - The permanent URL of the Tweet.\n * @property {Photo[]} photos - An array of photos attached to the Tweet.\n * @property { PlaceRaw } [place] - The place associated with the Tweet.\n * @property { Tweet } [quotedStatus] - The quoted Tweet.\n * @property { string } [quotedStatusId] - The ID of the quoted Tweet.\n * @property { number } [quotes] - The number of times this Tweet has been quoted.\n * @property { number } [replies] - The number of replies to the Tweet.\n * @property { number } [retweets] - The number of retweets on the Tweet.\n * @property { Tweet } [retweetedStatus] - The status that was retweeted.\n * @property { string } [retweetedStatusId] - The ID of the retweeted status.\n * @property { string } [text] - The text content of the Tweet.\n * @property {Tweet[]} thread - An array representing a Twitter thread.\n * @property { Date } [timeParsed] - The parsed timestamp of the Tweet.\n * @property { number } [timestamp] - The timestamp of the Tweet.\n * @property {string[]} urls - An array of URLs mentioned in the Tweet.\n * @property { string } [userId] - The ID of the user who posted the Tweet.\n * @property { string } [username] - The username of the user who posted the Tweet.\n * @property {Video[]} videos - An array of videos attached to the Tweet.\n * @property { number } [views] - The number of views on the Tweet.\n * @property { boolean } [sensitiveContent] - Indicates if the Tweet contains sensitive content.\n * @property {PollV2 | null} [poll] - The poll attached to the Tweet, if any.\n */\nexport interface Tweet {\n  bookmarkCount?: number;\n  conversationId?: string;\n  hashtags: string[];\n  html?: string;\n  id?: string;\n  inReplyToStatus?: Tweet;\n  inReplyToStatusId?: string;\n  isQuoted?: boolean;\n  isPin?: boolean;\n  isReply?: boolean;\n  isRetweet?: boolean;\n  isSelfThread?: boolean;\n  language?: string;\n  likes?: number;\n  name?: string;\n  mentions: Mention[];\n  permanentUrl?: string;\n  photos: Photo[];\n  place?: PlaceRaw;\n  quotedStatus?: Tweet;\n  quotedStatusId?: string;\n  quotes?: number;\n  replies?: number;\n  retweets?: number;\n  retweetedStatus?: Tweet;\n  retweetedStatusId?: string;\n  text?: string;\n  thread: Tweet[];\n  timeParsed?: Date;\n  timestamp?: number;\n  urls: string[];\n  userId?: string;\n  username?: string;\n  videos: Video[];\n  views?: number;\n  sensitiveContent?: boolean;\n  poll?: PollV2 | null;\n}\n\nexport interface Retweeter {\n  rest_id: string;\n  screen_name: string;\n  name: string;\n  description?: string;\n}\n\nexport type TweetQuery = Partial<Tweet> | ((tweet: Tweet) => boolean | Promise<boolean>);\n\nexport const features = addApiFeatures({\n  interactive_text_enabled: true,\n  longform_notetweets_inline_media_enabled: false,\n  responsive_web_text_conversations_enabled: false,\n  tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: false,\n  vibe_api_enabled: false,\n});\n\nexport async function fetchTweets(\n  userId: string,\n  maxTweets: number,\n  cursor: string | undefined,\n  auth: TwitterAuth\n): Promise<QueryTweetsResponse> {\n  if (maxTweets > 200) {\n    maxTweets = 200;\n  }\n\n  const userTweetsRequest = apiRequestFactory.createUserTweetsRequest();\n  userTweetsRequest.variables.userId = userId;\n  userTweetsRequest.variables.count = maxTweets;\n  userTweetsRequest.variables.includePromotedContent = false; // true on the website\n\n  if (cursor != null && cursor !== '') {\n    userTweetsRequest.variables.cursor = cursor;\n  }\n\n  const res = await requestApi<TimelineV2>(userTweetsRequest.toRequestUrl(), auth);\n\n  if (!res.success) {\n    throw (res as any).err;\n  }\n\n  return parseTimelineTweetsV2(res.value);\n}\n\nexport async function fetchTweetsAndReplies(\n  userId: string,\n  maxTweets: number,\n  cursor: string | undefined,\n  auth: TwitterAuth\n): Promise<QueryTweetsResponse> {\n  if (maxTweets > 40) {\n    maxTweets = 40;\n  }\n\n  const userTweetsRequest = apiRequestFactory.createUserTweetsAndRepliesRequest();\n  userTweetsRequest.variables.userId = userId;\n  userTweetsRequest.variables.count = maxTweets;\n  userTweetsRequest.variables.includePromotedContent = false; // true on the website\n\n  if (cursor != null && cursor !== '') {\n    userTweetsRequest.variables.cursor = cursor;\n  }\n\n  const res = await requestApi<TimelineV2>(userTweetsRequest.toRequestUrl(), auth);\n\n  if (!res.success) {\n    throw (res as any).err;\n  }\n\n  return parseTimelineTweetsV2(res.value);\n}\n\nexport async function createCreateTweetRequestV2(\n  text: string,\n  auth: TwitterAuth,\n  tweetId?: string,\n  options?: {\n    poll?: PollData;\n  }\n) {\n  const v2client = auth.getV2Client();\n  if (v2client == null) {\n    throw new Error('V2 client is not initialized');\n  }\n  const { poll } = options || {};\n  let tweetConfig;\n  if (poll) {\n    tweetConfig = {\n      text,\n      poll: {\n        options: poll?.options.map((option) => option.label) ?? [],\n        duration_minutes: poll?.duration_minutes ?? 60,\n      },\n    };\n  } else if (tweetId) {\n    tweetConfig = {\n      text,\n      reply: {\n        in_reply_to_tweet_id: tweetId,\n      },\n    };\n  } else {\n    tweetConfig = {\n      text,\n    };\n  }\n  const tweetResponse = await v2client.v2.tweet(tweetConfig);\n  let optionsConfig = {};\n  if (options?.poll) {\n    optionsConfig = {\n      expansions: ['attachments.poll_ids'],\n      pollFields: ['options', 'duration_minutes', 'end_datetime', 'voting_status'],\n    };\n  }\n  return await getTweetV2(tweetResponse.data.id, auth, optionsConfig);\n}\n\nexport function parseTweetV2ToV1(\n  tweetV2: TweetV2,\n  includes?: ApiV2Includes,\n  defaultTweetData?: Tweet | null\n): Tweet {\n  let parsedTweet: Tweet;\n  if (defaultTweetData != null) {\n    parsedTweet = defaultTweetData;\n  }\n  parsedTweet = {\n    id: tweetV2.id,\n    text: tweetV2.text ?? defaultTweetData?.text ?? '',\n    hashtags: tweetV2.entities?.hashtags?.map((tag) => tag.tag) ?? defaultTweetData?.hashtags ?? [],\n    mentions:\n      tweetV2.entities?.mentions?.map((mention) => ({\n        id: mention.id,\n        username: mention.username,\n      })) ??\n      defaultTweetData?.mentions ??\n      [],\n    urls: tweetV2.entities?.urls?.map((url) => url.url) ?? defaultTweetData?.urls ?? [],\n    likes: tweetV2.public_metrics?.like_count ?? defaultTweetData?.likes ?? 0,\n    retweets: tweetV2.public_metrics?.retweet_count ?? defaultTweetData?.retweets ?? 0,\n    replies: tweetV2.public_metrics?.reply_count ?? defaultTweetData?.replies ?? 0,\n    views: tweetV2.public_metrics?.impression_count ?? defaultTweetData?.views ?? 0,\n    userId: tweetV2.author_id ?? defaultTweetData?.userId,\n    conversationId: tweetV2.conversation_id ?? defaultTweetData?.conversationId,\n    photos: defaultTweetData?.photos ?? [],\n    videos: defaultTweetData?.videos ?? [],\n    poll: defaultTweetData?.poll ?? null,\n    username: defaultTweetData?.username ?? '',\n    name: defaultTweetData?.name ?? '',\n    place: defaultTweetData?.place,\n    thread: defaultTweetData?.thread ?? [],\n  };\n\n  // Process Polls\n  if (includes?.polls?.length) {\n    const poll = includes.polls[0];\n    parsedTweet.poll = {\n      id: poll.id,\n      end_datetime: poll.end_datetime\n        ? poll.end_datetime\n        : defaultTweetData?.poll?.end_datetime\n          ? defaultTweetData?.poll?.end_datetime\n          : undefined,\n      options: poll.options.map((option) => ({\n        position: option.position,\n        label: option.label,\n        votes: option.votes,\n      })),\n      voting_status: poll.voting_status ?? defaultTweetData?.poll?.voting_status,\n    };\n  }\n\n  // Process Media (photos and videos)\n  if (includes?.media?.length) {\n    includes.media.forEach((media: MediaObjectV2) => {\n      if (media.type === 'photo') {\n        parsedTweet.photos.push({\n          id: media.media_key,\n          url: media.url ?? '',\n          alt_text: media.alt_text ?? '',\n        });\n      } else if (media.type === 'video' || media.type === 'animated_gif') {\n        parsedTweet.videos.push({\n          id: media.media_key,\n          preview: media.preview_image_url ?? '',\n          url: media.variants?.find((variant) => variant.content_type === 'video/mp4')?.url ?? '',\n        });\n      }\n    });\n  }\n\n  // Process User (for author info)\n  if (includes?.users?.length) {\n    const user = includes.users.find((user: UserV2) => user.id === tweetV2.author_id);\n    if (user) {\n      parsedTweet.username = user.username ?? defaultTweetData?.username ?? '';\n      parsedTweet.name = user.name ?? defaultTweetData?.name ?? '';\n    }\n  }\n\n  // Process Place (if any)\n  if (tweetV2?.geo?.place_id && includes?.places?.length) {\n    const place = includes.places.find((place: PlaceV2) => place.id === tweetV2?.geo?.place_id);\n    if (place) {\n      parsedTweet.place = {\n        id: place.id,\n        full_name: place.full_name ?? defaultTweetData?.place?.full_name ?? '',\n        country: place.country ?? defaultTweetData?.place?.country ?? '',\n        country_code: place.country_code ?? defaultTweetData?.place?.country_code ?? '',\n        name: place.name ?? defaultTweetData?.place?.name ?? '',\n        place_type: place.place_type ?? defaultTweetData?.place?.place_type,\n      };\n    }\n  }\n\n  // TODO: Process Thread (referenced tweets) and remove reference to v1\n  return parsedTweet;\n}\n\nexport async function createCreateTweetRequest(\n  text: string,\n  auth: TwitterAuth,\n  tweetId?: string,\n  mediaData?: { data: Buffer; mediaType: string }[],\n  hideLinkPreview = false\n) {\n  const onboardingTaskUrl = 'https://api.twitter.com/1.1/onboarding/task.json';\n\n  const cookies = await auth.cookieJar().getCookies(onboardingTaskUrl);\n  const xCsrfToken = cookies.find((cookie) => cookie.key === 'ct0');\n\n  //@ ts-expect-error - This is a private API.\n  const headers = new Headers({\n    authorization: `Bearer ${(auth as any).bearerToken}`,\n    cookie: await auth.cookieJar().getCookieString(onboardingTaskUrl),\n    'content-type': 'application/json',\n    'User-Agent':\n      'Mozilla/5.0 (Linux; Android 11; Nokia G20) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.88 Mobile Safari/537.36',\n    'x-guest-token': (auth as any).guestToken,\n    'x-twitter-auth-type': 'OAuth2Client',\n    'x-twitter-active-user': 'yes',\n    'x-twitter-client-language': 'en',\n    'x-csrf-token': xCsrfToken?.value as string,\n  });\n\n  const variables: Record<string, any> = {\n    tweet_text: text,\n    dark_request: false,\n    media: {\n      media_entities: [],\n      possibly_sensitive: false,\n    },\n    semantic_annotation_ids: [],\n  };\n\n  if (hideLinkPreview) {\n    variables.card_uri = 'tombstone://card';\n  }\n\n  if (mediaData && mediaData.length > 0) {\n    const mediaIds = await Promise.all(\n      mediaData.map(({ data, mediaType }) => uploadMedia(data, auth, mediaType))\n    );\n\n    variables.media.media_entities = mediaIds.map((id) => ({\n      media_id: id,\n      tagged_users: [],\n    }));\n  }\n\n  if (tweetId) {\n    variables.reply = { in_reply_to_tweet_id: tweetId };\n  }\n\n  const response = await fetch(\n    'https://twitter.com/i/api/graphql/a1p9RWpkYKBjWv_I3WzS-A/CreateTweet',\n    {\n      headers,\n      body: JSON.stringify({\n        variables,\n        features: {\n          interactive_text_enabled: true,\n          longform_notetweets_inline_media_enabled: false,\n          responsive_web_text_conversations_enabled: false,\n          tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: false,\n          vibe_api_enabled: false,\n          rweb_lists_timeline_redesign_enabled: true,\n          responsive_web_graphql_exclude_directive_enabled: true,\n          verified_phone_label_enabled: false,\n          creator_subscriptions_tweet_preview_api_enabled: true,\n          responsive_web_graphql_timeline_navigation_enabled: true,\n          responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,\n          tweetypie_unmention_optimization_enabled: true,\n          responsive_web_edit_tweet_api_enabled: true,\n          graphql_is_translatable_rweb_tweet_is_translatable_enabled: true,\n          view_counts_everywhere_api_enabled: true,\n          longform_notetweets_consumption_enabled: true,\n          tweet_awards_web_tipping_enabled: false,\n          freedom_of_speech_not_reach_fetch_enabled: true,\n          standardized_nudges_misinfo: true,\n          longform_notetweets_rich_text_read_enabled: true,\n          responsive_web_enhance_cards_enabled: false,\n          subscriptions_verification_info_enabled: true,\n          subscriptions_verification_info_reason_enabled: true,\n          subscriptions_verification_info_verified_since_enabled: true,\n          super_follow_badge_privacy_enabled: false,\n          super_follow_exclusive_tweet_notifications_enabled: false,\n          super_follow_tweet_api_enabled: false,\n          super_follow_user_api_enabled: false,\n          android_graphql_skip_api_media_color_palette: false,\n          creator_subscriptions_subscription_count_enabled: false,\n          blue_business_profile_image_shape_enabled: false,\n          unified_cards_ad_metadata_container_dynamic_card_content_query_enabled: false,\n          rweb_video_timestamps_enabled: false,\n          c9s_tweet_anatomy_moderator_badge_enabled: false,\n          responsive_web_twitter_article_tweet_consumption_enabled: false,\n        },\n        fieldToggles: {},\n      }),\n      method: 'POST',\n    }\n  );\n\n  await updateCookieJar(auth.cookieJar(), response.headers);\n\n  // check for errors\n  if (!response.ok) {\n    throw new Error(await response.text());\n  }\n\n  return response;\n}\n\nexport async function createCreateNoteTweetRequest(\n  text: string,\n  auth: TwitterAuth,\n  tweetId?: string,\n  mediaData?: { data: Buffer; mediaType: string }[]\n) {\n  const onboardingTaskUrl = 'https://api.twitter.com/1.1/onboarding/task.json';\n\n  const cookies = await auth.cookieJar().getCookies(onboardingTaskUrl);\n  const xCsrfToken = cookies.find((cookie) => cookie.key === 'ct0');\n\n  const headers = new Headers({\n    authorization: `Bearer ${(auth as any).bearerToken}`,\n    cookie: await auth.cookieJar().getCookieString(onboardingTaskUrl),\n    'content-type': 'application/json',\n    'User-Agent':\n      'Mozilla/5.0 (Linux; Android 11; Nokia G20) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.88 Mobile Safari/537.36',\n    'x-guest-token': (auth as any).guestToken,\n    'x-twitter-auth-type': 'OAuth2Client',\n    'x-twitter-active-user': 'yes',\n    'x-twitter-client-language': 'en',\n    'x-csrf-token': xCsrfToken?.value as string,\n  });\n\n  const variables: Record<string, any> = {\n    tweet_text: text,\n    dark_request: false,\n    media: {\n      media_entities: [],\n      possibly_sensitive: false,\n    },\n    semantic_annotation_ids: [],\n  };\n\n  if (mediaData && mediaData.length > 0) {\n    const mediaIds = await Promise.all(\n      mediaData.map(({ data, mediaType }) => uploadMedia(data, auth, mediaType))\n    );\n\n    variables.media.media_entities = mediaIds.map((id) => ({\n      media_id: id,\n      tagged_users: [],\n    }));\n  }\n\n  if (tweetId) {\n    variables.reply = { in_reply_to_tweet_id: tweetId };\n  }\n\n  const response = await fetch(\n    'https://twitter.com/i/api/graphql/0aWhJJmFlxkxv9TAUJPanA/CreateNoteTweet',\n    {\n      headers,\n      body: JSON.stringify({\n        variables,\n        features: {\n          interactive_text_enabled: true,\n          longform_notetweets_inline_media_enabled: false,\n          responsive_web_text_conversations_enabled: false,\n          tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: false,\n          vibe_api_enabled: false,\n          rweb_lists_timeline_redesign_enabled: true,\n          responsive_web_graphql_exclude_directive_enabled: true,\n          verified_phone_label_enabled: false,\n          creator_subscriptions_tweet_preview_api_enabled: true,\n          responsive_web_graphql_timeline_navigation_enabled: true,\n          responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,\n          tweetypie_unmention_optimization_enabled: true,\n          responsive_web_edit_tweet_api_enabled: true,\n          graphql_is_translatable_rweb_tweet_is_translatable_enabled: true,\n          view_counts_everywhere_api_enabled: true,\n          longform_notetweets_consumption_enabled: true,\n          longform_notetweets_creation_enabled: true,\n          tweet_awards_web_tipping_enabled: false,\n          freedom_of_speech_not_reach_fetch_enabled: true,\n          standardized_nudges_misinfo: true,\n          longform_notetweets_rich_text_read_enabled: true,\n          responsive_web_enhance_cards_enabled: false,\n          subscriptions_verification_info_enabled: true,\n          subscriptions_verification_info_reason_enabled: true,\n          subscriptions_verification_info_verified_since_enabled: true,\n          super_follow_badge_privacy_enabled: false,\n          super_follow_exclusive_tweet_notifications_enabled: false,\n          super_follow_tweet_api_enabled: false,\n          super_follow_user_api_enabled: false,\n          android_graphql_skip_api_media_color_palette: false,\n          creator_subscriptions_subscription_count_enabled: false,\n          blue_business_profile_image_shape_enabled: false,\n          unified_cards_ad_metadata_container_dynamic_card_content_query_enabled: false,\n          rweb_video_timestamps_enabled: false,\n          c9s_tweet_anatomy_moderator_badge_enabled: false,\n          responsive_web_twitter_article_tweet_consumption_enabled: false,\n\n          communities_web_enable_tweet_community_results_fetch: false,\n          articles_preview_enabled: false,\n          rweb_tipjar_consumption_enabled: false,\n          creator_subscriptions_quote_tweet_preview_enabled: false,\n        },\n        fieldToggles: {},\n      }),\n      method: 'POST',\n    }\n  );\n\n  await updateCookieJar(auth.cookieJar(), response.headers);\n\n  // Check for errors and log the error response\n  if (!response.ok) {\n    const errorText = await response.text();\n    console.error('Error response:', errorText);\n    throw new Error(`Failed to create long tweet: ${errorText}`);\n  }\n\n  // Parse and return the response\n  const data = await response.json();\n  return data;\n}\n\nexport async function fetchListTweets(\n  listId: string,\n  maxTweets: number,\n  cursor: string | undefined,\n  auth: TwitterAuth\n): Promise<QueryTweetsResponse> {\n  if (maxTweets > 200) {\n    maxTweets = 200;\n  }\n\n  const listTweetsRequest = apiRequestFactory.createListTweetsRequest();\n  listTweetsRequest.variables.listId = listId;\n  listTweetsRequest.variables.count = maxTweets;\n\n  if (cursor != null && cursor !== '') {\n    listTweetsRequest.variables.cursor = cursor;\n  }\n\n  const res = await requestApi<ListTimeline>(listTweetsRequest.toRequestUrl(), auth);\n\n  if (!res.success) {\n    throw (res as any).err;\n  }\n\n  return parseListTimelineTweets(res.value);\n}\n\nexport function getTweets(\n  user: string,\n  maxTweets: number,\n  auth: TwitterAuth\n): AsyncGenerator<Tweet, void> {\n  return getTweetTimeline(user, maxTweets, async (q, mt, c) => {\n    const userIdRes = await getEntityIdByScreenName(q, auth);\n\n    if (!userIdRes.success) {\n      throw (userIdRes as any).err;\n    }\n\n    const { value: userId } = userIdRes;\n\n    return fetchTweets(userId, mt, c, auth);\n  });\n}\n\nexport function getTweetsByUserId(\n  userId: string,\n  maxTweets: number,\n  auth: TwitterAuth\n): AsyncGenerator<Tweet, void> {\n  return getTweetTimeline(userId, maxTweets, (q, mt, c) => {\n    return fetchTweets(q, mt, c, auth);\n  });\n}\n\nexport function getTweetsAndReplies(\n  user: string,\n  maxTweets: number,\n  auth: TwitterAuth\n): AsyncGenerator<Tweet, void> {\n  return getTweetTimeline(user, maxTweets, async (q, mt, c) => {\n    const userIdRes = await getEntityIdByScreenName(q, auth);\n\n    if (!userIdRes.success) {\n      throw (userIdRes as any).err;\n    }\n\n    const { value: userId } = userIdRes;\n\n    return fetchTweetsAndReplies(userId, mt, c, auth);\n  });\n}\n\nexport function getTweetsAndRepliesByUserId(\n  userId: string,\n  maxTweets: number,\n  auth: TwitterAuth\n): AsyncGenerator<Tweet, void> {\n  return getTweetTimeline(userId, maxTweets, (q, mt, c) => {\n    return fetchTweetsAndReplies(q, mt, c, auth);\n  });\n}\n\nexport async function fetchLikedTweets(\n  userId: string,\n  maxTweets: number,\n  cursor: string | undefined,\n  auth: TwitterAuth\n): Promise<QueryTweetsResponse> {\n  if (!auth.isLoggedIn()) {\n    throw new Error('Client is not logged-in for fetching liked tweets.');\n  }\n\n  if (maxTweets > 200) {\n    maxTweets = 200;\n  }\n\n  const userTweetsRequest = apiRequestFactory.createUserLikedTweetsRequest();\n  userTweetsRequest.variables.userId = userId;\n  userTweetsRequest.variables.count = maxTweets;\n  userTweetsRequest.variables.includePromotedContent = false; // true on the website\n\n  if (cursor != null && cursor !== '') {\n    userTweetsRequest.variables.cursor = cursor;\n  }\n\n  const res = await requestApi<TimelineV2>(userTweetsRequest.toRequestUrl(), auth);\n\n  if (!res.success) {\n    throw (res as any).err;\n  }\n\n  return parseTimelineTweetsV2(res.value);\n}\n\nexport async function getTweetWhere(\n  tweets: AsyncIterable<Tweet>,\n  query: TweetQuery\n): Promise<Tweet | null> {\n  const isCallback = typeof query === 'function';\n\n  for await (const tweet of tweets) {\n    const matches = isCallback ? await query(tweet) : checkTweetMatches(tweet, query);\n\n    if (matches) {\n      return tweet;\n    }\n  }\n\n  return null;\n}\n\nexport async function getTweetsWhere(\n  tweets: AsyncIterable<Tweet>,\n  query: TweetQuery\n): Promise<Tweet[]> {\n  const isCallback = typeof query === 'function';\n  const filtered = [];\n\n  for await (const tweet of tweets) {\n    const matches = isCallback ? query(tweet) : checkTweetMatches(tweet, query);\n\n    if (!matches) continue;\n    filtered.push(tweet);\n  }\n\n  return filtered;\n}\n\nfunction checkTweetMatches(tweet: Tweet, options: Partial<Tweet>): boolean {\n  return Object.keys(options).every((k) => {\n    const key = k as keyof Tweet;\n    return tweet[key] === options[key];\n  });\n}\n\nexport async function getLatestTweet(\n  user: string,\n  includeRetweets: boolean,\n  max: number,\n  auth: TwitterAuth\n): Promise<Tweet | null | undefined> {\n  const timeline = getTweets(user, max, auth);\n\n  // No point looping if max is 1, just use first entry.\n  return max === 1\n    ? ((await timeline.next()).value as Tweet)\n    : await getTweetWhere(timeline, { isRetweet: includeRetweets });\n}\n\nexport interface TweetResultByRestId {\n  data?: TimelineEntryItemContentRaw;\n}\n\nexport async function getTweet(id: string, auth: TwitterAuth): Promise<Tweet | null> {\n  const tweetDetailRequest = apiRequestFactory.createTweetDetailRequest();\n  tweetDetailRequest.variables.focalTweetId = id;\n\n  const res = await requestApi<ThreadedConversation>(tweetDetailRequest.toRequestUrl(), auth);\n\n  if (!res.success) {\n    throw (res as any).err;\n  }\n\n  if (!res.value) {\n    return null;\n  }\n\n  const tweets = parseThreadedConversation(res.value);\n  return tweets.find((tweet) => tweet.id === id) ?? null;\n}\n\nexport async function getTweetV2(\n  id: string,\n  auth: TwitterAuth,\n  options: {\n    expansions?: TTweetv2Expansion[];\n    tweetFields?: TTweetv2TweetField[];\n    pollFields?: TTweetv2PollField[];\n    mediaFields?: TTweetv2MediaField[];\n    userFields?: TTweetv2UserField[];\n    placeFields?: TTweetv2PlaceField[];\n  } = defaultOptions\n): Promise<Tweet | null> {\n  const v2client = auth.getV2Client();\n  if (!v2client) {\n    throw new Error('V2 client is not initialized');\n  }\n\n  try {\n    const tweetData = await v2client.v2.singleTweet(id, {\n      expansions: options?.expansions,\n      'tweet.fields': options?.tweetFields,\n      'poll.fields': options?.pollFields,\n      'media.fields': options?.mediaFields,\n      'user.fields': options?.userFields,\n      'place.fields': options?.placeFields,\n    });\n\n    if (!tweetData?.data) {\n      console.warn(`Tweet data not found for ID: ${id}`);\n      return null;\n    }\n\n    const defaultTweetData = await getTweet(tweetData.data.id, auth);\n    // Extract primary tweet data\n    const parsedTweet = parseTweetV2ToV1(tweetData.data, tweetData?.includes, defaultTweetData);\n\n    return parsedTweet;\n  } catch (error) {\n    console.error(`Error fetching tweet ${id}:`, error);\n    return null;\n  }\n}\n\nexport async function getTweetsV2(\n  ids: string[],\n  auth: TwitterAuth,\n  options: {\n    expansions?: TTweetv2Expansion[];\n    tweetFields?: TTweetv2TweetField[];\n    pollFields?: TTweetv2PollField[];\n    mediaFields?: TTweetv2MediaField[];\n    userFields?: TTweetv2UserField[];\n    placeFields?: TTweetv2PlaceField[];\n  } = defaultOptions\n): Promise<Tweet[]> {\n  const v2client = auth.getV2Client();\n  if (!v2client) {\n    return [];\n  }\n\n  try {\n    const tweetData = await v2client.v2.tweets(ids, {\n      expansions: options?.expansions,\n      'tweet.fields': options?.tweetFields,\n      'poll.fields': options?.pollFields,\n      'media.fields': options?.mediaFields,\n      'user.fields': options?.userFields,\n      'place.fields': options?.placeFields,\n    });\n    const tweetsV2 = tweetData.data;\n    if (tweetsV2.length === 0) {\n      console.warn(`No tweet data found for IDs: ${ids.join(', ')}`);\n      return [];\n    }\n    return (\n      await Promise.all(tweetsV2.map(async (tweet) => await getTweetV2(tweet.id, auth, options)))\n    ).filter((tweet): tweet is Tweet => tweet !== null);\n  } catch (error) {\n    console.error(`Error fetching tweets for IDs: ${ids.join(', ')}`, error);\n    return [];\n  }\n}\n\nexport async function getTweetAnonymous(id: string, auth: TwitterAuth): Promise<Tweet | null> {\n  const tweetResultByRestIdRequest = apiRequestFactory.createTweetResultByRestIdRequest();\n  tweetResultByRestIdRequest.variables.tweetId = id;\n\n  const res = await requestApi<TweetResultByRestId>(\n    tweetResultByRestIdRequest.toRequestUrl(),\n    auth\n  );\n\n  if (!res.success) {\n    throw (res as any).err;\n  }\n\n  if (!res.value.data) {\n    return null;\n  }\n\n  return parseTimelineEntryItemContentRaw(res.value.data, id);\n}\n\ninterface MediaUploadResponse {\n  media_id_string: string;\n  size: number;\n  expires_after_secs: number;\n  image: {\n    image_type: string;\n    w: number;\n    h: number;\n  };\n}\n\nasync function uploadMedia(\n  mediaData: Buffer,\n  auth: TwitterAuth,\n  mediaType: string\n): Promise<string> {\n  const uploadUrl = 'https://upload.twitter.com/1.1/media/upload.json';\n\n  // Get authentication headers\n  const cookies = await auth.cookieJar().getCookies(uploadUrl);\n  const xCsrfToken = cookies.find((cookie) => cookie.key === 'ct0');\n  const headers = new Headers({\n    authorization: `Bearer ${(auth as any).bearerToken}`,\n    cookie: await auth.cookieJar().getCookieString(uploadUrl),\n    'x-csrf-token': xCsrfToken?.value as string,\n  });\n\n  // Detect if media is a video based on mediaType\n  const isVideo = mediaType.startsWith('video/');\n\n  if (isVideo) {\n    // Handle video upload using chunked media upload\n    const mediaId = await uploadVideoInChunks(mediaData, mediaType);\n    return mediaId;\n  }\n  // Handle image upload\n  const form = new FormData();\n  form.append('media', new Blob([mediaData]));\n\n  const response = await fetch(uploadUrl, {\n    method: 'POST',\n    headers,\n    body: form,\n  });\n\n  await updateCookieJar(auth.cookieJar(), response.headers);\n\n  if (!response.ok) {\n    throw new Error(await response.text());\n  }\n\n  const data: MediaUploadResponse = await response.json();\n  return data.media_id_string;\n\n  // Function to upload video in chunks\n  async function uploadVideoInChunks(mediaData: Buffer, mediaType: string): Promise<string> {\n    // Initialize upload\n    const initParams = new URLSearchParams();\n    initParams.append('command', 'INIT');\n    initParams.append('media_type', mediaType);\n    initParams.append('total_bytes', mediaData.length.toString());\n\n    const initResponse = await fetch(uploadUrl, {\n      method: 'POST',\n      headers,\n      body: initParams,\n    });\n\n    if (!initResponse.ok) {\n      throw new Error(await initResponse.text());\n    }\n\n    const initData = await initResponse.json();\n    const mediaId = initData.media_id_string;\n\n    // Append upload in chunks\n    const segmentSize = 5 * 1024 * 1024; // 5 MB per chunk\n    let segmentIndex = 0;\n    for (let offset = 0; offset < mediaData.length; offset += segmentSize) {\n      const chunk = mediaData.slice(offset, offset + segmentSize);\n\n      const appendForm = new FormData();\n      appendForm.append('command', 'APPEND');\n      appendForm.append('media_id', mediaId);\n      appendForm.append('segment_index', segmentIndex.toString());\n      appendForm.append('media', new Blob([chunk]));\n\n      const appendResponse = await fetch(uploadUrl, {\n        method: 'POST',\n        headers,\n        body: appendForm,\n      });\n\n      if (!appendResponse.ok) {\n        throw new Error(await appendResponse.text());\n      }\n\n      segmentIndex++;\n    }\n\n    // Finalize upload\n    const finalizeParams = new URLSearchParams();\n    finalizeParams.append('command', 'FINALIZE');\n    finalizeParams.append('media_id', mediaId);\n\n    const finalizeResponse = await fetch(uploadUrl, {\n      method: 'POST',\n      headers,\n      body: finalizeParams,\n    });\n\n    if (!finalizeResponse.ok) {\n      throw new Error(await finalizeResponse.text());\n    }\n\n    const finalizeData = await finalizeResponse.json();\n\n    // Check processing status for videos\n    if (finalizeData.processing_info) {\n      await checkUploadStatus(mediaId);\n    }\n\n    return mediaId;\n  }\n\n  // Function to check upload status\n  async function checkUploadStatus(mediaId: string): Promise<void> {\n    let processing = true;\n    while (processing) {\n      await new Promise((resolve) => setTimeout(resolve, 5000)); // Wait 5 seconds\n\n      const statusParams = new URLSearchParams();\n      statusParams.append('command', 'STATUS');\n      statusParams.append('media_id', mediaId);\n\n      const statusResponse = await fetch(`${uploadUrl}?${statusParams.toString()}`, {\n        method: 'GET',\n        headers,\n      });\n\n      if (!statusResponse.ok) {\n        throw new Error(await statusResponse.text());\n      }\n\n      const statusData = await statusResponse.json();\n      const state = statusData.processing_info.state;\n\n      if (state === 'succeeded') {\n        processing = false;\n      } else if (state === 'failed') {\n        throw new Error('Video processing failed');\n      }\n    }\n  }\n}\n\n// Function to create a quote tweet\nexport async function createQuoteTweetRequest(\n  text: string,\n  quotedTweetId: string,\n  auth: TwitterAuth,\n  mediaData?: { data: Buffer; mediaType: string }[]\n) {\n  const onboardingTaskUrl = 'https://api.twitter.com/1.1/onboarding/task.json';\n\n  // Retrieve necessary cookies and tokens\n  const cookies = await auth.cookieJar().getCookies(onboardingTaskUrl);\n  const xCsrfToken = cookies.find((cookie) => cookie.key === 'ct0');\n\n  const headers = new Headers({\n    authorization: `Bearer ${(auth as any).bearerToken}`,\n    cookie: await auth.cookieJar().getCookieString(onboardingTaskUrl),\n    'content-type': 'application/json',\n    'User-Agent':\n      'Mozilla/5.0 (Linux; Android 11; Nokia G20) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.88 Mobile Safari/537.36',\n    'x-guest-token': (auth as any).guestToken,\n    'x-twitter-auth-type': 'OAuth2Client',\n    'x-twitter-active-user': 'yes',\n    'x-csrf-token': xCsrfToken?.value as string,\n  });\n\n  // Construct variables for the GraphQL request\n  const variables: Record<string, any> = {\n    tweet_text: text,\n    dark_request: false,\n    attachment_url: `https://twitter.com/twitter/status/${quotedTweetId}`,\n    media: {\n      media_entities: [],\n      possibly_sensitive: false,\n    },\n    semantic_annotation_ids: [],\n  };\n\n  // Handle media uploads if any media data is provided\n  if (mediaData && mediaData.length > 0) {\n    const mediaIds = await Promise.all(\n      mediaData.map(({ data, mediaType }) => uploadMedia(data, auth, mediaType))\n    );\n\n    variables.media.media_entities = mediaIds.map((id) => ({\n      media_id: id,\n      tagged_users: [],\n    }));\n  }\n\n  // Send the GraphQL request to create a quote tweet\n  const response = await fetch(\n    'https://twitter.com/i/api/graphql/a1p9RWpkYKBjWv_I3WzS-A/CreateTweet',\n    {\n      headers,\n      body: JSON.stringify({\n        variables,\n        features: {\n          interactive_text_enabled: true,\n          longform_notetweets_inline_media_enabled: false,\n          responsive_web_text_conversations_enabled: false,\n          tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: false,\n          vibe_api_enabled: false,\n          rweb_lists_timeline_redesign_enabled: true,\n          responsive_web_graphql_exclude_directive_enabled: true,\n          verified_phone_label_enabled: false,\n          creator_subscriptions_tweet_preview_api_enabled: true,\n          responsive_web_graphql_timeline_navigation_enabled: true,\n          responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,\n          tweetypie_unmention_optimization_enabled: true,\n          responsive_web_edit_tweet_api_enabled: true,\n          graphql_is_translatable_rweb_tweet_is_translatable_enabled: true,\n          view_counts_everywhere_api_enabled: true,\n          longform_notetweets_consumption_enabled: true,\n          tweet_awards_web_tipping_enabled: false,\n          freedom_of_speech_not_reach_fetch_enabled: true,\n          standardized_nudges_misinfo: true,\n          longform_notetweets_rich_text_read_enabled: true,\n          responsive_web_enhance_cards_enabled: false,\n          subscriptions_verification_info_enabled: true,\n          subscriptions_verification_info_reason_enabled: true,\n          subscriptions_verification_info_verified_since_enabled: true,\n          super_follow_badge_privacy_enabled: false,\n          super_follow_exclusive_tweet_notifications_enabled: false,\n          super_follow_tweet_api_enabled: false,\n          super_follow_user_api_enabled: false,\n          android_graphql_skip_api_media_color_palette: false,\n          creator_subscriptions_subscription_count_enabled: false,\n          blue_business_profile_image_shape_enabled: false,\n          unified_cards_ad_metadata_container_dynamic_card_content_query_enabled: false,\n          rweb_video_timestamps_enabled: true,\n          c9s_tweet_anatomy_moderator_badge_enabled: true,\n          responsive_web_twitter_article_tweet_consumption_enabled: false,\n        },\n        fieldToggles: {},\n      }),\n      method: 'POST',\n    }\n  );\n\n  // Update the cookie jar with any new cookies from the response\n  await updateCookieJar(auth.cookieJar(), response.headers);\n\n  // Check for errors in the response\n  if (!response.ok) {\n    throw new Error(await response.text());\n  }\n\n  return response;\n}\n\n/**\n * Likes a tweet with the given tweet ID.\n * @param tweetId The ID of the tweet to like.\n * @param auth The authentication object.\n * @returns A promise that resolves when the tweet is liked.\n */\nexport async function likeTweet(tweetId: string, auth: TwitterAuth): Promise<void> {\n  // Prepare the GraphQL endpoint and payload\n  const likeTweetUrl = 'https://twitter.com/i/api/graphql/lI07N6Otwv1PhnEgXILM7A/FavoriteTweet';\n\n  // Retrieve necessary cookies and tokens\n  const cookies = await auth.cookieJar().getCookies(likeTweetUrl);\n  const xCsrfToken = cookies.find((cookie) => cookie.key === 'ct0');\n\n  const headers = new Headers({\n    authorization: `Bearer ${(auth as any).bearerToken}`,\n    cookie: await auth.cookieJar().getCookieString(likeTweetUrl),\n    'content-type': 'application/json',\n    'x-guest-token': (auth as any).guestToken,\n    'x-twitter-auth-type': 'OAuth2Client',\n    'x-twitter-active-user': 'yes',\n    'x-csrf-token': xCsrfToken?.value as string,\n  });\n\n  const payload = {\n    variables: {\n      tweet_id: tweetId,\n    },\n  };\n\n  // Send the POST request to like the tweet\n  const response = await fetch(likeTweetUrl, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(payload),\n  });\n\n  // Update the cookie jar with any new cookies from the response\n  await updateCookieJar(auth.cookieJar(), response.headers);\n\n  // Check for errors in the response\n  if (!response.ok) {\n    throw new Error(await response.text());\n  }\n}\n\n/**\n * Retweets a tweet with the given tweet ID.\n * @param tweetId The ID of the tweet to retweet.\n * @param auth The authentication object.\n * @returns A promise that resolves when the tweet is retweeted.\n */\nexport async function retweet(tweetId: string, auth: TwitterAuth): Promise<void> {\n  // Prepare the GraphQL endpoint and payload\n  const retweetUrl = 'https://twitter.com/i/api/graphql/ojPdsZsimiJrUGLR1sjUtA/CreateRetweet';\n\n  // Retrieve necessary cookies and tokens\n  const cookies = await auth.cookieJar().getCookies(retweetUrl);\n  const xCsrfToken = cookies.find((cookie) => cookie.key === 'ct0');\n\n  const headers = new Headers({\n    authorization: `Bearer ${(auth as any).bearerToken}`,\n    cookie: await auth.cookieJar().getCookieString(retweetUrl),\n    'content-type': 'application/json',\n    'x-guest-token': (auth as any).guestToken,\n    'x-twitter-auth-type': 'OAuth2Client',\n    'x-twitter-active-user': 'yes',\n    'x-csrf-token': xCsrfToken?.value as string,\n  });\n\n  const payload = {\n    variables: {\n      tweet_id: tweetId,\n      dark_request: false,\n    },\n  };\n\n  // Send the POST request to retweet the tweet\n  const response = await fetch(retweetUrl, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(payload),\n  });\n\n  // Update the cookie jar with any new cookies from the response\n  await updateCookieJar(auth.cookieJar(), response.headers);\n\n  // Check for errors in the response\n  if (!response.ok) {\n    throw new Error(await response.text());\n  }\n}\n\nexport async function createCreateLongTweetRequest(\n  text: string,\n  auth: TwitterAuth,\n  tweetId?: string,\n  mediaData?: { data: Buffer; mediaType: string }[]\n) {\n  // URL for the long tweet endpoint\n  const url = 'https://x.com/i/api/graphql/YNXM2DGuE2Sff6a2JD3Ztw/CreateNoteTweet';\n  const onboardingTaskUrl = 'https://api.twitter.com/1.1/onboarding/task.json';\n\n  const cookies = await auth.cookieJar().getCookies(onboardingTaskUrl);\n  const xCsrfToken = cookies.find((cookie) => cookie.key === 'ct0');\n\n  //@ ts-expect-error - This is a private API.\n  const headers = new Headers({\n    authorization: `Bearer ${(auth as any).bearerToken}`,\n    cookie: await auth.cookieJar().getCookieString(onboardingTaskUrl),\n    'content-type': 'application/json',\n    'User-Agent':\n      'Mozilla/5.0 (Linux; Android 11; Nokia G20) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.88 Mobile Safari/537.36',\n    'x-guest-token': (auth as any).guestToken,\n    'x-twitter-auth-type': 'OAuth2Client',\n    'x-twitter-active-user': 'yes',\n    'x-twitter-client-language': 'en',\n    'x-csrf-token': xCsrfToken?.value as string,\n  });\n\n  const variables: Record<string, any> = {\n    tweet_text: text,\n    dark_request: false,\n    media: {\n      media_entities: [],\n      possibly_sensitive: false,\n    },\n    semantic_annotation_ids: [],\n  };\n\n  if (mediaData && mediaData.length > 0) {\n    const mediaIds = await Promise.all(\n      mediaData.map(({ data, mediaType }) => uploadMedia(data, auth, mediaType))\n    );\n\n    variables.media.media_entities = mediaIds.map((id) => ({\n      media_id: id,\n      tagged_users: [],\n    }));\n  }\n\n  if (tweetId) {\n    variables.reply = { in_reply_to_tweet_id: tweetId };\n  }\n\n  const features = {\n    premium_content_api_read_enabled: false,\n    communities_web_enable_tweet_community_results_fetch: true,\n    c9s_tweet_anatomy_moderator_badge_enabled: true,\n    responsive_web_grok_analyze_button_fetch_trends_enabled: true,\n    responsive_web_edit_tweet_api_enabled: true,\n    graphql_is_translatable_rweb_tweet_is_translatable_enabled: true,\n    view_counts_everywhere_api_enabled: true,\n    longform_notetweets_consumption_enabled: true,\n    responsive_web_twitter_article_tweet_consumption_enabled: true,\n    tweet_awards_web_tipping_enabled: false,\n    creator_subscriptions_quote_tweet_preview_enabled: false,\n    longform_notetweets_rich_text_read_enabled: true,\n    longform_notetweets_inline_media_enabled: true,\n    profile_label_improvements_pcf_label_in_post_enabled: false,\n    rweb_tipjar_consumption_enabled: true,\n    responsive_web_graphql_exclude_directive_enabled: true,\n    verified_phone_label_enabled: false,\n    articles_preview_enabled: true,\n    rweb_video_timestamps_enabled: true,\n    responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,\n    freedom_of_speech_not_reach_fetch_enabled: true,\n    standardized_nudges_misinfo: true,\n    tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: true,\n    responsive_web_graphql_timeline_navigation_enabled: true,\n    responsive_web_enhance_cards_enabled: false,\n  };\n\n  const response = await fetch(url, {\n    headers,\n    body: JSON.stringify({\n      variables,\n      features,\n      queryId: 'YNXM2DGuE2Sff6a2JD3Ztw',\n    }),\n    method: 'POST',\n  });\n\n  await updateCookieJar(auth.cookieJar(), response.headers);\n\n  // check for errors\n  if (!response.ok) {\n    throw new Error(await response.text());\n  }\n\n  return response;\n}\n\nexport async function getArticle(id: string, auth: TwitterAuth): Promise<TimelineArticle | null> {\n  const tweetDetailRequest = apiRequestFactory.createTweetDetailArticleRequest();\n  tweetDetailRequest.variables.focalTweetId = id;\n\n  const res = await requestApi<ThreadedConversation>(tweetDetailRequest.toRequestUrl(), auth);\n\n  if (!res.success) {\n    throw (res as any).err;\n  }\n\n  if (!res.value) {\n    return null;\n  }\n\n  const articles = parseArticle(res.value);\n  return articles.find((article) => article.id === id) ?? null;\n}\n\n/**\n * Fetches a single page of retweeters for a given tweet, collecting both bottom and top cursors.\n * Logs each user's description in the process.\n * All comments must remain in English.\n */\nexport async function fetchRetweetersPage(\n  tweetId: string,\n  auth: TwitterAuth,\n  cursor?: string,\n  count = 40\n): Promise<{\n  retweeters: Retweeter[];\n  bottomCursor?: string;\n  topCursor?: string;\n}> {\n  const baseUrl = 'https://twitter.com/i/api/graphql/VSnHXwLGADxxtetlPnO7xg/Retweeters';\n\n  // Build query parameters\n  const variables = {\n    tweetId,\n    count,\n    cursor,\n    includePromotedContent: true,\n  };\n  const features = {\n    profile_label_improvements_pcf_label_in_post_enabled: true,\n    rweb_tipjar_consumption_enabled: true,\n    responsive_web_graphql_exclude_directive_enabled: true,\n    verified_phone_label_enabled: false,\n    creator_subscriptions_tweet_preview_api_enabled: true,\n    responsive_web_graphql_timeline_navigation_enabled: true,\n    responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,\n    premium_content_api_read_enabled: false,\n    communities_web_enable_tweet_community_results_fetch: true,\n    c9s_tweet_anatomy_moderator_badge_enabled: true,\n    responsive_web_grok_analyze_button_fetch_trends_enabled: false,\n    responsive_web_grok_analyze_post_followups_enabled: true,\n    responsive_web_jetfuel_frame: false,\n    responsive_web_grok_share_attachment_enabled: true,\n    articles_preview_enabled: true,\n    responsive_web_edit_tweet_api_enabled: true,\n    graphql_is_translatable_rweb_tweet_is_translatable_enabled: true,\n    view_counts_everywhere_api_enabled: true,\n    longform_notetweets_consumption_enabled: true,\n    responsive_web_twitter_article_tweet_consumption_enabled: true,\n    tweet_awards_web_tipping_enabled: false,\n    creator_subscriptions_quote_tweet_preview_enabled: false,\n    freedom_of_speech_not_reach_fetch_enabled: true,\n    standardized_nudges_misinfo: true,\n    tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: true,\n    rweb_video_timestamps_enabled: true,\n    longform_notetweets_rich_text_read_enabled: true,\n    longform_notetweets_inline_media_enabled: true,\n    responsive_web_grok_image_annotation_enabled: false,\n    responsive_web_enhance_cards_enabled: false,\n  };\n\n  // Prepare URL with query params\n  const url = new URL(baseUrl);\n  url.searchParams.set('variables', JSON.stringify(variables));\n  url.searchParams.set('features', JSON.stringify(features));\n\n  // Retrieve necessary cookies and tokens\n  const cookies = await auth.cookieJar().getCookies(url.toString());\n  const xCsrfToken = cookies.find((cookie) => cookie.key === 'ct0');\n\n  const headers = new Headers({\n    authorization: `Bearer ${(auth as any).bearerToken}`,\n    cookie: await auth.cookieJar().getCookieString(url.toString()),\n    'content-type': 'application/json',\n    'x-guest-token': (auth as any).guestToken,\n    'x-twitter-auth-type': 'OAuth2Client',\n    'x-twitter-active-user': 'yes',\n    'x-csrf-token': xCsrfToken?.value || '',\n  });\n\n  const response = await fetch(url.toString(), {\n    method: 'GET',\n    headers,\n  });\n\n  // Update cookies if needed\n  await updateCookieJar(auth.cookieJar(), response.headers);\n\n  if (!response.ok) {\n    throw new Error(await response.text());\n  }\n\n  const json = await response.json();\n  const instructions = json?.data?.retweeters_timeline?.timeline?.instructions || [];\n\n  const retweeters: Retweeter[] = [];\n  let bottomCursor: string | undefined;\n  let topCursor: string | undefined;\n\n  // Parse the retweeters from instructions\n  for (const instruction of instructions) {\n    if (instruction.type === 'TimelineAddEntries') {\n      for (const entry of instruction.entries) {\n        // If this entry is a user entry\n        if (entry.content?.itemContent?.user_results?.result) {\n          const user = entry.content.itemContent.user_results.result;\n          const description = user.legacy?.name ?? '';\n\n          retweeters.push({\n            rest_id: user.rest_id,\n            screen_name: user.legacy?.screen_name ?? '',\n            name: user.legacy?.name ?? '',\n            description,\n          });\n        }\n\n        // Capture the bottom cursor\n        if (\n          entry.content?.entryType === 'TimelineTimelineCursor' &&\n          entry.content?.cursorType === 'Bottom'\n        ) {\n          bottomCursor = entry.content.value;\n        }\n\n        // Capture the top cursor\n        if (\n          entry.content?.entryType === 'TimelineTimelineCursor' &&\n          entry.content?.cursorType === 'Top'\n        ) {\n          topCursor = entry.content.value;\n        }\n      }\n    }\n  }\n\n  return { retweeters, bottomCursor, topCursor };\n}\n\n/**\n * Retrieves *all* retweeters by chaining requests until no next cursor is found.\n * @param tweetId The ID of the tweet.\n * @param auth The TwitterAuth object for authentication.\n * @returns A list of all users that retweeted the tweet.\n */\nexport async function getAllRetweeters(tweetId: string, auth: TwitterAuth): Promise<Retweeter[]> {\n  let allRetweeters: Retweeter[] = [];\n  let cursor: string | undefined;\n\n  while (true) {\n    // Destructure bottomCursor / topCursor\n    const { retweeters, bottomCursor, topCursor } = await fetchRetweetersPage(\n      tweetId,\n      auth,\n      cursor,\n      40\n    );\n    allRetweeters = allRetweeters.concat(retweeters);\n\n    const newCursor = bottomCursor || topCursor;\n\n    // Stop if there is no new cursor or if it's the same as the old one\n    if (!newCursor || newCursor === cursor) {\n      break;\n    }\n\n    cursor = newCursor;\n  }\n\n  return allRetweeters;\n}\n","import type { Cookie } from 'tough-cookie';\nimport type {\n  TTweetv2Expansion,\n  TTweetv2MediaField,\n  TTweetv2PlaceField,\n  TTweetv2PollField,\n  TTweetv2TweetField,\n  TTweetv2UserField,\n} from 'twitter-api-v2';\nimport { type FetchTransformOptions, type RequestApiResult, bearerToken, requestApi } from './api';\nimport { type TwitterAuth, type TwitterAuthOptions, TwitterGuestAuth } from './auth';\nimport { TwitterUserAuth } from './auth-user';\nimport {\n  type GrokChatOptions,\n  type GrokChatResponse,\n  createGrokConversation,\n  grokChat,\n} from './grok';\nimport {\n  type DirectMessagesResponse,\n  type SendDirectMessageResponse,\n  getDirectMessageConversations,\n  sendDirectMessage,\n} from './messages';\nimport {\n  type Profile,\n  getEntityIdByScreenName,\n  getProfile,\n  getScreenNameByUserId,\n} from './profile';\nimport {\n  fetchProfileFollowers,\n  fetchProfileFollowing,\n  followUser,\n  getFollowers,\n  getFollowing,\n} from './relationships';\nimport {\n  SearchMode,\n  fetchQuotedTweetsPage,\n  fetchSearchProfiles,\n  fetchSearchTweets,\n  searchProfiles,\n  searchQuotedTweets,\n  searchTweets,\n} from './search';\nimport {\n  fetchAudioSpaceById,\n  fetchAuthenticatePeriscope,\n  fetchBrowseSpaceTopics,\n  fetchCommunitySelectQuery,\n  fetchLiveVideoStreamStatus,\n  fetchLoginTwitterToken,\n} from './spaces';\nimport { fetchFollowingTimeline } from './timeline-following';\nimport { fetchHomeTimeline } from './timeline-home';\nimport type { QueryProfilesResponse, QueryTweetsResponse } from './timeline-v1';\nimport { type TimelineArticle, type TimelineV2, parseTimelineTweetsV2 } from './timeline-v2';\nimport { getTrends } from './trends';\nimport {\n  type PollData,\n  type Retweeter,\n  type Tweet,\n  type TweetQuery,\n  createCreateLongTweetRequest,\n  createCreateNoteTweetRequest,\n  createCreateTweetRequest,\n  createCreateTweetRequestV2,\n  createQuoteTweetRequest,\n  defaultOptions,\n  fetchListTweets,\n  getAllRetweeters,\n  getArticle,\n  getLatestTweet,\n  getTweet,\n  getTweetAnonymous,\n  getTweetV2,\n  getTweetWhere,\n  getTweets,\n  getTweetsAndReplies,\n  getTweetsAndRepliesByUserId,\n  getTweetsByUserId,\n  getTweetsV2,\n  getTweetsWhere,\n  likeTweet,\n  retweet,\n} from './tweets';\nimport type {\n  AudioSpace,\n  Community,\n  LiveVideoStreamStatus,\n  LoginTwitterTokenResponse,\n  Subtopic,\n} from './types/spaces';\n\nconst twUrl = 'https://twitter.com';\nconst UserTweetsUrl = 'https://twitter.com/i/api/graphql/E3opETHurmVJflFsUBVuUQ/UserTweets';\n\n/**\n * An alternative fetch function to use instead of the default fetch function. This may be useful\n * in nonstandard runtime environments, such as edge workers.\n *\n * @param {typeof fetch} fetch - The fetch function to use.\n *\n * @param {Partial<FetchTransformOptions>} transform - Additional options that control how requests\n * and responses are processed. This can be used to proxy requests through other hosts, for example.\n */\nexport interface ClientOptions {\n  /**\n   * An alternative fetch function to use instead of the default fetch function. This may be useful\n   * in nonstandard runtime environments, such as edge workers.\n   */\n  fetch: typeof fetch;\n\n  /**\n   * Additional options that control how requests and responses are processed. This can be used to\n   * proxy requests through other hosts, for example.\n   */\n  transform: Partial<FetchTransformOptions>;\n}\n\n/**\n * An interface to Twitter's undocumented API.\n * - Reusing Client objects is recommended to minimize the time spent authenticating unnecessarily.\n */\nexport class Client {\n  private auth!: TwitterAuth;\n  private authTrends!: TwitterAuth;\n  private token: string;\n\n  /**\n   * Creates a new Client object.\n   * - Clients maintain their own guest tokens for Twitter's internal API.\n   * - Reusing Client objects is recommended to minimize the time spent authenticating unnecessarily.\n   */\n  constructor(private readonly options?: Partial<ClientOptions>) {\n    this.token = bearerToken;\n    this.useGuestAuth();\n  }\n\n  /**\n   * Initializes auth properties using a guest token.\n   * Used when creating a new instance of this class, and when logging out.\n   * @internal\n   */\n  private useGuestAuth() {\n    this.auth = new TwitterGuestAuth(this.token, this.getAuthOptions());\n    this.authTrends = new TwitterGuestAuth(this.token, this.getAuthOptions());\n  }\n\n  /**\n   * Fetches a Twitter profile.\n   * @param username The Twitter username of the profile to fetch, without an `@` at the beginning.\n   * @returns The requested {@link Profile}.\n   */\n  public async getProfile(username: string): Promise<Profile> {\n    const res = await getProfile(username, this.auth);\n    return this.handleResponse(res);\n  }\n\n  /**\n   * Fetches the user ID corresponding to the provided screen name.\n   * @param screenName The Twitter screen name of the profile to fetch.\n   * @returns The ID of the corresponding account.\n   */\n  public async getEntityIdByScreenName(screenName: string): Promise<string> {\n    const res = await getEntityIdByScreenName(screenName, this.auth);\n    return this.handleResponse(res);\n  }\n\n  /**\n   *\n   * @param userId The user ID of the profile to fetch.\n   * @returns The screen name of the corresponding account.\n   */\n  public async getScreenNameByUserId(userId: string): Promise<string> {\n    const response = await getScreenNameByUserId(userId, this.auth);\n    return this.handleResponse(response);\n  }\n\n  /**\n   * Fetches tweets from Twitter.\n   * @param query The search query. Any Twitter-compatible query format can be used.\n   * @param maxTweets The maximum number of tweets to return.\n   * @param includeReplies Whether or not replies should be included in the response.\n   * @param searchMode The category filter to apply to the search. Defaults to `Top`.\n   * @returns An {@link AsyncGenerator} of tweets matching the provided filters.\n   */\n  public searchTweets(\n    query: string,\n    maxTweets: number,\n    searchMode: SearchMode = SearchMode.Top\n  ): AsyncGenerator<Tweet, void> {\n    return searchTweets(query, maxTweets, searchMode, this.auth);\n  }\n\n  /**\n   * Fetches profiles from Twitter.\n   * @param query The search query. Any Twitter-compatible query format can be used.\n   * @param maxProfiles The maximum number of profiles to return.\n   * @returns An {@link AsyncGenerator} of tweets matching the provided filter(s).\n   */\n  public searchProfiles(query: string, maxProfiles: number): AsyncGenerator<Profile, void> {\n    return searchProfiles(query, maxProfiles, this.auth);\n  }\n\n  /**\n   * Fetches tweets from Twitter.\n   * @param query The search query. Any Twitter-compatible query format can be used.\n   * @param maxTweets The maximum number of tweets to return.\n   * @param includeReplies Whether or not replies should be included in the response.\n   * @param searchMode The category filter to apply to the search. Defaults to `Top`.\n   * @param cursor The search cursor, which can be passed into further requests for more results.\n   * @returns A page of results, containing a cursor that can be used in further requests.\n   */\n  public fetchSearchTweets(\n    query: string,\n    maxTweets: number,\n    searchMode: SearchMode,\n    cursor?: string\n  ): Promise<QueryTweetsResponse> {\n    return fetchSearchTweets(query, maxTweets, searchMode, this.auth, cursor);\n  }\n\n  /**\n   * Fetches profiles from Twitter.\n   * @param query The search query. Any Twitter-compatible query format can be used.\n   * @param maxProfiles The maximum number of profiles to return.\n   * @param cursor The search cursor, which can be passed into further requests for more results.\n   * @returns A page of results, containing a cursor that can be used in further requests.\n   */\n  public fetchSearchProfiles(\n    query: string,\n    maxProfiles: number,\n    cursor?: string\n  ): Promise<QueryProfilesResponse> {\n    return fetchSearchProfiles(query, maxProfiles, this.auth, cursor);\n  }\n\n  /**\n   * Fetches list tweets from Twitter.\n   * @param listId The list id\n   * @param maxTweets The maximum number of tweets to return.\n   * @param cursor The search cursor, which can be passed into further requests for more results.\n   * @returns A page of results, containing a cursor that can be used in further requests.\n   */\n  public fetchListTweets(\n    listId: string,\n    maxTweets: number,\n    cursor?: string\n  ): Promise<QueryTweetsResponse> {\n    return fetchListTweets(listId, maxTweets, cursor, this.auth);\n  }\n\n  /**\n   * Fetch the profiles a user is following\n   * @param userId The user whose following should be returned\n   * @param maxProfiles The maximum number of profiles to return.\n   * @returns An {@link AsyncGenerator} of following profiles for the provided user.\n   */\n  public getFollowing(userId: string, maxProfiles: number): AsyncGenerator<Profile, void> {\n    return getFollowing(userId, maxProfiles, this.auth);\n  }\n\n  /**\n   * Fetch the profiles that follow a user\n   * @param userId The user whose followers should be returned\n   * @param maxProfiles The maximum number of profiles to return.\n   * @returns An {@link AsyncGenerator} of profiles following the provided user.\n   */\n  public getFollowers(userId: string, maxProfiles: number): AsyncGenerator<Profile, void> {\n    return getFollowers(userId, maxProfiles, this.auth);\n  }\n\n  /**\n   * Fetches following profiles from Twitter.\n   * @param userId The user whose following should be returned\n   * @param maxProfiles The maximum number of profiles to return.\n   * @param cursor The search cursor, which can be passed into further requests for more results.\n   * @returns A page of results, containing a cursor that can be used in further requests.\n   */\n  public fetchProfileFollowing(\n    userId: string,\n    maxProfiles: number,\n    cursor?: string\n  ): Promise<QueryProfilesResponse> {\n    return fetchProfileFollowing(userId, maxProfiles, this.auth, cursor);\n  }\n\n  /**\n   * Fetches profile followers from Twitter.\n   * @param userId The user whose following should be returned\n   * @param maxProfiles The maximum number of profiles to return.\n   * @param cursor The search cursor, which can be passed into further requests for more results.\n   * @returns A page of results, containing a cursor that can be used in further requests.\n   */\n  public fetchProfileFollowers(\n    userId: string,\n    maxProfiles: number,\n    cursor?: string\n  ): Promise<QueryProfilesResponse> {\n    return fetchProfileFollowers(userId, maxProfiles, this.auth, cursor);\n  }\n\n  /**\n   * Fetches the home timeline for the current user. (for you feed)\n   * @param count The number of tweets to fetch.\n   * @param seenTweetIds An array of tweet IDs that have already been seen.\n   * @returns A promise that resolves to the home timeline response.\n   */\n  public async fetchHomeTimeline(count: number, seenTweetIds: string[]): Promise<any[]> {\n    return await fetchHomeTimeline(count, seenTweetIds, this.auth);\n  }\n\n  /**\n   * Fetches the home timeline for the current user. (following feed)\n   * @param count The number of tweets to fetch.\n   * @param seenTweetIds An array of tweet IDs that have already been seen.\n   * @returns A promise that resolves to the home timeline response.\n   */\n  public async fetchFollowingTimeline(count: number, seenTweetIds: string[]): Promise<any[]> {\n    return await fetchFollowingTimeline(count, seenTweetIds, this.auth);\n  }\n\n  async getUserTweets(\n    userId: string,\n    maxTweets = 200,\n    cursor?: string\n  ): Promise<{ tweets: Tweet[]; next?: string }> {\n    if (maxTweets > 200) {\n      maxTweets = 200;\n    }\n\n    const variables: Record<string, any> = {\n      userId,\n      count: maxTweets,\n      includePromotedContent: true,\n      withQuickPromoteEligibilityTweetFields: true,\n      withVoice: true,\n      withV2Timeline: true,\n    };\n\n    if (cursor) {\n      variables.cursor = cursor;\n    }\n\n    const features = {\n      rweb_tipjar_consumption_enabled: true,\n      responsive_web_graphql_exclude_directive_enabled: true,\n      verified_phone_label_enabled: false,\n      creator_subscriptions_tweet_preview_api_enabled: true,\n      responsive_web_graphql_timeline_navigation_enabled: true,\n      responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,\n      communities_web_enable_tweet_community_results_fetch: true,\n      c9s_tweet_anatomy_moderator_badge_enabled: true,\n      articles_preview_enabled: true,\n      responsive_web_edit_tweet_api_enabled: true,\n      graphql_is_translatable_rweb_tweet_is_translatable_enabled: true,\n      view_counts_everywhere_api_enabled: true,\n      longform_notetweets_consumption_enabled: true,\n      responsive_web_twitter_article_tweet_consumption_enabled: true,\n      tweet_awards_web_tipping_enabled: false,\n      creator_subscriptions_quote_tweet_preview_enabled: false,\n      freedom_of_speech_not_reach_fetch_enabled: true,\n      standardized_nudges_misinfo: true,\n      tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: true,\n      rweb_video_timestamps_enabled: true,\n      longform_notetweets_rich_text_read_enabled: true,\n      longform_notetweets_inline_media_enabled: true,\n      responsive_web_enhance_cards_enabled: false,\n    };\n\n    const fieldToggles = {\n      withArticlePlainText: false,\n    };\n\n    const res = await requestApi<TimelineV2>(\n      `${UserTweetsUrl}?variables=${encodeURIComponent(\n        JSON.stringify(variables)\n      )}&features=${encodeURIComponent(\n        JSON.stringify(features)\n      )}&fieldToggles=${encodeURIComponent(JSON.stringify(fieldToggles))}`,\n      this.auth\n    );\n\n    if (!res.success) {\n      throw (res as any).err;\n    }\n\n    const timelineV2 = parseTimelineTweetsV2(res.value);\n    return {\n      tweets: timelineV2.tweets,\n      next: timelineV2.next,\n    };\n  }\n\n  async *getUserTweetsIterator(userId: string, maxTweets = 200): AsyncGenerator<Tweet, void> {\n    let cursor: string | undefined;\n    let retrievedTweets = 0;\n\n    while (retrievedTweets < maxTweets) {\n      const response = await this.getUserTweets(userId, maxTweets - retrievedTweets, cursor);\n\n      for (const tweet of response.tweets) {\n        yield tweet;\n        retrievedTweets++;\n        if (retrievedTweets >= maxTweets) {\n          break;\n        }\n      }\n\n      cursor = response.next;\n\n      if (!cursor) {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Fetches the current trends from Twitter.\n   * @returns The current list of trends.\n   */\n  public getTrends(): Promise<string[]> {\n    return getTrends(this.authTrends);\n  }\n\n  /**\n   * Fetches tweets from a Twitter user.\n   * @param user The user whose tweets should be returned.\n   * @param maxTweets The maximum number of tweets to return. Defaults to `200`.\n   * @returns An {@link AsyncGenerator} of tweets from the provided user.\n   */\n  public getTweets(user: string, maxTweets = 200): AsyncGenerator<Tweet> {\n    return getTweets(user, maxTweets, this.auth);\n  }\n\n  /**\n   * Fetches tweets from a Twitter user using their ID.\n   * @param userId The user whose tweets should be returned.\n   * @param maxTweets The maximum number of tweets to return. Defaults to `200`.\n   * @returns An {@link AsyncGenerator} of tweets from the provided user.\n   */\n  public getTweetsByUserId(userId: string, maxTweets = 200): AsyncGenerator<Tweet, void> {\n    return getTweetsByUserId(userId, maxTweets, this.auth);\n  }\n\n  /**\n   * Send a tweet\n   * @param text The text of the tweet\n   * @param tweetId The id of the tweet to reply to\n   * @param mediaData Optional media data\n   * @returns\n   */\n\n  async sendTweet(\n    text: string,\n    replyToTweetId?: string,\n    mediaData?: { data: Buffer; mediaType: string }[],\n    hideLinkPreview?: boolean\n  ) {\n    return await createCreateTweetRequest(\n      text,\n      this.auth,\n      replyToTweetId,\n      mediaData,\n      hideLinkPreview\n    );\n  }\n\n  async sendNoteTweet(\n    text: string,\n    replyToTweetId?: string,\n    mediaData?: { data: Buffer; mediaType: string }[]\n  ) {\n    return await createCreateNoteTweetRequest(text, this.auth, replyToTweetId, mediaData);\n  }\n\n  /**\n   * Send a long tweet (Note Tweet)\n   * @param text The text of the tweet\n   * @param tweetId The id of the tweet to reply to\n   * @param mediaData Optional media data\n   * @returns\n   */\n  async sendLongTweet(\n    text: string,\n    replyToTweetId?: string,\n    mediaData?: { data: Buffer; mediaType: string }[]\n  ) {\n    return await createCreateLongTweetRequest(text, this.auth, replyToTweetId, mediaData);\n  }\n\n  /**\n   * Send a tweet\n   * @param text The text of the tweet\n   * @param tweetId The id of the tweet to reply to\n   * @param options The options for the tweet\n   * @returns\n   */\n\n  async sendTweetV2(\n    text: string,\n    replyToTweetId?: string,\n    options?: {\n      poll?: PollData;\n    }\n  ) {\n    return await createCreateTweetRequestV2(text, this.auth, replyToTweetId, options);\n  }\n\n  /**\n   * Fetches tweets and replies from a Twitter user.\n   * @param user The user whose tweets should be returned.\n   * @param maxTweets The maximum number of tweets to return. Defaults to `200`.\n   * @returns An {@link AsyncGenerator} of tweets from the provided user.\n   */\n  public getTweetsAndReplies(user: string, maxTweets = 200): AsyncGenerator<Tweet> {\n    return getTweetsAndReplies(user, maxTweets, this.auth);\n  }\n\n  /**\n   * Fetches tweets and replies from a Twitter user using their ID.\n   * @param userId The user whose tweets should be returned.\n   * @param maxTweets The maximum number of tweets to return. Defaults to `200`.\n   * @returns An {@link AsyncGenerator} of tweets from the provided user.\n   */\n  public getTweetsAndRepliesByUserId(userId: string, maxTweets = 200): AsyncGenerator<Tweet, void> {\n    return getTweetsAndRepliesByUserId(userId, maxTweets, this.auth);\n  }\n\n  /**\n   * Fetches the first tweet matching the given query.\n   *\n   * Example:\n   * ```js\n   * const timeline = client.getTweets('user', 200);\n   * const retweet = await client.getTweetWhere(timeline, { isRetweet: true });\n   * ```\n   * @param tweets The {@link AsyncIterable} of tweets to search through.\n   * @param query A query to test **all** tweets against. This may be either an\n   * object of key/value pairs or a predicate. If this query is an object, all\n   * key/value pairs must match a {@link Tweet} for it to be returned. If this query\n   * is a predicate, it must resolve to `true` for a {@link Tweet} to be returned.\n   * - All keys are optional.\n   * - If specified, the key must be implemented by that of {@link Tweet}.\n   */\n  public getTweetWhere(tweets: AsyncIterable<Tweet>, query: TweetQuery): Promise<Tweet | null> {\n    return getTweetWhere(tweets, query);\n  }\n\n  /**\n   * Fetches all tweets matching the given query.\n   *\n   * Example:\n   * ```js\n   * const timeline = client.getTweets('user', 200);\n   * const retweets = await client.getTweetsWhere(timeline, { isRetweet: true });\n   * ```\n   * @param tweets The {@link AsyncIterable} of tweets to search through.\n   * @param query A query to test **all** tweets against. This may be either an\n   * object of key/value pairs or a predicate. If this query is an object, all\n   * key/value pairs must match a {@link Tweet} for it to be returned. If this query\n   * is a predicate, it must resolve to `true` for a {@link Tweet} to be returned.\n   * - All keys are optional.\n   * - If specified, the key must be implemented by that of {@link Tweet}.\n   */\n  public getTweetsWhere(tweets: AsyncIterable<Tweet>, query: TweetQuery): Promise<Tweet[]> {\n    return getTweetsWhere(tweets, query);\n  }\n\n  /**\n   * Fetches the most recent tweet from a Twitter user.\n   * @param user The user whose latest tweet should be returned.\n   * @param includeRetweets Whether or not to include retweets. Defaults to `false`.\n   * @returns The {@link Tweet} object or `null`/`undefined` if it couldn't be fetched.\n   */\n  public getLatestTweet(\n    user: string,\n    includeRetweets = false,\n    max = 200\n  ): Promise<Tweet | null | undefined> {\n    return getLatestTweet(user, includeRetweets, max, this.auth);\n  }\n\n  /**\n   * Fetches a single tweet.\n   * @param id The ID of the tweet to fetch.\n   * @returns The {@link Tweet} object, or `null` if it couldn't be fetched.\n   */\n  public getTweet(id: string): Promise<Tweet | null> {\n    if (this.auth instanceof TwitterUserAuth) {\n      return getTweet(id, this.auth);\n    }\n    return getTweetAnonymous(id, this.auth);\n  }\n\n  /**\n   * Fetches a single tweet by ID using the Twitter API v2.\n   * Allows specifying optional expansions and fields for more detailed data.\n   *\n   * @param {string} id - The ID of the tweet to fetch.\n   * @param {Object} [options] - Optional parameters to customize the tweet data.\n   * @param {string[]} [options.expansions] - Array of expansions to include, e.g., 'attachments.poll_ids'.\n   * @param {string[]} [options.tweetFields] - Array of tweet fields to include, e.g., 'created_at', 'public_metrics'.\n   * @param {string[]} [options.pollFields] - Array of poll fields to include, if the tweet has a poll, e.g., 'options', 'end_datetime'.\n   * @param {string[]} [options.mediaFields] - Array of media fields to include, if the tweet includes media, e.g., 'url', 'preview_image_url'.\n   * @param {string[]} [options.userFields] - Array of user fields to include, if user information is requested, e.g., 'username', 'verified'.\n   * @param {string[]} [options.placeFields] - Array of place fields to include, if the tweet includes location data, e.g., 'full_name', 'country'.\n   * @returns {Promise<TweetV2 | null>} - The tweet data, including requested expansions and fields.\n   */\n  async getTweetV2(\n    id: string,\n    options: {\n      expansions?: TTweetv2Expansion[];\n      tweetFields?: TTweetv2TweetField[];\n      pollFields?: TTweetv2PollField[];\n      mediaFields?: TTweetv2MediaField[];\n      userFields?: TTweetv2UserField[];\n      placeFields?: TTweetv2PlaceField[];\n    } = defaultOptions\n  ): Promise<Tweet | null> {\n    return await getTweetV2(id, this.auth, options);\n  }\n\n  /**\n   * Fetches multiple tweets by IDs using the Twitter API v2.\n   * Allows specifying optional expansions and fields for more detailed data.\n   *\n   * @param {string[]} ids - Array of tweet IDs to fetch.\n   * @param {Object} [options] - Optional parameters to customize the tweet data.\n   * @param {string[]} [options.expansions] - Array of expansions to include, e.g., 'attachments.poll_ids'.\n   * @param {string[]} [options.tweetFields] - Array of tweet fields to include, e.g., 'created_at', 'public_metrics'.\n   * @param {string[]} [options.pollFields] - Array of poll fields to include, if tweets contain polls, e.g., 'options', 'end_datetime'.\n   * @param {string[]} [options.mediaFields] - Array of media fields to include, if tweets contain media, e.g., 'url', 'preview_image_url'.\n   * @param {string[]} [options.userFields] - Array of user fields to include, if user information is requested, e.g., 'username', 'verified'.\n   * @param {string[]} [options.placeFields] - Array of place fields to include, if tweets contain location data, e.g., 'full_name', 'country'.\n   * @returns {Promise<TweetV2[]> } - Array of tweet data, including requested expansions and fields.\n   */\n  async getTweetsV2(\n    ids: string[],\n    options: {\n      expansions?: TTweetv2Expansion[];\n      tweetFields?: TTweetv2TweetField[];\n      pollFields?: TTweetv2PollField[];\n      mediaFields?: TTweetv2MediaField[];\n      userFields?: TTweetv2UserField[];\n      placeFields?: TTweetv2PlaceField[];\n    } = defaultOptions\n  ): Promise<Tweet[]> {\n    return await getTweetsV2(ids, this.auth, options);\n  }\n\n  /**\n   * Returns if the client has a guest token. The token may not be valid.\n   * @returns `true` if the client has a guest token; otherwise `false`.\n   */\n  public hasGuestToken(): boolean {\n    return this.auth.hasToken() || this.authTrends.hasToken();\n  }\n\n  /**\n   * Returns if the client is logged in as a real user.\n   * @returns `true` if the client is logged in with a real user account; otherwise `false`.\n   */\n  public async isLoggedIn(): Promise<boolean> {\n    return (await this.auth.isLoggedIn()) && (await this.authTrends.isLoggedIn());\n  }\n\n  /**\n   * Returns the currently logged in user\n   * @returns The currently logged in user\n   */\n  public async me(): Promise<Profile | undefined> {\n    return this.auth.me();\n  }\n\n  /**\n   * Login to Twitter as a real Twitter account. This enables running\n   * searches.\n   * @param username The username of the Twitter account to login with.\n   * @param password The password of the Twitter account to login with.\n   * @param email The email to log in with, if you have email confirmation enabled.\n   * @param twoFactorSecret The secret to generate two factor authentication tokens with, if you have two factor authentication enabled.\n   */\n  public async login(\n    username: string,\n    password: string,\n    email?: string,\n    twoFactorSecret?: string,\n    appKey?: string,\n    appSecret?: string,\n    accessToken?: string,\n    accessSecret?: string\n  ): Promise<void> {\n    // Swap in a real authorizer for all requests\n    const userAuth = new TwitterUserAuth(this.token, this.getAuthOptions());\n    await userAuth.login(\n      username,\n      password,\n      email,\n      twoFactorSecret,\n      appKey,\n      appSecret,\n      accessToken,\n      accessSecret\n    );\n    this.auth = userAuth;\n    this.authTrends = userAuth;\n  }\n\n  /**\n   * Log out of Twitter.\n   */\n  public async logout(): Promise<void> {\n    await this.auth.logout();\n    await this.authTrends.logout();\n\n    // Swap in guest authorizers for all requests\n    this.useGuestAuth();\n  }\n\n  /**\n   * Retrieves all cookies for the current session.\n   * @returns All cookies for the current session.\n   */\n  public async getCookies(): Promise<Cookie[]> {\n    return await this.authTrends\n      .cookieJar()\n      .getCookies(typeof document !== 'undefined' ? document.location.toString() : twUrl);\n  }\n\n  /**\n   * Set cookies for the current session.\n   * @param cookies The cookies to set for the current session.\n   */\n  public async setCookies(cookies: (string | Cookie)[]): Promise<void> {\n    const userAuth = new TwitterUserAuth(this.token, this.getAuthOptions());\n    for (const cookie of cookies) {\n      await userAuth.cookieJar().setCookie(cookie, twUrl);\n    }\n\n    this.auth = userAuth;\n    this.authTrends = userAuth;\n  }\n\n  /**\n   * Clear all cookies for the current session.\n   */\n  public async clearCookies(): Promise<void> {\n    await this.auth.cookieJar().removeAllCookies();\n    await this.authTrends.cookieJar().removeAllCookies();\n  }\n\n  /**\n   * Sets the optional cookie to be used in requests.\n   * @param _cookie The cookie to be used in requests.\n   * @deprecated This function no longer represents any part of Twitter's auth flow.\n   * @returns This client instance.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public withCookie(_cookie: string): Client {\n    console.warn(\n      'Warning: Client#withCookie is deprecated and will be removed in a later version. Use Client#login or Client#setCookies instead.'\n    );\n    return this;\n  }\n\n  /**\n   * Sets the optional CSRF token to be used in requests.\n   * @param _token The CSRF token to be used in requests.\n   * @deprecated This function no longer represents any part of Twitter's auth flow.\n   * @returns This client instance.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public withXCsrfToken(_token: string): Client {\n    console.warn(\n      'Warning: Client#withXCsrfToken is deprecated and will be removed in a later version.'\n    );\n    return this;\n  }\n\n  /**\n   * Sends a quote tweet.\n   * @param text The text of the tweet.\n   * @param quotedTweetId The ID of the tweet to quote.\n   * @param options Optional parameters, such as media data.\n   * @returns The response from the Twitter API.\n   */\n  public async sendQuoteTweet(\n    text: string,\n    quotedTweetId: string,\n    options?: {\n      mediaData: { data: Buffer; mediaType: string }[];\n    }\n  ) {\n    return await createQuoteTweetRequest(text, quotedTweetId, this.auth, options?.mediaData);\n  }\n\n  /**\n   * Likes a tweet with the given tweet ID.\n   * @param tweetId The ID of the tweet to like.\n   * @returns A promise that resolves when the tweet is liked.\n   */\n  public async likeTweet(tweetId: string): Promise<void> {\n    // Call the likeTweet function from tweets.ts\n    await likeTweet(tweetId, this.auth);\n  }\n\n  /**\n   * Retweets a tweet with the given tweet ID.\n   * @param tweetId The ID of the tweet to retweet.\n   * @returns A promise that resolves when the tweet is retweeted.\n   */\n  public async retweet(tweetId: string): Promise<void> {\n    // Call the retweet function from tweets.ts\n    await retweet(tweetId, this.auth);\n  }\n\n  /**\n   * Follows a user with the given user ID.\n   * @param userId The user ID of the user to follow.\n   * @returns A promise that resolves when the user is followed.\n   */\n  public async followUser(userName: string): Promise<void> {\n    // Call the followUser function from relationships.ts\n    await followUser(userName, this.auth);\n  }\n\n  /**\n   * Fetches direct message conversations\n   * @param count Number of conversations to fetch (default: 50)\n   * @param cursor Pagination cursor for fetching more conversations\n   * @returns Array of DM conversations and other details\n   */\n  public async getDirectMessageConversations(\n    userId: string,\n    cursor?: string\n  ): Promise<DirectMessagesResponse> {\n    return await getDirectMessageConversations(userId, this.auth, cursor);\n  }\n\n  /**\n   * Sends a direct message to a user.\n   * @param conversationId The ID of the conversation to send the message to.\n   * @param text The text of the message to send.\n   * @returns The response from the Twitter API.\n   */\n  public async sendDirectMessage(\n    conversationId: string,\n    text: string\n  ): Promise<SendDirectMessageResponse> {\n    return await sendDirectMessage(this.auth, conversationId, text);\n  }\n\n  private getAuthOptions(): Partial<TwitterAuthOptions> {\n    return {\n      fetch: this.options?.fetch,\n      transform: this.options?.transform,\n    };\n  }\n\n  private handleResponse<T>(res: RequestApiResult<T>): T {\n    if (!res.success) {\n      throw (res as any).err;\n    }\n\n    return res.value;\n  }\n\n  /**\n   * Retrieves the details of an Audio Space by its ID.\n   * @param id The ID of the Audio Space.\n   * @returns The details of the Audio Space.\n   */\n  public async getAudioSpaceById(id: string): Promise<AudioSpace> {\n    const variables = {\n      id,\n      isMetatagsQuery: false,\n      withReplays: true,\n      withListeners: true,\n    };\n\n    return await fetchAudioSpaceById(variables, this.auth);\n  }\n\n  /**\n   * Retrieves available space topics.\n   * @returns An array of space topics.\n   */\n  public async browseSpaceTopics(): Promise<Subtopic[]> {\n    return await fetchBrowseSpaceTopics(this.auth);\n  }\n\n  /**\n   * Retrieves available communities.\n   * @returns An array of communities.\n   */\n  public async communitySelectQuery(): Promise<Community[]> {\n    return await fetchCommunitySelectQuery(this.auth);\n  }\n\n  /**\n   * Retrieves the status of an Audio Space stream by its media key.\n   * @param mediaKey The media key of the Audio Space.\n   * @returns The status of the Audio Space stream.\n   */\n  public async getAudioSpaceStreamStatus(mediaKey: string): Promise<LiveVideoStreamStatus> {\n    return await fetchLiveVideoStreamStatus(mediaKey, this.auth);\n  }\n\n  /**\n   * Retrieves the status of an Audio Space by its ID.\n   * This method internally fetches the Audio Space to obtain the media key,\n   * then retrieves the stream status using the media key.\n   * @param audioSpaceId The ID of the Audio Space.\n   * @returns The status of the Audio Space stream.\n   */\n  public async getAudioSpaceStatus(audioSpaceId: string): Promise<LiveVideoStreamStatus> {\n    const audioSpace = await this.getAudioSpaceById(audioSpaceId);\n\n    const mediaKey = audioSpace.metadata.media_key;\n    if (!mediaKey) {\n      throw new Error('Media Key not found in Audio Space metadata.');\n    }\n\n    return await this.getAudioSpaceStreamStatus(mediaKey);\n  }\n\n  /**\n   * Authenticates Periscope to obtain a token.\n   * @returns The Periscope authentication token.\n   */\n  public async authenticatePeriscope(): Promise<string> {\n    return await fetchAuthenticatePeriscope(this.auth);\n  }\n\n  /**\n   * Logs in to Twitter via Proxsee using the Periscope JWT.\n   * @param jwt The JWT obtained from AuthenticatePeriscope.\n   * @returns The response containing the cookie and user information.\n   */\n  public async loginTwitterToken(jwt: string): Promise<LoginTwitterTokenResponse> {\n    return await fetchLoginTwitterToken(jwt, this.auth);\n  }\n\n  /**\n   * Orchestrates the flow: get token -> login -> return Periscope cookie\n   */\n  public async getPeriscopeCookie(): Promise<string> {\n    const periscopeToken = await this.authenticatePeriscope();\n\n    const loginResponse = await this.loginTwitterToken(periscopeToken);\n\n    return loginResponse.cookie;\n  }\n\n  /**\n   * Fetches a article (long form tweet) by its ID.\n   * @param id The ID of the article to fetch. In the format of (http://x.com/i/article/id)\n   * @returns The {@link TimelineArticle} object, or `null` if it couldn't be fetched.\n   */\n  public getArticle(id: string): Promise<TimelineArticle | null> {\n    return getArticle(id, this.auth);\n  }\n\n  /**\n   * Creates a new conversation with Grok.\n   * @returns A promise that resolves to the conversation ID string.\n   */\n  public async createGrokConversation(): Promise<string> {\n    return await createGrokConversation(this.auth);\n  }\n\n  /**\n   * Interact with Grok in a chat-like manner.\n   * @param options The options for the Grok chat interaction.\n   * @param {GrokMessage[]} options.messages - Array of messages in the conversation.\n   * @param {string} [options.conversationId] - Optional ID of an existing conversation.\n   * @param {boolean} [options.returnSearchResults] - Whether to return search results.\n   * @param {boolean} [options.returnCitations] - Whether to return citations.\n   * @returns A promise that resolves to the Grok chat response.\n   */\n  public async grokChat(options: GrokChatOptions): Promise<GrokChatResponse> {\n    return await grokChat(options, this.auth);\n  }\n\n  /**\n   * Retrieves all users who retweeted the given tweet.\n   * @param tweetId The ID of the tweet.\n   * @returns An array of users (retweeters).\n   */\n  public async getRetweetersOfTweet(tweetId: string): Promise<Retweeter[]> {\n    return await getAllRetweeters(tweetId, this.auth);\n  }\n\n  /**\n   * Fetches all tweets quoting a given tweet ID by chaining requests\n   * until no more pages are available.\n   * @param quotedTweetId The tweet ID to find quotes of.\n   * @param maxTweetsPerPage Max tweets per page (default 20).\n   * @returns An array of all Tweet objects referencing the given tweet.\n   */\n  public async getAllQuotedTweets(quotedTweetId: string, maxTweetsPerPage = 20): Promise<Tweet[]> {\n    const allQuotes: Tweet[] = [];\n    let cursor: string | undefined;\n    let prevCursor: string | undefined;\n\n    while (true) {\n      const page = await fetchQuotedTweetsPage(quotedTweetId, maxTweetsPerPage, this.auth, cursor);\n\n      // If there's no new tweets, stop\n      if (!page.tweets || page.tweets.length === 0) {\n        break;\n      }\n\n      allQuotes.push(...page.tweets);\n\n      // If next is missing or same => stop\n      if (!page.next || page.next === cursor || page.next === prevCursor) {\n        break;\n      }\n\n      // Move cursors\n      prevCursor = cursor;\n      cursor = page.next;\n    }\n\n    return allQuotes;\n  }\n}\n","// src/core/Space.ts\n\nimport { EventEmitter } from 'node:events';\nimport type { Client } from '../../client';\nimport { Logger } from '../logger';\nimport type {\n  AudioDataWithUser,\n  BroadcastCreated,\n  Plugin,\n  PluginRegistration,\n  SpaceConfig,\n  SpeakerInfo,\n} from '../types';\nimport {\n  authorizeToken,\n  createBroadcast,\n  getRegion,\n  getTurnServers,\n  muteSpeaker,\n  publishBroadcast,\n  setupCommonChatEvents,\n  unmuteSpeaker,\n} from '../utils';\nimport { ChatClient } from './ChatClient';\nimport { JanusClient } from './JanusClient';\n\n/**\n * Manages the creation of a new Space (broadcast host):\n * 1) Creates the broadcast on Periscope\n * 2) Sets up Janus WebRTC for audio\n * 3) Optionally creates a ChatClient for interactive mode\n * 4) Allows managing (approve/remove) speakers, pushing audio, etc.\n */\n/**\n * Represents a space that can be used for communication and collaboration.\n * Extends the EventEmitter class and contains properties for debugging, logging, Janus client, chat client, authentication token,\n * and broadcast information.\n */\nexport class Space extends EventEmitter {\n  private readonly debug: boolean;\n  private readonly logger: Logger;\n\n  private janusClient?: JanusClient;\n  private chatClient?: ChatClient;\n\n  private authToken?: string;\n  private broadcastInfo?: BroadcastCreated;\n  private isInitialized = false;\n\n  private plugins = new Set<PluginRegistration>();\n  private speakers = new Map<string, SpeakerInfo>();\n\n  constructor(\n    private readonly client: Client,\n    options?: { debug?: boolean }\n  ) {\n    super();\n    this.debug = options?.debug ?? false;\n    this.logger = new Logger(this.debug);\n  }\n\n  /**\n   * Registers a plugin and calls its onAttach(...).\n   * init(...) will be invoked once initialization is complete.\n   */\n  public use(plugin: Plugin, config?: Record<string, any>) {\n    const registration: PluginRegistration = { plugin, config };\n    this.plugins.add(registration);\n\n    this.logger.debug('[Space] Plugin added =>', plugin.constructor.name);\n    plugin.onAttach?.({ space: this, pluginConfig: config });\n\n    // If we've already initialized this Space, immediately call plugin.init(...)\n    if (this.isInitialized && plugin.init) {\n      plugin.init({ space: this, pluginConfig: config });\n      // If Janus is also up, call onJanusReady\n      if (this.janusClient) {\n        plugin.onJanusReady?.(this.janusClient);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Main entry point to create and initialize the Space broadcast.\n   */\n  public async initialize(config: SpaceConfig) {\n    this.logger.debug('[Space] Initializing...');\n\n    // 1) Obtain the Periscope cookie + region\n    const cookie = await this.client.getPeriscopeCookie();\n    const region = await getRegion();\n    this.logger.debug('[Space] Got region =>', region);\n\n    // 2) Create a broadcast\n    this.logger.debug('[Space] Creating broadcast...');\n    const broadcast = await createBroadcast({\n      description: config.description,\n      languages: config.languages,\n      cookie,\n      region,\n      record: config.record,\n    });\n    this.broadcastInfo = broadcast;\n\n    // 3) Authorize to get an auth token\n    this.logger.debug('[Space] Authorizing token...');\n    this.authToken = await authorizeToken(cookie);\n\n    // 4) Gather TURN servers\n    this.logger.debug('[Space] Getting turn servers...');\n    const turnServers = await getTurnServers(cookie);\n\n    // 5) Create and initialize Janus for hosting\n    this.janusClient = new JanusClient({\n      webrtcUrl: broadcast.webrtc_gw_url,\n      roomId: broadcast.room_id,\n      credential: broadcast.credential,\n      userId: broadcast.broadcast.user_id,\n      streamName: broadcast.stream_name,\n      turnServers,\n      logger: this.logger,\n    });\n    await this.janusClient.initialize();\n\n    // Forward PCM from Janus to plugin.onAudioData\n    this.janusClient.on('audioDataFromSpeaker', (data: AudioDataWithUser) => {\n      this.logger.debug('[Space] Received PCM from speaker =>', data.userId);\n      this.handleAudioData(data);\n    });\n\n    // Update speaker info once we subscribe\n    this.janusClient.on('subscribedSpeaker', ({ userId, feedId }) => {\n      const speaker = this.speakers.get(userId);\n      if (!speaker) {\n        this.logger.debug('[Space] subscribedSpeaker => no speaker found', userId);\n        return;\n      }\n      speaker.janusParticipantId = feedId;\n      this.logger.debug(`[Space] updated speaker => userId=${userId}, feedId=${feedId}`);\n    });\n\n    // 6) Publish the broadcast so it's live\n    this.logger.debug('[Space] Publishing broadcast...');\n    await publishBroadcast({\n      title: config.title || '',\n      broadcast,\n      cookie,\n      janusSessionId: this.janusClient.getSessionId(),\n      janusHandleId: this.janusClient.getHandleId(),\n      janusPublisherId: this.janusClient.getPublisherId(),\n    });\n\n    // 7) If interactive => set up ChatClient\n    if (config.mode === 'INTERACTIVE') {\n      this.logger.debug('[Space] Connecting chat...');\n      this.chatClient = new ChatClient({\n        spaceId: broadcast.room_id,\n        accessToken: broadcast.access_token,\n        endpoint: broadcast.endpoint,\n        logger: this.logger,\n      });\n      await this.chatClient.connect();\n      this.setupChatEvents();\n    }\n\n    this.logger.info('[Space] Initialized =>', broadcast.share_url.replace('broadcasts', 'spaces'));\n    this.isInitialized = true;\n\n    // Call plugin.init(...) and onJanusReady(...) for all plugins now that we're set\n    for (const { plugin, config: pluginConfig } of this.plugins) {\n      plugin.init?.({ space: this, pluginConfig });\n      plugin.onJanusReady?.(this.janusClient);\n    }\n\n    this.logger.debug('[Space] All plugins initialized');\n    return broadcast;\n  }\n\n  /**\n   * Send an emoji reaction via chat, if interactive.\n   */\n  public reactWithEmoji(emoji: string) {\n    if (!this.chatClient) return;\n    this.chatClient.reactWithEmoji(emoji);\n  }\n\n  /**\n   * Internal method to wire up chat events if interactive.\n   */\n  private setupChatEvents() {\n    if (!this.chatClient) return;\n    setupCommonChatEvents(this.chatClient, this.logger, this);\n  }\n\n  /**\n   * Approves a speaker request on Twitter side, then calls Janus to subscribe their audio.\n   */\n  public async approveSpeaker(userId: string, sessionUUID: string) {\n    if (!this.isInitialized || !this.broadcastInfo) {\n      throw new Error('[Space] Not initialized or missing broadcastInfo');\n    }\n    if (!this.authToken) {\n      throw new Error('[Space] No auth token available');\n    }\n\n    // Store in our local speaker map\n    this.speakers.set(userId, { userId, sessionUUID });\n\n    // 1) Call Twitter's /request/approve\n    await this.callApproveEndpoint(this.broadcastInfo, this.authToken, userId, sessionUUID);\n\n    // 2) Subscribe to their audio in Janus\n    await this.janusClient?.subscribeSpeaker(userId);\n  }\n\n  /**\n   * Approve request => calls /api/v1/audiospace/request/approve\n   */\n  private async callApproveEndpoint(\n    broadcast: BroadcastCreated,\n    authorizationToken: string,\n    userId: string,\n    sessionUUID: string\n  ): Promise<void> {\n    const endpoint = 'https://guest.pscp.tv/api/v1/audiospace/request/approve';\n    const headers = {\n      'Content-Type': 'application/json',\n      Referer: 'https://x.com/',\n      Authorization: authorizationToken,\n    };\n    const body = {\n      ntpForBroadcasterFrame: '2208988800024000300',\n      ntpForLiveFrame: '2208988800024000300',\n      chat_token: broadcast.access_token,\n      session_uuid: sessionUUID,\n    };\n\n    this.logger.debug('[Space] Approving speaker =>', endpoint, body);\n\n    const resp = await fetch(endpoint, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(body),\n    });\n\n    if (!resp.ok) {\n      const error = await resp.text();\n      throw new Error(`[Space] Failed to approve speaker => ${resp.status}: ${error}`);\n    }\n\n    this.logger.info('[Space] Speaker approved =>', userId);\n  }\n\n  /**\n   * Removes a speaker from the Twitter side, then unsubscribes in Janus if needed.\n   */\n  public async removeSpeaker(userId: string) {\n    if (!this.isInitialized || !this.broadcastInfo) {\n      throw new Error('[Space] Not initialized or missing broadcastInfo');\n    }\n    if (!this.authToken) {\n      throw new Error('[Space] No auth token');\n    }\n    if (!this.janusClient) {\n      throw new Error('[Space] No Janus client');\n    }\n\n    // Find this speaker in local map\n    const speaker = this.speakers.get(userId);\n    if (!speaker) {\n      throw new Error(`[Space] removeSpeaker => no speaker found for userId=${userId}`);\n    }\n\n    const { sessionUUID, janusParticipantId } = speaker;\n    this.logger.debug('[Space] removeSpeaker =>', sessionUUID, janusParticipantId, speaker);\n\n    if (!sessionUUID || janusParticipantId === undefined) {\n      throw new Error(\n        `[Space] removeSpeaker => missing sessionUUID or feedId for userId=${userId}`\n      );\n    }\n\n    // 1) Eject on Twitter side\n    const janusHandleId = this.janusClient.getHandleId();\n    const janusSessionId = this.janusClient.getSessionId();\n    if (!janusHandleId || !janusSessionId) {\n      throw new Error(`[Space] removeSpeaker => missing Janus handle/session for userId=${userId}`);\n    }\n\n    await this.callRemoveEndpoint(\n      this.broadcastInfo,\n      this.authToken,\n      sessionUUID,\n      janusParticipantId,\n      this.broadcastInfo.room_id,\n      janusHandleId,\n      janusSessionId\n    );\n\n    // 2) Remove from local map\n    this.speakers.delete(userId);\n    this.logger.info(`[Space] removeSpeaker => removed userId=${userId}`);\n  }\n\n  /**\n   * Twitter's /api/v1/audiospace/stream/eject call\n   */\n  private async callRemoveEndpoint(\n    broadcast: BroadcastCreated,\n    authorizationToken: string,\n    sessionUUID: string,\n    janusParticipantId: number,\n    janusRoomId: string,\n    webrtcHandleId: number,\n    webrtcSessionId: number\n  ): Promise<void> {\n    const endpoint = 'https://guest.pscp.tv/api/v1/audiospace/stream/eject';\n    const headers = {\n      'Content-Type': 'application/json',\n      Referer: 'https://x.com/',\n      Authorization: authorizationToken,\n    };\n    const body = {\n      ntpForBroadcasterFrame: '2208988800024000300',\n      ntpForLiveFrame: '2208988800024000300',\n      session_uuid: sessionUUID,\n      chat_token: broadcast.access_token,\n      janus_room_id: janusRoomId,\n      janus_participant_id: janusParticipantId,\n      webrtc_handle_id: webrtcHandleId,\n      webrtc_session_id: webrtcSessionId,\n    };\n\n    this.logger.debug('[Space] Removing speaker =>', endpoint, body);\n\n    const resp = await fetch(endpoint, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(body),\n    });\n\n    if (!resp.ok) {\n      const error = await resp.text();\n      throw new Error(`[Space] Failed to remove speaker => ${resp.status}: ${error}`);\n    }\n\n    this.logger.debug('[Space] Speaker removed => sessionUUID=', sessionUUID);\n  }\n\n  /**\n   * Push PCM audio frames if you're the host. Usually you'd do this if you're capturing\n   * microphone input from the host side.\n   */\n  public pushAudio(samples: Int16Array, sampleRate: number) {\n    this.janusClient?.pushLocalAudio(samples, sampleRate);\n  }\n\n  /**\n   * Handler for PCM from other speakers, forwarded to plugin.onAudioData\n   */\n  private handleAudioData(data: AudioDataWithUser) {\n    for (const { plugin } of this.plugins) {\n      plugin.onAudioData?.(data);\n    }\n  }\n\n  /**\n   * Gracefully shut down this Space: destroy the Janus room, end the broadcast, etc.\n   */\n  public async finalizeSpace(): Promise<void> {\n    this.logger.info('[Space] finalizeSpace => stopping broadcast gracefully');\n\n    const tasks: Array<Promise<any>> = [];\n\n    if (this.janusClient) {\n      tasks.push(\n        this.janusClient.destroyRoom().catch((err) => {\n          this.logger.error('[Space] destroyRoom error =>', err);\n        })\n      );\n    }\n\n    if (this.broadcastInfo) {\n      tasks.push(\n        this.endAudiospace({\n          broadcastId: this.broadcastInfo.room_id,\n          chatToken: this.broadcastInfo.access_token,\n        }).catch((err) => {\n          this.logger.error('[Space] endAudiospace error =>', err);\n        })\n      );\n    }\n\n    if (this.janusClient) {\n      tasks.push(\n        this.janusClient.leaveRoom().catch((err) => {\n          this.logger.error('[Space] leaveRoom error =>', err);\n        })\n      );\n    }\n\n    await Promise.all(tasks);\n    this.logger.info('[Space] finalizeSpace => done.');\n  }\n\n  /**\n   * Calls /api/v1/audiospace/admin/endAudiospace on Twitter side.\n   */\n  private async endAudiospace(params: { broadcastId: string; chatToken: string }): Promise<void> {\n    const url = 'https://guest.pscp.tv/api/v1/audiospace/admin/endAudiospace';\n    const headers = {\n      'Content-Type': 'application/json',\n      Referer: 'https://x.com/',\n      Authorization: this.authToken || '',\n    };\n    const body = {\n      broadcast_id: params.broadcastId,\n      chat_token: params.chatToken,\n    };\n\n    this.logger.debug('[Space] endAudiospace =>', body);\n\n    const resp = await fetch(url, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(body),\n    });\n\n    if (!resp.ok) {\n      const errText = await resp.text();\n      throw new Error(`[Space] endAudiospace => ${resp.status} ${errText}`);\n    }\n\n    const json = await resp.json();\n    this.logger.debug('[Space] endAudiospace => success =>', json);\n  }\n\n  /**\n   * Retrieves an array of known speakers in this Space (by userId and sessionUUID).\n   */\n  public getSpeakers(): SpeakerInfo[] {\n    return Array.from(this.speakers.values());\n  }\n\n  /**\n   * Mute the host (yourself). For the host, session_uuid = '' (empty).\n   */\n  public async muteHost() {\n    if (!this.authToken) {\n      throw new Error('[Space] No auth token available');\n    }\n    if (!this.broadcastInfo) {\n      throw new Error('[Space] No broadcastInfo');\n    }\n\n    await muteSpeaker({\n      broadcastId: this.broadcastInfo.room_id,\n      sessionUUID: '', // host => empty\n      chatToken: this.broadcastInfo.access_token,\n      authToken: this.authToken,\n    });\n    this.logger.info('[Space] Host muted successfully.');\n  }\n\n  /**\n   * Unmute the host (yourself).\n   */\n  public async unmuteHost() {\n    if (!this.authToken) {\n      throw new Error('[Space] No auth token');\n    }\n    if (!this.broadcastInfo) {\n      throw new Error('[Space] No broadcastInfo');\n    }\n\n    await unmuteSpeaker({\n      broadcastId: this.broadcastInfo.room_id,\n      sessionUUID: '',\n      chatToken: this.broadcastInfo.access_token,\n      authToken: this.authToken,\n    });\n    this.logger.info('[Space] Host unmuted successfully.');\n  }\n\n  /**\n   * Mute a specific speaker. We'll retrieve sessionUUID from our local map.\n   */\n  public async muteSpeaker(userId: string) {\n    if (!this.authToken) {\n      throw new Error('[Space] No auth token available');\n    }\n    if (!this.broadcastInfo) {\n      throw new Error('[Space] No broadcastInfo');\n    }\n\n    const speaker = this.speakers.get(userId);\n    if (!speaker) {\n      throw new Error(`[Space] Speaker not found for userId=${userId}`);\n    }\n\n    await muteSpeaker({\n      broadcastId: this.broadcastInfo.room_id,\n      sessionUUID: speaker.sessionUUID,\n      chatToken: this.broadcastInfo.access_token,\n      authToken: this.authToken,\n    });\n    this.logger.info(`[Space] Muted speaker => userId=${userId}`);\n  }\n\n  /**\n   * Unmute a specific speaker. We'll retrieve sessionUUID from local map.\n   */\n  public async unmuteSpeaker(userId: string) {\n    if (!this.authToken) {\n      throw new Error('[Space] No auth token available');\n    }\n    if (!this.broadcastInfo) {\n      throw new Error('[Space] No broadcastInfo');\n    }\n\n    const speaker = this.speakers.get(userId);\n    if (!speaker) {\n      throw new Error(`[Space] Speaker not found for userId=${userId}`);\n    }\n\n    await unmuteSpeaker({\n      broadcastId: this.broadcastInfo.room_id,\n      sessionUUID: speaker.sessionUUID,\n      chatToken: this.broadcastInfo.access_token,\n      authToken: this.authToken,\n    });\n    this.logger.info(`[Space] Unmuted speaker => userId=${userId}`);\n  }\n\n  /**\n   * Stop the broadcast entirely, performing finalizeSpace() plus plugin cleanup.\n   */\n  public async stop() {\n    this.logger.info('[Space] Stopping...');\n\n    await this.finalizeSpace().catch((err) => {\n      this.logger.error('[Space] finalizeBroadcast error =>', err);\n    });\n\n    // Disconnect chat if present\n    if (this.chatClient) {\n      await this.chatClient.disconnect();\n      this.chatClient = undefined;\n    }\n\n    // Stop Janus if running\n    if (this.janusClient) {\n      await this.janusClient.stop();\n      this.janusClient = undefined;\n    }\n\n    // Cleanup all plugins\n    for (const { plugin } of this.plugins) {\n      plugin.cleanup?.();\n    }\n    this.plugins.clear();\n\n    this.isInitialized = false;\n  }\n}\n","// src/logger.ts\n\n/**\n * Represents a Logger class for logging information, debug messages, warnings, and errors.\n */\nexport class Logger {\n  private readonly debugEnabled: boolean;\n\n  /**\n   * Constructor for initializing a new instance of the class.\n   *\n   * @param {boolean} debugEnabled - Specifies whether debug mode is enabled or not.\n   */\n  constructor(debugEnabled: boolean) {\n    this.debugEnabled = debugEnabled;\n  }\n\n  /**\n   * Logs an info message with optional additional arguments.\n   *\n   * @param {string} msg - The info message to log.\n   * @param {...any} args - Additional arguments to include in the log message.\n   */\n  info(msg: string, ...args: any[]) {\n    console.log(msg, ...args);\n  }\n\n  /**\n   * Logs a debug message if debug mode is enabled.\n   *\n   * @param {string} msg - The debug message to be logged.\n   * @param {...any} args - Additional arguments to be passed to the console.log function.\n   */\n  debug(msg: string, ...args: any[]) {\n    if (this.debugEnabled) {\n      console.log(msg, ...args);\n    }\n  }\n\n  /**\n   * Logs a warning message to the console.\n   *\n   * @param {string} msg The warning message to be logged.\n   * @param {...any} args Additional arguments to be logged along with the message.\n   */\n  warn(msg: string, ...args: any[]) {\n    console.warn('[WARN]', msg, ...args);\n  }\n\n  /**\n   * Logs an error message to the console.\n   *\n   * @param {string} msg - The error message to be logged.\n   * @param {...any} args - Additional arguments to be logged along with the error message.\n   */\n  error(msg: string, ...args: any[]) {\n    console.error(msg, ...args);\n  }\n\n  /**\n   * Check if debug mode is enabled.\n   * @returns {boolean} True if debug mode is enabled, false otherwise.\n   */\n  isDebugEnabled(): boolean {\n    return this.debugEnabled;\n  }\n}\n","// src/utils.ts\n\nimport type { EventEmitter } from 'node:events';\nimport { Headers } from 'headers-polyfill';\nimport type { ChatClient } from './core/ChatClient';\nimport type { Logger } from './logger';\nimport type { BroadcastCreated, TurnServersInfo } from './types';\n\n/**\n * Authorizes a token for guest access, using the provided Periscope cookie.\n * Returns an authorization token (bearer/JWT-like).\n */\n/**\n * Authorizes a token for a specified cookie.\n *\n * @param {string} cookie - The cookie to use for authorization.\n * @returns {Promise<string>} The authorized token.\n * @throws {Error} If the request fails or if the authorization_token is missing in the response.\n */\nexport async function authorizeToken(cookie: string): Promise<string> {\n  const headers = new Headers({\n    'X-Periscope-User-Agent': 'Twitter/m5',\n    'Content-Type': 'application/json',\n    'X-Idempotence': Date.now().toString(),\n    Referer: 'https://x.com/',\n    'X-Attempt': '1',\n  });\n\n  const resp = await fetch('https://proxsee.pscp.tv/api/v2/authorizeToken', {\n    method: 'POST',\n    headers,\n    body: JSON.stringify({\n      service: 'guest',\n      cookie: cookie,\n    }),\n  });\n\n  if (!resp.ok) {\n    throw new Error(`authorizeToken => request failed with status ${resp.status}`);\n  }\n\n  const data = (await resp.json()) as { authorization_token: string };\n  if (!data.authorization_token) {\n    throw new Error('authorizeToken => Missing authorization_token in response');\n  }\n\n  return data.authorization_token;\n}\n\n/**\n * Publishes a newly created broadcast (Space) to make it live/visible.\n * Generally invoked after creating the broadcast and initializing Janus.\n */\nexport async function publishBroadcast(params: {\n  title: string;\n  broadcast: BroadcastCreated;\n  cookie: string;\n  janusSessionId?: number;\n  janusHandleId?: number;\n  janusPublisherId?: number;\n}): Promise<void> {\n  const headers = new Headers({\n    'X-Periscope-User-Agent': 'Twitter/m5',\n    'Content-Type': 'application/json',\n    Referer: 'https://x.com/',\n    'X-Idempotence': Date.now().toString(),\n    'X-Attempt': '1',\n  });\n\n  await fetch('https://proxsee.pscp.tv/api/v2/publishBroadcast', {\n    method: 'POST',\n    headers,\n    body: JSON.stringify({\n      accept_guests: true,\n      broadcast_id: params.broadcast.room_id,\n      webrtc_handle_id: params.janusHandleId,\n      webrtc_session_id: params.janusSessionId,\n      janus_publisher_id: params.janusPublisherId,\n      janus_room_id: params.broadcast.room_id,\n      cookie: params.cookie,\n      status: params.title,\n      conversation_controls: 0,\n    }),\n  });\n}\n\n/**\n * Retrieves TURN server credentials and URIs from Periscope.\n */\nexport async function getTurnServers(cookie: string): Promise<TurnServersInfo> {\n  const headers = new Headers({\n    'X-Periscope-User-Agent': 'Twitter/m5',\n    'Content-Type': 'application/json',\n    Referer: 'https://x.com/',\n    'X-Idempotence': Date.now().toString(),\n    'X-Attempt': '1',\n  });\n\n  const resp = await fetch('https://proxsee.pscp.tv/api/v2/turnServers', {\n    method: 'POST',\n    headers,\n    body: JSON.stringify({ cookie }),\n  });\n  if (!resp.ok) {\n    throw new Error(`getTurnServers => request failed with status ${resp.status}`);\n  }\n  return resp.json();\n}\n\n/**\n * Obtains the region from signer.pscp.tv, typically used when creating a broadcast.\n */\nexport async function getRegion(): Promise<string> {\n  const resp = await fetch('https://signer.pscp.tv/region', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Referer: 'https://x.com',\n    },\n    body: JSON.stringify({}),\n  });\n  if (!resp.ok) {\n    throw new Error(`getRegion => request failed with status ${resp.status}`);\n  }\n  const data = (await resp.json()) as { region: string };\n  return data.region;\n}\n\n/**\n * Creates a new broadcast on Periscope/Twitter.\n * Used by the host to create the underlying audio-room structure.\n */\nexport async function createBroadcast(params: {\n  description?: string;\n  languages?: string[];\n  cookie: string;\n  region: string;\n  record: boolean;\n}): Promise<BroadcastCreated> {\n  const headers = new Headers({\n    'X-Periscope-User-Agent': 'Twitter/m5',\n    'Content-Type': 'application/json',\n    'X-Idempotence': Date.now().toString(),\n    Referer: 'https://x.com/',\n    'X-Attempt': '1',\n  });\n\n  const resp = await fetch('https://proxsee.pscp.tv/api/v2/createBroadcast', {\n    method: 'POST',\n    headers,\n    body: JSON.stringify({\n      app_component: 'audio-room',\n      content_type: 'visual_audio',\n      cookie: params.cookie,\n      conversation_controls: 0,\n      description: params.description || '',\n      height: 1080,\n      is_360: false,\n      is_space_available_for_replay: params.record,\n      is_webrtc: true,\n      languages: params.languages ?? [],\n      region: params.region,\n      width: 1920,\n    }),\n  });\n\n  if (!resp.ok) {\n    const text = await resp.text();\n    throw new Error(`createBroadcast => request failed with status ${resp.status} ${text}`);\n  }\n\n  const data = await resp.json();\n  return data as BroadcastCreated;\n}\n\n/**\n * Acquires chat access info (token, endpoint, etc.) from Periscope.\n * Needed to connect via WebSocket to the chat server.\n */\nexport async function accessChat(chatToken: string, cookie: string): Promise<any> {\n  const url = 'https://proxsee.pscp.tv/api/v2/accessChat';\n  const headers = new Headers({\n    'Content-Type': 'application/json',\n    'X-Periscope-User-Agent': 'Twitter/m5',\n  });\n\n  const body = {\n    chat_token: chatToken,\n    cookie,\n  };\n\n  const resp = await fetch(url, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body),\n  });\n  if (!resp.ok) {\n    throw new Error(`accessChat => request failed with status ${resp.status}`);\n  }\n  return resp.json();\n}\n\n/**\n * Registers this client as a viewer (POST /startWatching), returning a watch session token.\n */\nexport async function startWatching(lifecycleToken: string, cookie: string): Promise<string> {\n  const url = 'https://proxsee.pscp.tv/api/v2/startWatching';\n  const headers = new Headers({\n    'Content-Type': 'application/json',\n    'X-Periscope-User-Agent': 'Twitter/m5',\n  });\n\n  const body = {\n    auto_play: false,\n    life_cycle_token: lifecycleToken,\n    cookie,\n  };\n\n  const resp = await fetch(url, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body),\n  });\n  if (!resp.ok) {\n    throw new Error(`startWatching => request failed with status ${resp.status}`);\n  }\n  const json = await resp.json();\n  // Typically returns { session: \"...someToken...\" }\n  return json.session;\n}\n\n/**\n * Deregisters this client from viewing the broadcast (POST /stopWatching).\n */\nexport async function stopWatching(session: string, cookie: string): Promise<void> {\n  const url = 'https://proxsee.pscp.tv/api/v2/stopWatching';\n  const headers = new Headers({\n    'Content-Type': 'application/json',\n    'X-Periscope-User-Agent': 'Twitter/m5',\n  });\n\n  const body = { session, cookie };\n  const resp = await fetch(url, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body),\n  });\n  if (!resp.ok) {\n    throw new Error(`stopWatching => request failed with status ${resp.status}`);\n  }\n}\n\n/**\n * Optional step: join an existing AudioSpace (POST /audiospace/join).\n * This might be required before you can request speaker.\n */\nexport async function joinAudioSpace(params: {\n  broadcastId: string;\n  chatToken: string;\n  authToken: string;\n  joinAsAdmin?: boolean;\n  shouldAutoJoin?: boolean;\n}): Promise<any> {\n  const url = 'https://guest.pscp.tv/api/v1/audiospace/join';\n\n  const body = {\n    ntpForBroadcasterFrame: '2208988800031000000',\n    ntpForLiveFrame: '2208988800031000000',\n    broadcast_id: params.broadcastId,\n    join_as_admin: params.joinAsAdmin ?? false,\n    should_auto_join: params.shouldAutoJoin ?? false,\n    chat_token: params.chatToken,\n  };\n\n  const headers = new Headers({\n    'Content-Type': 'application/json',\n    Authorization: params.authToken,\n  });\n\n  const resp = await fetch(url, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body),\n  });\n\n  if (!resp.ok) {\n    throw new Error(`joinAudioSpace => request failed with status ${resp.status}`);\n  }\n  // Typically returns { can_auto_join: boolean } etc.\n  return resp.json();\n}\n\n/**\n * Submits a speaker request (POST /audiospace/request/submit),\n * returning the session UUID you need for negotiation.\n */\nexport async function submitSpeakerRequest(params: {\n  broadcastId: string;\n  chatToken: string;\n  authToken: string;\n}): Promise<{ session_uuid: string }> {\n  const url = 'https://guest.pscp.tv/api/v1/audiospace/request/submit';\n  const headers = new Headers({\n    'Content-Type': 'application/json',\n    Authorization: params.authToken,\n  });\n\n  const body = {\n    ntpForBroadcasterFrame: '2208988800030000000',\n    ntpForLiveFrame: '2208988800030000000',\n    broadcast_id: params.broadcastId,\n    chat_token: params.chatToken,\n  };\n\n  const resp = await fetch(url, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body),\n  });\n  if (!resp.ok) {\n    throw new Error(`submitSpeakerRequest => request failed with status ${resp.status}`);\n  }\n  return resp.json();\n}\n\n/**\n * Cancels a previously submitted speaker request (POST /audiospace/request/cancel).\n * Only valid if a request/submit was made first with a sessionUUID.\n */\nexport async function cancelSpeakerRequest(params: {\n  broadcastId: string;\n  sessionUUID: string;\n  chatToken: string;\n  authToken: string;\n}): Promise<void> {\n  const url = 'https://guest.pscp.tv/api/v1/audiospace/request/cancel';\n  const headers = new Headers({\n    'Content-Type': 'application/json',\n    Authorization: params.authToken,\n  });\n\n  const body = {\n    ntpForBroadcasterFrame: '2208988800002000000',\n    ntpForLiveFrame: '2208988800002000000',\n    broadcast_id: params.broadcastId,\n    session_uuid: params.sessionUUID,\n    chat_token: params.chatToken,\n  };\n\n  const resp = await fetch(url, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body),\n  });\n  if (!resp.ok) {\n    throw new Error(`cancelSpeakerRequest => request failed with status ${resp.status}`);\n  }\n  // Typically returns { \"success\": true }\n  return resp.json();\n}\n\n/**\n * Negotiates a guest streaming session (POST /audiospace/stream/negotiate),\n * returning a Janus JWT and gateway URL for WebRTC.\n */\nexport async function negotiateGuestStream(params: {\n  broadcastId: string;\n  sessionUUID: string;\n  authToken: string;\n  cookie: string;\n}): Promise<{ janus_jwt: string; webrtc_gw_url: string }> {\n  const url = 'https://guest.pscp.tv/api/v1/audiospace/stream/negotiate';\n  const headers = new Headers({\n    'Content-Type': 'application/json',\n    Authorization: params.authToken,\n  });\n\n  const body = {\n    session_uuid: params.sessionUUID,\n  };\n\n  const resp = await fetch(url, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body),\n  });\n  if (!resp.ok) {\n    throw new Error(`negotiateGuestStream => request failed with status ${resp.status}`);\n  }\n  return resp.json();\n}\n\n/**\n * Mutes a speaker (POST /audiospace/muteSpeaker).\n * If called by the host, sessionUUID is \"\".\n * If called by a speaker, pass your own sessionUUID.\n */\nexport async function muteSpeaker(params: {\n  broadcastId: string;\n  sessionUUID?: string;\n  chatToken: string;\n  authToken: string;\n}): Promise<void> {\n  const url = 'https://guest.pscp.tv/api/v1/audiospace/muteSpeaker';\n\n  const body = {\n    ntpForBroadcasterFrame: 2208988800031000000,\n    ntpForLiveFrame: 2208988800031000000,\n    session_uuid: params.sessionUUID ?? '',\n    broadcast_id: params.broadcastId,\n    chat_token: params.chatToken,\n  };\n\n  const headers = new Headers({\n    'Content-Type': 'application/json',\n    Authorization: params.authToken,\n  });\n\n  const resp = await fetch(url, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body),\n  });\n  if (!resp.ok) {\n    const text = await resp.text();\n    throw new Error(`muteSpeaker => ${resp.status} ${text}`);\n  }\n}\n\n/**\n * Unmutes a speaker (POST /audiospace/unmuteSpeaker).\n * If called by the host, sessionUUID is \"\".\n * If called by a speaker, pass your own sessionUUID.\n */\nexport async function unmuteSpeaker(params: {\n  broadcastId: string;\n  sessionUUID?: string;\n  chatToken: string;\n  authToken: string;\n}): Promise<void> {\n  const url = 'https://guest.pscp.tv/api/v1/audiospace/unmuteSpeaker';\n\n  const body = {\n    ntpForBroadcasterFrame: 2208988800031000000,\n    ntpForLiveFrame: 2208988800031000000,\n    session_uuid: params.sessionUUID ?? '',\n    broadcast_id: params.broadcastId,\n    chat_token: params.chatToken,\n  };\n\n  const headers = new Headers({\n    'Content-Type': 'application/json',\n    Authorization: params.authToken,\n  });\n\n  const resp = await fetch(url, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body),\n  });\n  if (!resp.ok) {\n    const text = await resp.text();\n    throw new Error(`unmuteSpeaker => ${resp.status} ${text}`);\n  }\n}\n\n/**\n * Common chat events helper. Attaches listeners to a ChatClient, then re-emits them\n * through a given EventEmitter (e.g. Space or SpaceParticipant).\n */\nexport function setupCommonChatEvents(\n  chatClient: ChatClient,\n  logger: Logger,\n  emitter: EventEmitter\n): void {\n  // Occupancy updates\n  chatClient.on('occupancyUpdate', (upd) => {\n    logger.debug('[ChatEvents] occupancyUpdate =>', upd);\n    emitter.emit('occupancyUpdate', upd);\n  });\n\n  // Reaction events\n  chatClient.on('guestReaction', (reaction) => {\n    logger.debug('[ChatEvents] guestReaction =>', reaction);\n    emitter.emit('guestReaction', reaction);\n  });\n\n  // Mute state changes\n  chatClient.on('muteStateChanged', (evt) => {\n    logger.debug('[ChatEvents] muteStateChanged =>', evt);\n    emitter.emit('muteStateChanged', evt);\n  });\n\n  // Speaker requests\n  chatClient.on('speakerRequest', (req) => {\n    logger.debug('[ChatEvents] speakerRequest =>', req);\n    emitter.emit('speakerRequest', req);\n  });\n\n  // Additional event example: new speaker accepted\n  chatClient.on('newSpeakerAccepted', (info) => {\n    logger.debug('[ChatEvents] newSpeakerAccepted =>', info);\n    emitter.emit('newSpeakerAccepted', info);\n  });\n\n  chatClient.on('newSpeakerRemoved', (info) => {\n    logger.debug('[ChatEvents] newSpeakerRemoved =>', info);\n    emitter.emit('newSpeakerRemoved', info);\n  });\n}\n","// src/core/ChatClient.ts\n\nimport { EventEmitter } from 'node:events';\nimport WebSocket from 'ws';\nimport type { Logger } from '../logger';\nimport type { OccupancyUpdate, SpeakerRequest } from '../types';\n\n/**\n * Configuration object for ChatClient.\n */\n/**\n * @typedef {Object} ChatClientConfig\n * @property {string} spaceId - The space ID (e.g., \"1vOGwAbcdE...\") for this audio space.\n * @property {string} accessToken - The access token obtained from accessChat or the live_video_stream/status.\n * @property {string} endpoint - The endpoint host for the chat server (e.g., \"https://prod-chatman-ancillary-eu-central-1.pscp.tv\").\n * @property {Logger} logger - An instance of Logger for debug/info logs.\n */\ninterface ChatClientConfig {\n  /**\n   * The space ID (e.g., \"1vOGwAbcdE...\") for this audio space.\n   */\n  spaceId: string;\n\n  /**\n   * The access token obtained from accessChat or the live_video_stream/status.\n   */\n  accessToken: string;\n\n  /**\n   * The endpoint host for the chat server (e.g., \"https://prod-chatman-ancillary-eu-central-1.pscp.tv\").\n   */\n  endpoint: string;\n\n  /**\n   * An instance of Logger for debug/info logs.\n   */\n  logger: Logger;\n}\n\n/**\n * ChatClient handles the WebSocket connection to the Twitter/Periscope chat API.\n * It emits events such as \"speakerRequest\", \"occupancyUpdate\", \"muteStateChanged\", etc.\n */\nexport class ChatClient extends EventEmitter {\n  private ws?: WebSocket;\n  private connected = false;\n\n  private readonly logger: Logger;\n  private readonly spaceId: string;\n  private readonly accessToken: string;\n  private endpoint: string;\n\n  constructor(config: ChatClientConfig) {\n    super();\n    this.spaceId = config.spaceId;\n    this.accessToken = config.accessToken;\n    this.endpoint = config.endpoint;\n    this.logger = config.logger;\n  }\n\n  /**\n   * Establishes a WebSocket connection to the chat endpoint and sets up event handlers.\n   */\n  public async connect(): Promise<void> {\n    const wsUrl = `${this.endpoint}/chatapi/v1/chatnow`.replace('https://', 'wss://');\n    this.logger.info('[ChatClient] Connecting =>', wsUrl);\n\n    this.ws = new WebSocket(wsUrl, {\n      headers: {\n        Origin: 'https://x.com',\n        'User-Agent': 'Mozilla/5.0',\n      },\n    });\n\n    await this.setupHandlers();\n  }\n\n  /**\n   * Internal method to set up WebSocket event listeners (open, message, close, error).\n   */\n  private setupHandlers(): Promise<void> {\n    if (!this.ws) {\n      throw new Error('[ChatClient] No WebSocket instance available');\n    }\n\n    return new Promise((resolve, reject) => {\n      this.ws?.on('open', () => {\n        this.logger.info('[ChatClient] Connected');\n        this.connected = true;\n        this.sendAuthAndJoin();\n        resolve();\n      });\n\n      this.ws?.on('message', (data: { toString: () => string }) => {\n        this.handleMessage(data.toString());\n      });\n\n      this.ws?.on('close', () => {\n        this.logger.info('[ChatClient] Closed');\n        this.connected = false;\n        this.emit('disconnected');\n      });\n\n      this.ws?.on('error', (err) => {\n        this.logger.error('[ChatClient] Error =>', err);\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * Sends two WebSocket messages to authenticate and join the specified space.\n   */\n  private sendAuthAndJoin(): void {\n    if (!this.ws) return;\n\n    // 1) Send authentication (access token)\n    this.ws.send(\n      JSON.stringify({\n        payload: JSON.stringify({ access_token: this.accessToken }),\n        kind: 3,\n      })\n    );\n\n    // 2) Send a \"join\" message specifying the room (space ID)\n    this.ws.send(\n      JSON.stringify({\n        payload: JSON.stringify({\n          body: JSON.stringify({ room: this.spaceId }),\n          kind: 1,\n        }),\n        kind: 2,\n      })\n    );\n  }\n\n  /**\n   * Sends an emoji reaction to the chat server.\n   * @param emoji - The emoji string, e.g. '🔥', '🙏', etc.\n   */\n  public reactWithEmoji(emoji: string): void {\n    if (!this.ws || !this.connected) {\n      this.logger.warn('[ChatClient] Not connected or WebSocket missing; ignoring reactWithEmoji.');\n      return;\n    }\n\n    const payload = JSON.stringify({\n      body: JSON.stringify({ body: emoji, type: 2, v: 2 }),\n      kind: 1,\n      /*\n      // The 'sender' field is not required, it's not even verified by the server\n      // Instead of passing attributes down here it's easier to ignore it\n      sender: {\n        user_id: null,\n        twitter_id: null,\n        username: null,\n        display_name: null,\n      },\n      */\n      payload: JSON.stringify({\n        room: this.spaceId,\n        body: JSON.stringify({ body: emoji, type: 2, v: 2 }),\n      }),\n      type: 2,\n    });\n\n    this.ws.send(payload);\n  }\n\n  /**\n   * Handles inbound WebSocket messages, parsing JSON payloads\n   * and emitting relevant events (speakerRequest, occupancyUpdate, etc.).\n   */\n  private handleMessage(raw: string): void {\n    let msg: any;\n    try {\n      msg = JSON.parse(raw);\n    } catch {\n      return; // Invalid JSON, ignoring\n    }\n    if (!msg.payload) return;\n\n    const payload = safeJson(msg.payload);\n    if (!payload?.body) return;\n\n    const body = safeJson(payload.body);\n\n    // 1) Speaker request => \"guestBroadcastingEvent=1\"\n    if (body.guestBroadcastingEvent === 1) {\n      const req: SpeakerRequest = {\n        userId: body.guestRemoteID,\n        username: body.guestUsername,\n        displayName: payload.sender?.display_name || body.guestUsername,\n        sessionUUID: body.sessionUUID,\n      };\n      this.emit('speakerRequest', req);\n    }\n\n    // 2) Occupancy update => body.occupancy\n    if (typeof body.occupancy === 'number') {\n      const update: OccupancyUpdate = {\n        occupancy: body.occupancy,\n        totalParticipants: body.total_participants || 0,\n      };\n      this.emit('occupancyUpdate', update);\n    }\n\n    // 3) Mute/unmute => \"guestBroadcastingEvent=16\" (mute) or \"17\" (unmute)\n    if (body.guestBroadcastingEvent === 16) {\n      this.emit('muteStateChanged', {\n        userId: body.guestRemoteID,\n        muted: true,\n      });\n    }\n    if (body.guestBroadcastingEvent === 17) {\n      this.emit('muteStateChanged', {\n        userId: body.guestRemoteID,\n        muted: false,\n      });\n    }\n\n    // 4) \"guestBroadcastingEvent=12\" => host accepted a speaker\n    if (body.guestBroadcastingEvent === 12) {\n      this.emit('newSpeakerAccepted', {\n        userId: body.guestRemoteID,\n        username: body.guestUsername,\n        sessionUUID: body.sessionUUID,\n      });\n    }\n\n    // 5) \"guestBroadcastingEvent=10\" => host removed a speaker\n    if (body.guestBroadcastingEvent === 10) {\n      this.emit('newSpeakerRemoved', {\n        userId: body.guestRemoteID,\n        username: body.guestUsername,\n        sessionUUID: body.sessionUUID,\n      });\n    }\n\n    // 6) Reaction => body.type=2\n    if (body?.type === 2) {\n      this.logger.debug('[ChatClient] Emitting guestReaction =>', body);\n      this.emit('guestReaction', {\n        displayName: body.displayName,\n        emoji: body.body,\n      });\n    }\n  }\n\n  /**\n   * Closes the WebSocket connection if open, and resets internal state.\n   */\n  public async disconnect(): Promise<void> {\n    if (this.ws) {\n      this.logger.info('[ChatClient] Disconnecting...');\n      this.ws.close();\n      this.ws = undefined;\n      this.connected = false;\n    }\n  }\n}\n\n/**\n * Helper function to safely parse JSON without throwing.\n */\nfunction safeJson(text: string): any {\n  try {\n    return JSON.parse(text);\n  } catch {\n    return null;\n  }\n}\n","// src/core/JanusClient.ts\n\nimport { EventEmitter } from 'node:events';\nimport wrtc from '@roamhq/wrtc';\nconst { RTCPeerConnection, MediaStream } = wrtc;\nimport type { Logger } from '../logger';\nimport type { AudioDataWithUser, TurnServersInfo } from '../types';\nimport { JanusAudioSink, JanusAudioSource } from './JanusAudio';\n\n/**\n * Interface representing the configuration settings for the Janus gateway.\n * @typedef {Object} JanusConfig\n * @property {string} webrtcUrl - The base URL for the Janus gateway.\n * @property {string} roomId - The unique room ID.\n * @property {string} credential - The token/credential used to authorize requests to Janus.\n * @property {string} userId - The user identifier (host or speaker).\n * @property {string} streamName - The name of the stream.\n * @property {TurnServersInfo} turnServers - ICE/TURN server information returned by Twitter's /turnServers endpoint.\n * @property {Logger} logger - Logger instance for consistent debug/info/error logs.\n */\ninterface JanusConfig {\n  /**\n   * The base URL for the Janus gateway (e.g. \"https://gw-prod-hydra-eu-west-3.pscp.tv/s=prod:XX/v1/gateway\")\n   */\n  webrtcUrl: string;\n\n  /**\n   * The unique room ID (e.g., the broadcast or space ID)\n   */\n  roomId: string;\n\n  /**\n   * The token/credential used to authorize requests to Janus (often a signed JWT).\n   */\n  credential: string;\n\n  /**\n   * The user identifier (host or speaker). Used as 'display' in the Janus plugin.\n   */\n  userId: string;\n\n  /**\n   * The name of the stream (often the same as roomId for convenience).\n   */\n  streamName: string;\n\n  /**\n   * ICE / TURN server information returned by Twitter's /turnServers endpoint.\n   */\n  turnServers: TurnServersInfo;\n\n  /**\n   * Logger instance for consistent debug/info/error logs.\n   */\n  logger: Logger;\n}\n\n/**\n * Manages the Janus session for a Twitter AudioSpace:\n *  - Creates a Janus session and plugin handle\n *  - Joins the Janus videoroom as publisher/subscriber\n *  - Subscribes to other speakers\n *  - Sends local PCM frames as Opus\n *  - Polls for Janus events\n *\n * It can be used by both the host (who creates a room) or a guest speaker (who joins an existing room).\n */\nexport class JanusClient extends EventEmitter {\n  private logger: Logger;\n\n  private sessionId?: number;\n  private handleId?: number;\n  private publisherId?: number;\n\n  private pc?: RTCPeerConnection;\n  private localAudioSource?: JanusAudioSource;\n\n  private pollActive = false;\n\n  // Tracks promises waiting for specific Janus events\n  private eventWaiters: Array<{\n    predicate: (evt: any) => boolean;\n    resolve: (value: any) => void;\n    reject: (error: Error) => void;\n  }> = [];\n\n  // Tracks subscriber handle+pc for each userId we subscribe to\n  private subscribers = new Map<\n    string,\n    {\n      handleId: number;\n      pc: RTCPeerConnection;\n    }\n  >();\n\n  constructor(private readonly config: JanusConfig) {\n    super();\n    this.logger = config.logger;\n  }\n\n  /**\n   * Initializes this JanusClient for the host scenario:\n   *  1) createSession()\n   *  2) attachPlugin()\n   *  3) createRoom()\n   *  4) joinRoom()\n   *  5) configure local PeerConnection (send audio, etc.)\n   */\n  public async initialize(): Promise<void> {\n    this.logger.debug('[JanusClient] initialize() called');\n\n    this.sessionId = await this.createSession();\n    this.handleId = await this.attachPlugin();\n\n    // Start polling for Janus events\n    this.pollActive = true;\n    this.startPolling();\n\n    // Create a new Janus room (only for the host scenario)\n    await this.createRoom();\n\n    // Join that room as publisher\n    this.publisherId = await this.joinRoom();\n\n    // Set up our RTCPeerConnection for local audio\n    this.pc = new RTCPeerConnection({\n      iceServers: [\n        {\n          urls: this.config.turnServers.uris,\n          username: this.config.turnServers.username,\n          credential: this.config.turnServers.password,\n        },\n      ],\n    });\n    this.setupPeerEvents();\n\n    // Add local audio track\n    this.enableLocalAudio();\n\n    // Create an offer and configure the publisher in Janus\n    await this.configurePublisher();\n\n    this.logger.info('[JanusClient] Initialization complete');\n  }\n\n  /**\n   * Initializes this JanusClient for a guest speaker scenario:\n   *  1) createSession()\n   *  2) attachPlugin()\n   *  3) join existing room as publisher (no createRoom call)\n   *  4) configure local PeerConnection\n   *  5) subscribe to any existing publishers\n   */\n  public async initializeGuestSpeaker(sessionUUID: string): Promise<void> {\n    this.logger.debug('[JanusClient] initializeGuestSpeaker() called');\n\n    // 1) Create a new Janus session\n    this.sessionId = await this.createSession();\n    this.handleId = await this.attachPlugin();\n\n    // Start polling\n    this.pollActive = true;\n    this.startPolling();\n\n    // 2) Join the existing room as a publisher (no createRoom)\n    const evtPromise = this.waitForJanusEvent(\n      (e) =>\n        e.janus === 'event' &&\n        e.plugindata?.plugin === 'janus.plugin.videoroom' &&\n        e.plugindata?.data?.videoroom === 'joined',\n      10000,\n      'Guest Speaker joined event'\n    );\n\n    const body = {\n      request: 'join',\n      room: this.config.roomId,\n      ptype: 'publisher',\n      display: this.config.userId,\n      periscope_user_id: this.config.userId,\n    };\n    await this.sendJanusMessage(this.handleId, body);\n\n    // Wait for the joined event\n    const evt = await evtPromise;\n    const data = evt.plugindata?.data;\n    this.publisherId = data.id; // Our own publisherId\n    this.logger.debug('[JanusClient] guest joined => publisherId=', this.publisherId);\n\n    // If there are existing publishers, we can subscribe to them\n    const publishers = data.publishers || [];\n    this.logger.debug('[JanusClient] existing publishers =>', publishers);\n\n    // 3) Create RTCPeerConnection for sending local audio\n    this.pc = new RTCPeerConnection({\n      iceServers: [\n        {\n          urls: this.config.turnServers.uris,\n          username: this.config.turnServers.username,\n          credential: this.config.turnServers.password,\n        },\n      ],\n    });\n    this.setupPeerEvents();\n    this.enableLocalAudio();\n\n    // 4) configurePublisher => generate offer, wait for answer\n    await this.configurePublisher(sessionUUID);\n\n    // 5) Subscribe to each existing publisher\n    await Promise.all(publishers.map((pub: any) => this.subscribeSpeaker(pub.display, pub.id)));\n\n    this.logger.info('[JanusClient] Guest speaker negotiation complete');\n  }\n\n  /**\n   * Subscribes to a speaker's audio feed by userId and/or feedId.\n   * If feedId=0, we wait for a \"publishers\" event to discover feedId.\n   */\n  public async subscribeSpeaker(userId: string, feedId = 0): Promise<void> {\n    this.logger.debug('[JanusClient] subscribeSpeaker => userId=', userId);\n\n    // 1) Attach a separate plugin handle for subscriber\n    const subscriberHandleId = await this.attachPlugin();\n    this.logger.debug('[JanusClient] subscriber handle =>', subscriberHandleId);\n\n    // If feedId was not provided, wait for an event listing publishers\n    if (feedId === 0) {\n      const publishersEvt = await this.waitForJanusEvent(\n        (e) =>\n          e.janus === 'event' &&\n          e.plugindata?.plugin === 'janus.plugin.videoroom' &&\n          e.plugindata?.data?.videoroom === 'event' &&\n          Array.isArray(e.plugindata?.data?.publishers) &&\n          e.plugindata?.data?.publishers.length > 0,\n        8000,\n        'discover feed_id from \"publishers\"'\n      );\n\n      const list = publishersEvt.plugindata.data.publishers as any[];\n      const pub = list.find((p) => p.display === userId || p.periscope_user_id === userId);\n      if (!pub) {\n        throw new Error(\n          `[JanusClient] subscribeSpeaker => No publisher found for userId=${userId}`\n        );\n      }\n      feedId = pub.id;\n      this.logger.debug('[JanusClient] found feedId =>', feedId);\n    }\n\n    // Notify listeners that we've discovered a feed\n    this.emit('subscribedSpeaker', { userId, feedId });\n\n    // 2) Join the room as a \"subscriber\"\n    const joinBody = {\n      request: 'join',\n      room: this.config.roomId,\n      periscope_user_id: this.config.userId,\n      ptype: 'subscriber',\n      streams: [\n        {\n          feed: feedId,\n          mid: '0',\n          send: true, // indicates we might send audio?\n        },\n      ],\n    };\n    await this.sendJanusMessage(subscriberHandleId, joinBody);\n\n    // 3) Wait for \"attached\" + jsep.offer\n    const attachedEvt = await this.waitForJanusEvent(\n      (e) =>\n        e.janus === 'event' &&\n        e.sender === subscriberHandleId &&\n        e.plugindata?.plugin === 'janus.plugin.videoroom' &&\n        e.plugindata?.data?.videoroom === 'attached' &&\n        e.jsep?.type === 'offer',\n      8000,\n      'subscriber attached + offer'\n    );\n    this.logger.debug('[JanusClient] subscriber => \"attached\" with offer');\n\n    // 4) Create a new RTCPeerConnection for receiving audio from this feed\n    const offer = attachedEvt.jsep;\n    const subPc = new RTCPeerConnection({\n      iceServers: [\n        {\n          urls: this.config.turnServers.uris,\n          username: this.config.turnServers.username,\n          credential: this.config.turnServers.password,\n        },\n      ],\n    });\n\n    subPc.ontrack = (evt) => {\n      this.logger.debug(\n        '[JanusClient] subscriber track => kind=%s, readyState=%s, muted=%s',\n        evt.track.kind,\n        evt.track.readyState,\n        evt.track.muted\n      );\n      // Attach a JanusAudioSink to capture PCM\n      const sink = new JanusAudioSink(evt.track, { logger: this.logger });\n\n      // For each audio frame, forward it to 'audioDataFromSpeaker'\n      sink.on('audioData', (frame) => {\n        if (this.logger.isDebugEnabled()) {\n          let maxVal = 0;\n          for (let i = 0; i < frame.samples.length; i++) {\n            const val = Math.abs(frame.samples[i]);\n            if (val > maxVal) maxVal = val;\n          }\n          this.logger.debug(`[AudioSink] userId=${userId}, maxAmplitude=${maxVal}`);\n        }\n\n        this.emit('audioDataFromSpeaker', {\n          userId,\n          bitsPerSample: frame.bitsPerSample,\n          sampleRate: frame.sampleRate,\n          numberOfFrames: frame.numberOfFrames,\n          channelCount: frame.channelCount,\n          samples: frame.samples,\n        } as AudioDataWithUser);\n      });\n    };\n\n    // 5) Answer the subscription offer\n    await subPc.setRemoteDescription(offer);\n    const answer = await subPc.createAnswer();\n    await subPc.setLocalDescription(answer);\n\n    // 6) Send \"start\" request to begin receiving\n    await this.sendJanusMessage(\n      subscriberHandleId,\n      {\n        request: 'start',\n        room: this.config.roomId,\n        periscope_user_id: this.config.userId,\n      },\n      answer\n    );\n\n    this.logger.debug('[JanusClient] subscriber => done (user=', userId, ')');\n\n    // Track this subscription handle+pc by userId\n    this.subscribers.set(userId, { handleId: subscriberHandleId, pc: subPc });\n  }\n\n  /**\n   * Pushes local PCM frames to Janus. If the localAudioSource isn't active, it enables it.\n   */\n  public pushLocalAudio(samples: Int16Array, sampleRate: number, channels = 1) {\n    if (!this.localAudioSource) {\n      this.logger.warn('[JanusClient] No localAudioSource => enabling now...');\n      this.enableLocalAudio();\n    }\n    this.localAudioSource?.pushPcmData(samples, sampleRate, channels);\n  }\n\n  /**\n   * Ensures a local audio track is added to the RTCPeerConnection for publishing.\n   */\n  public enableLocalAudio(): void {\n    if (!this.pc) {\n      this.logger.warn('[JanusClient] enableLocalAudio => No RTCPeerConnection');\n      return;\n    }\n    if (this.localAudioSource) {\n      this.logger.debug('[JanusClient] localAudioSource already active');\n      return;\n    }\n    // Create a JanusAudioSource that feeds PCM frames\n    this.localAudioSource = new JanusAudioSource({ logger: this.logger });\n    const track = this.localAudioSource.getTrack();\n    const localStream = new MediaStream();\n    localStream.addTrack(track);\n    this.pc.addTrack(track, localStream);\n  }\n\n  /**\n   * Stops the Janus client: ends polling, closes the RTCPeerConnection, etc.\n   * Does not destroy or leave the room automatically; call destroyRoom() or leaveRoom() if needed.\n   */\n  public async stop(): Promise<void> {\n    this.logger.info('[JanusClient] Stopping...');\n    this.pollActive = false;\n    if (this.pc) {\n      this.pc.close();\n      this.pc = undefined;\n    }\n  }\n\n  /**\n   * Returns the current Janus sessionId, if any.\n   */\n  public getSessionId(): number | undefined {\n    return this.sessionId;\n  }\n\n  /**\n   * Returns the Janus handleId for the publisher, if any.\n   */\n  public getHandleId(): number | undefined {\n    return this.handleId;\n  }\n\n  /**\n   * Returns the Janus publisherId (internal participant ID), if any.\n   */\n  public getPublisherId(): number | undefined {\n    return this.publisherId;\n  }\n\n  /**\n   * Creates a new Janus session via POST /janus (with \"janus\":\"create\").\n   */\n  private async createSession(): Promise<number> {\n    const transaction = this.randomTid();\n    const resp = await fetch(this.config.webrtcUrl, {\n      method: 'POST',\n      headers: {\n        Authorization: this.config.credential,\n        'Content-Type': 'application/json',\n        Referer: 'https://x.com',\n      },\n      body: JSON.stringify({\n        janus: 'create',\n        transaction,\n      }),\n    });\n    if (!resp.ok) {\n      throw new Error('[JanusClient] createSession failed');\n    }\n    const json = await resp.json();\n    if (json.janus !== 'success') {\n      throw new Error('[JanusClient] createSession invalid response');\n    }\n    return json.data.id;\n  }\n\n  /**\n   * Attaches to the videoroom plugin via /janus/{sessionId} (with \"janus\":\"attach\").\n   */\n  private async attachPlugin(): Promise<number> {\n    if (!this.sessionId) {\n      throw new Error('[JanusClient] attachPlugin => no sessionId');\n    }\n    const transaction = this.randomTid();\n    const resp = await fetch(`${this.config.webrtcUrl}/${this.sessionId}`, {\n      method: 'POST',\n      headers: {\n        Authorization: this.config.credential,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        janus: 'attach',\n        plugin: 'janus.plugin.videoroom',\n        transaction,\n      }),\n    });\n    if (!resp.ok) {\n      throw new Error('[JanusClient] attachPlugin failed');\n    }\n    const json = await resp.json();\n    if (json.janus !== 'success') {\n      throw new Error('[JanusClient] attachPlugin invalid response');\n    }\n    return json.data.id;\n  }\n\n  /**\n   * Creates a Janus room for the host scenario.\n   * For a guest, this step is skipped (the room already exists).\n   */\n  private async createRoom(): Promise<void> {\n    if (!this.sessionId || !this.handleId) {\n      throw new Error('[JanusClient] createRoom => No session/handle');\n    }\n    const transaction = this.randomTid();\n    const body = {\n      request: 'create',\n      room: this.config.roomId,\n      periscope_user_id: this.config.userId,\n      audiocodec: 'opus',\n      videocodec: 'h264',\n      transport_wide_cc_ext: true,\n      app_component: 'audio-room',\n      h264_profile: '42e01f',\n      dummy_publisher: false,\n    };\n    const resp = await fetch(`${this.config.webrtcUrl}/${this.sessionId}/${this.handleId}`, {\n      method: 'POST',\n      headers: {\n        Authorization: this.config.credential,\n        'Content-Type': 'application/json',\n        Referer: 'https://x.com',\n      },\n      body: JSON.stringify({\n        janus: 'message',\n        transaction,\n        body,\n      }),\n    });\n    if (!resp.ok) {\n      throw new Error(`[JanusClient] createRoom failed => ${resp.status}`);\n    }\n    const json = await resp.json();\n    this.logger.debug('[JanusClient] createRoom =>', JSON.stringify(json));\n\n    if (json.janus === 'error') {\n      throw new Error(`[JanusClient] createRoom error => ${json.error?.reason || 'Unknown'}`);\n    }\n    if (json.plugindata?.data?.videoroom !== 'created') {\n      throw new Error(`[JanusClient] unexpected createRoom response => ${JSON.stringify(json)}`);\n    }\n    this.logger.debug(`[JanusClient] Room '${this.config.roomId}' created successfully`);\n  }\n\n  /**\n   * Joins the created room as a publisher, for the host scenario.\n   */\n  private async joinRoom(): Promise<number> {\n    if (!this.sessionId || !this.handleId) {\n      throw new Error('[JanusClient] no session/handle for joinRoom()');\n    }\n\n    this.logger.debug('[JanusClient] joinRoom => start');\n\n    // Wait for the 'joined' event from videoroom\n    const evtPromise = this.waitForJanusEvent(\n      (e) =>\n        e.janus === 'event' &&\n        e.plugindata?.plugin === 'janus.plugin.videoroom' &&\n        e.plugindata?.data?.videoroom === 'joined',\n      12000,\n      'Host Joined Event'\n    );\n\n    const body = {\n      request: 'join',\n      room: this.config.roomId,\n      ptype: 'publisher',\n      display: this.config.userId,\n      periscope_user_id: this.config.userId,\n    };\n    await this.sendJanusMessage(this.handleId, body);\n\n    const evt = await evtPromise;\n    const publisherId = evt.plugindata.data.id;\n    this.logger.debug('[JanusClient] joined room => publisherId=', publisherId);\n    return publisherId;\n  }\n\n  /**\n   * Creates an SDP offer and sends \"configure\" to Janus with it.\n   * Used by both host and guest after attach + join.\n   */\n  private async configurePublisher(sessionUUID = ''): Promise<void> {\n    if (!this.pc || !this.sessionId || !this.handleId) {\n      return;\n    }\n\n    this.logger.debug('[JanusClient] createOffer...');\n    const offer = await this.pc.createOffer({\n      offerToReceiveAudio: true,\n      offerToReceiveVideo: false,\n    });\n    await this.pc.setLocalDescription(offer);\n\n    this.logger.debug('[JanusClient] sending configure with JSEP...');\n    await this.sendJanusMessage(\n      this.handleId,\n      {\n        request: 'configure',\n        room: this.config.roomId,\n        periscope_user_id: this.config.userId,\n        session_uuid: sessionUUID,\n        stream_name: this.config.streamName,\n        vidman_token: this.config.credential,\n      },\n      offer\n    );\n    this.logger.debug('[JanusClient] waiting for answer...');\n  }\n\n  /**\n   * Sends a \"janus\":\"message\" to the Janus handle, optionally with jsep.\n   */\n  private async sendJanusMessage(handleId: number, body: any, jsep?: any): Promise<void> {\n    if (!this.sessionId) {\n      throw new Error('[JanusClient] No session for sendJanusMessage');\n    }\n    const transaction = this.randomTid();\n    const resp = await fetch(`${this.config.webrtcUrl}/${this.sessionId}/${handleId}`, {\n      method: 'POST',\n      headers: {\n        Authorization: this.config.credential,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        janus: 'message',\n        transaction,\n        body,\n        jsep,\n      }),\n    });\n    if (!resp.ok) {\n      throw new Error(`[JanusClient] sendJanusMessage failed => status=${resp.status}`);\n    }\n  }\n\n  /**\n   * Starts polling /janus/{sessionId}?maxev=1 for events. We parse keepalives, answers, etc.\n   */\n  private startPolling(): void {\n    this.logger.debug('[JanusClient] Starting polling...');\n    const doPoll = async () => {\n      if (!this.pollActive || !this.sessionId) {\n        this.logger.debug('[JanusClient] Polling stopped');\n        return;\n      }\n      try {\n        const url = `${this.config.webrtcUrl}/${this.sessionId}?maxev=1&_=${Date.now()}`;\n        const resp = await fetch(url, {\n          headers: { Authorization: this.config.credential },\n        });\n        if (resp.ok) {\n          const event = await resp.json();\n          this.handleJanusEvent(event);\n        } else {\n          this.logger.warn('[JanusClient] poll error =>', resp.status);\n        }\n      } catch (err) {\n        this.logger.error('[JanusClient] poll exception =>', err);\n      }\n      setTimeout(doPoll, 500);\n    };\n    doPoll();\n  }\n\n  /**\n   * Processes each Janus event received from the poll cycle.\n   */\n  private handleJanusEvent(evt: any): void {\n    if (!evt.janus) {\n      return;\n    }\n    if (evt.janus === 'keepalive') {\n      this.logger.debug('[JanusClient] keepalive received');\n      return;\n    }\n    if (evt.janus === 'webrtcup') {\n      this.logger.debug('[JanusClient] webrtcup => sender=', evt.sender);\n    }\n    // If there's a JSEP answer, set it on our RTCPeerConnection\n    if (evt.jsep && evt.jsep.type === 'answer') {\n      this.onReceivedAnswer(evt.jsep);\n    }\n    // If there's a publisherId in the data, store it\n    if (evt.plugindata?.data?.id) {\n      this.publisherId = evt.plugindata.data.id;\n    }\n    // If there's an error, emit an 'error' event\n    if (evt.error) {\n      this.logger.error('[JanusClient] Janus error =>', evt.error.reason);\n      this.emit('error', new Error(evt.error.reason));\n    }\n\n    // Resolve any waiting eventWaiters whose predicate matches\n    for (let i = 0; i < this.eventWaiters.length; i++) {\n      const waiter = this.eventWaiters[i];\n      if (waiter.predicate(evt)) {\n        this.eventWaiters.splice(i, 1);\n        waiter.resolve(evt);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Called whenever we get an SDP \"answer\" from Janus. Sets the remote description on our PC.\n   */\n  private async onReceivedAnswer(answer: any): Promise<void> {\n    if (!this.pc) {\n      return;\n    }\n    this.logger.debug('[JanusClient] got answer => setRemoteDescription');\n    await this.pc.setRemoteDescription(answer);\n  }\n\n  /**\n   * Sets up events on our main RTCPeerConnection for ICE changes, track additions, etc.\n   */\n  private setupPeerEvents(): void {\n    if (!this.pc) {\n      return;\n    }\n    this.pc.addEventListener('iceconnectionstatechange', () => {\n      this.logger.debug('[JanusClient] ICE state =>', this.pc?.iceConnectionState);\n      if (this.pc?.iceConnectionState === 'failed') {\n        this.emit('error', new Error('[JanusClient] ICE connection failed'));\n      }\n    });\n    this.pc.addEventListener('track', (evt) => {\n      this.logger.debug('[JanusClient] ontrack => kind=', evt.track.kind);\n    });\n  }\n\n  /**\n   * Generates a random transaction ID for Janus requests.\n   */\n  private randomTid(): string {\n    return Math.random().toString(36).slice(2, 10);\n  }\n\n  /**\n   * Waits for a specific Janus event (e.g., \"joined\", \"attached\", etc.)\n   * that matches a given predicate. Times out after timeoutMs if not received.\n   */\n  private async waitForJanusEvent(\n    predicate: (evt: any) => boolean,\n    timeoutMs = 5000,\n    description = 'some event'\n  ): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const waiter = { predicate, resolve, reject };\n      this.eventWaiters.push(waiter);\n\n      setTimeout(() => {\n        const idx = this.eventWaiters.indexOf(waiter);\n        if (idx !== -1) {\n          this.eventWaiters.splice(idx, 1);\n          this.logger.warn(\n            `[JanusClient] waitForJanusEvent => timed out waiting for: ${description}`\n          );\n          reject(\n            new Error(\n              `[JanusClient] waitForJanusEvent (expecting \"${description}\") timed out after ${timeoutMs}ms`\n            )\n          );\n        }\n      }, timeoutMs);\n    });\n  }\n\n  /**\n   * Destroys the Janus room (host only). Does not close local PC or stop polling.\n   */\n  public async destroyRoom(): Promise<void> {\n    if (!this.sessionId || !this.handleId) {\n      this.logger.warn('[JanusClient] destroyRoom => no session/handle');\n      return;\n    }\n    if (!this.config.roomId || !this.config.userId) {\n      this.logger.warn('[JanusClient] destroyRoom => no roomId/userId');\n      return;\n    }\n\n    const transaction = this.randomTid();\n    const body = {\n      request: 'destroy',\n      room: this.config.roomId,\n      periscope_user_id: this.config.userId,\n    };\n    this.logger.info('[JanusClient] destroying room =>', body);\n\n    const resp = await fetch(`${this.config.webrtcUrl}/${this.sessionId}/${this.handleId}`, {\n      method: 'POST',\n      headers: {\n        Authorization: this.config.credential,\n        'Content-Type': 'application/json',\n        Referer: 'https://x.com',\n      },\n      body: JSON.stringify({\n        janus: 'message',\n        transaction,\n        body,\n      }),\n    });\n    if (!resp.ok) {\n      throw new Error(`[JanusClient] destroyRoom failed => ${resp.status}`);\n    }\n    const json = await resp.json();\n    this.logger.debug('[JanusClient] destroyRoom =>', JSON.stringify(json));\n  }\n\n  /**\n   * Leaves the Janus room if we've joined. Does not close the local PC or stop polling.\n   */\n  public async leaveRoom(): Promise<void> {\n    if (!this.sessionId || !this.handleId) {\n      this.logger.warn('[JanusClient] leaveRoom => no session/handle');\n      return;\n    }\n    const transaction = this.randomTid();\n    const body = {\n      request: 'leave',\n      room: this.config.roomId,\n      periscope_user_id: this.config.userId,\n    };\n    this.logger.info('[JanusClient] leaving room =>', body);\n\n    const resp = await fetch(`${this.config.webrtcUrl}/${this.sessionId}/${this.handleId}`, {\n      method: 'POST',\n      headers: {\n        Authorization: this.config.credential,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        janus: 'message',\n        transaction,\n        body,\n      }),\n    });\n    if (!resp.ok) {\n      throw new Error(`[JanusClient] leaveRoom => error code ${resp.status}`);\n    }\n    const json = await resp.json();\n    this.logger.debug('[JanusClient] leaveRoom =>', JSON.stringify(json));\n  }\n}\n","// src/core/JanusAudio.ts\n\nimport { EventEmitter } from 'node:events';\nimport wrtc from '@roamhq/wrtc';\nconst { nonstandard } = wrtc;\nconst { RTCAudioSource, RTCAudioSink } = nonstandard;\nimport type { Logger } from '../logger';\n\n/**\n * Configuration options for the JanusAudioSource.\n */\n/**\n * Optional logger instance for debug/info/warn logs.\n */\ninterface AudioSourceOptions {\n  /**\n   * Optional logger instance for debug/info/warn logs.\n   */\n  logger?: Logger;\n}\n\n/**\n * Configuration options for the JanusAudioSink.\n */\ninterface AudioSinkOptions {\n  /**\n   * Optional logger instance for debug/info/warn logs.\n   */\n  logger?: Logger;\n}\n\n/**\n * JanusAudioSource wraps a RTCAudioSource, allowing you to push\n * raw PCM frames (Int16Array) into the WebRTC pipeline.\n */\nexport class JanusAudioSource extends EventEmitter {\n  private source: any;\n  private readonly track: MediaStreamTrack;\n  private logger?: Logger;\n\n  constructor(options?: AudioSourceOptions) {\n    super();\n    this.logger = options?.logger;\n    this.source = new RTCAudioSource();\n    this.track = this.source.createTrack();\n  }\n\n  /**\n   * Returns the MediaStreamTrack associated with this audio source.\n   */\n  public getTrack(): MediaStreamTrack {\n    return this.track;\n  }\n\n  /**\n   * Pushes PCM data into the RTCAudioSource. Typically 16-bit, single- or multi-channel frames.\n   * @param samples - The Int16Array audio samples.\n   * @param sampleRate - The sampling rate (e.g., 48000).\n   * @param channels - Number of channels (e.g., 1 for mono).\n   */\n  public pushPcmData(samples: Int16Array, sampleRate: number, channels = 1): void {\n    if (this.logger?.isDebugEnabled()) {\n      this.logger?.debug(\n        `[JanusAudioSource] pushPcmData => sampleRate=${sampleRate}, channels=${channels}, frames=${samples.length}`\n      );\n    }\n\n    // Feed data into the RTCAudioSource\n    this.source.onData({\n      samples,\n      sampleRate,\n      bitsPerSample: 16,\n      channelCount: channels,\n      numberOfFrames: samples.length / channels,\n    });\n  }\n}\n\n/**\n * JanusAudioSink wraps a RTCAudioSink, providing an event emitter\n * that forwards raw PCM frames (Int16Array) to listeners.\n */\nexport class JanusAudioSink extends EventEmitter {\n  private sink: any;\n  private active = true;\n  private logger?: Logger;\n\n  constructor(track: MediaStreamTrack, options?: AudioSinkOptions) {\n    super();\n    this.logger = options?.logger;\n\n    if (track.kind !== 'audio') {\n      throw new Error('[JanusAudioSink] Provided track is not an audio track');\n    }\n\n    // Create RTCAudioSink to listen for PCM frames\n    this.sink = new RTCAudioSink(track);\n\n    // Register callback for PCM frames\n    this.sink.ondata = (frame: {\n      samples: Int16Array;\n      sampleRate: number;\n      bitsPerSample: number;\n      channelCount: number;\n    }) => {\n      if (!this.active) return;\n\n      if (this.logger?.isDebugEnabled()) {\n        this.logger?.debug(\n          `[JanusAudioSink] ondata => sampleRate=${frame.sampleRate}, bitsPerSample=${frame.bitsPerSample}, channelCount=${frame.channelCount}, frames=${frame.samples.length}`\n        );\n      }\n\n      // Emit 'audioData' event with the raw PCM frame\n      this.emit('audioData', frame);\n    };\n  }\n\n  /**\n   * Stops receiving audio data. Once called, no further 'audioData' events will be emitted.\n   */\n  public stop(): void {\n    this.active = false;\n    if (this.logger?.isDebugEnabled()) {\n      this.logger?.debug('[JanusAudioSink] stop called => stopping the sink');\n    }\n    this.sink?.stop();\n  }\n}\n","// src/core/SpaceParticipant.ts\n\nimport { EventEmitter } from 'node:events';\nimport type { Client } from '../../client';\nimport { Logger } from '../logger';\nimport type { AudioDataWithUser, Plugin, PluginRegistration, TurnServersInfo } from '../types';\nimport {\n  accessChat,\n  authorizeToken,\n  cancelSpeakerRequest,\n  getTurnServers,\n  muteSpeaker,\n  negotiateGuestStream,\n  setupCommonChatEvents,\n  startWatching,\n  stopWatching,\n  submitSpeakerRequest,\n  unmuteSpeaker,\n} from '../utils';\nimport { ChatClient } from './ChatClient';\nimport { JanusClient } from './JanusClient';\n\n/**\n * Interface representing the configuration options for a space participant.\n * @typedef {object} SpaceParticipantConfig\n * @property {string} spaceId - The unique identifier for the space.\n * @property {boolean} [debug] - Optional flag for enabling debug mode.\n */\ninterface SpaceParticipantConfig {\n  spaceId: string;\n  debug?: boolean;\n}\n\n/**\n * Manages joining an existing Space in listener mode,\n * and optionally becoming a speaker via WebRTC (Janus).\n */\n/**\n * Class representing a participant in a space.\n * @extends EventEmitter\n */\nexport class SpaceParticipant extends EventEmitter {\n  private readonly spaceId: string;\n  private readonly debug: boolean;\n  private readonly logger: Logger;\n\n  // Basic auth/cookie data\n  private cookie?: string;\n  private authToken?: string;\n\n  // Chat\n  private chatJwtToken?: string;\n  private chatToken?: string;\n  private chatClient?: ChatClient;\n\n  // Watch session\n  private lifecycleToken?: string;\n  private watchSession?: string;\n\n  // HLS stream\n  private hlsUrl?: string;\n\n  // Speaker request + Janus\n  private sessionUUID?: string;\n  private janusJwt?: string;\n  private webrtcGwUrl?: string;\n  private janusClient?: JanusClient;\n\n  // Plugin management\n  private plugins = new Set<PluginRegistration>();\n\n  constructor(\n    private readonly client: Client,\n    config: SpaceParticipantConfig\n  ) {\n    super();\n    this.spaceId = config.spaceId;\n    this.debug = config.debug ?? false;\n    this.logger = new Logger(this.debug);\n  }\n\n  /**\n   * Adds a plugin and calls its onAttach immediately.\n   * init() or onJanusReady() will be invoked later at the appropriate time.\n   */\n  public use(plugin: Plugin, config?: Record<string, any>) {\n    const registration: PluginRegistration = { plugin, config };\n    this.plugins.add(registration);\n\n    this.logger.debug('[SpaceParticipant] Plugin added =>', plugin.constructor.name);\n\n    // Call the plugin's onAttach if it exists\n    plugin.onAttach?.({ space: this, pluginConfig: config });\n\n    if (plugin.init) {\n      plugin.init({ space: this, pluginConfig: config });\n    }\n\n    return this;\n  }\n\n  /**\n   * Joins the Space as a listener: obtains HLS, chat token, etc.\n   */\n  public async joinAsListener(): Promise<void> {\n    this.logger.info('[SpaceParticipant] Joining space as listener =>', this.spaceId);\n\n    // 1) Get cookie and authorize\n    this.cookie = await this.client.getPeriscopeCookie();\n    this.authToken = await authorizeToken(this.cookie);\n\n    // 2) Retrieve the space metadata for mediaKey\n    const spaceMeta = await this.client.getAudioSpaceById(this.spaceId);\n    const mediaKey = spaceMeta?.metadata?.media_key;\n    if (!mediaKey) {\n      throw new Error('[SpaceParticipant] No mediaKey found in metadata');\n    }\n    this.logger.debug('[SpaceParticipant] mediaKey =>', mediaKey);\n\n    // 3) Query live_video_stream/status for HLS URL and chat token\n    const status = await this.client.getAudioSpaceStreamStatus(mediaKey);\n    this.hlsUrl = status?.source?.location;\n    this.chatJwtToken = status?.chatToken;\n    this.lifecycleToken = status?.lifecycleToken;\n    this.logger.debug('[SpaceParticipant] HLS =>', this.hlsUrl);\n\n    // 4) Access the chat\n    if (!this.chatJwtToken) {\n      throw new Error('[SpaceParticipant] No chatToken found');\n    }\n    const chatInfo = await accessChat(this.chatJwtToken, this.cookie!);\n    this.chatToken = chatInfo.access_token;\n\n    // 5) Create and connect the ChatClient\n    this.chatClient = new ChatClient({\n      spaceId: chatInfo.room_id,\n      accessToken: chatInfo.access_token,\n      endpoint: chatInfo.endpoint,\n      logger: this.logger,\n    });\n    await this.chatClient.connect();\n    this.setupChatEvents();\n\n    // 6) startWatching (to appear as a viewer)\n    this.watchSession = await startWatching(this.lifecycleToken!, this.cookie!);\n\n    this.logger.info('[SpaceParticipant] Joined as listener.');\n  }\n\n  /**\n   * Returns the HLS URL if you want to consume the stream as a listener.\n   */\n  public getHlsUrl(): string | undefined {\n    return this.hlsUrl;\n  }\n\n  /**\n   * Submits a speaker request using /audiospace/request/submit.\n   * Returns the sessionUUID used to track approval.\n   */\n  public async requestSpeaker(): Promise<{ sessionUUID: string }> {\n    if (!this.chatJwtToken) {\n      throw new Error('[SpaceParticipant] Must join as listener first (no chat token).');\n    }\n    if (!this.authToken) {\n      throw new Error('[SpaceParticipant] No auth token available.');\n    }\n    if (!this.chatToken) {\n      throw new Error('[SpaceParticipant] No chat token available.');\n    }\n\n    this.logger.info('[SpaceParticipant] Submitting speaker request...');\n\n    const { session_uuid } = await submitSpeakerRequest({\n      broadcastId: this.spaceId,\n      chatToken: this.chatToken,\n      authToken: this.authToken,\n    });\n    this.sessionUUID = session_uuid;\n\n    this.logger.info('[SpaceParticipant] Speaker request submitted =>', session_uuid);\n    return { sessionUUID: session_uuid };\n  }\n\n  /**\n   * Cancels a previously submitted speaker request using /audiospace/request/cancel.\n   * This requires a valid sessionUUID from requestSpeaker() first.\n   */\n  public async cancelSpeakerRequest(): Promise<void> {\n    if (!this.sessionUUID) {\n      throw new Error(\n        '[SpaceParticipant] No sessionUUID; cannot cancel a speaker request that was never submitted.'\n      );\n    }\n    if (!this.authToken) {\n      throw new Error('[SpaceParticipant] No auth token available.');\n    }\n    if (!this.chatToken) {\n      throw new Error('[SpaceParticipant] No chat token available.');\n    }\n\n    await cancelSpeakerRequest({\n      broadcastId: this.spaceId,\n      sessionUUID: this.sessionUUID,\n      chatToken: this.chatToken,\n      authToken: this.authToken,\n    });\n\n    this.logger.info('[SpaceParticipant] Speaker request canceled =>', this.sessionUUID);\n    this.sessionUUID = undefined;\n  }\n\n  /**\n   * Once the host approves our speaker request, we perform Janus negotiation\n   * to become a speaker.\n   */\n  public async becomeSpeaker(): Promise<void> {\n    if (!this.sessionUUID) {\n      throw new Error('[SpaceParticipant] No sessionUUID (did you call requestSpeaker()?).');\n    }\n    this.logger.info('[SpaceParticipant] Negotiating speaker role via Janus...');\n\n    // 1) Retrieve TURN servers\n    const turnServers: TurnServersInfo = await getTurnServers(this.cookie!);\n    this.logger.debug('[SpaceParticipant] turnServers =>', turnServers);\n\n    // 2) Negotiate with /audiospace/stream/negotiate\n    const nego = await negotiateGuestStream({\n      broadcastId: this.spaceId,\n      sessionUUID: this.sessionUUID,\n      authToken: this.authToken!,\n      cookie: this.cookie!,\n    });\n    this.janusJwt = nego.janus_jwt;\n    this.webrtcGwUrl = nego.webrtc_gw_url;\n    this.logger.debug('[SpaceParticipant] webrtcGwUrl =>', this.webrtcGwUrl);\n\n    // 3) Create JanusClient\n    this.janusClient = new JanusClient({\n      webrtcUrl: this.webrtcGwUrl!,\n      roomId: this.spaceId,\n      credential: this.janusJwt!,\n      userId: turnServers.username.split(':')[1],\n      streamName: this.spaceId,\n      turnServers,\n      logger: this.logger,\n    });\n\n    // 4) Initialize the guest speaker session in Janus\n    await this.janusClient.initializeGuestSpeaker(this.sessionUUID);\n\n    this.janusClient.on('audioDataFromSpeaker', (data: AudioDataWithUser) => {\n      this.logger.debug('[SpaceParticipant] Received speaker audio =>', data.userId);\n      this.handleAudioData(data);\n    });\n\n    this.logger.info('[SpaceParticipant] Now speaker on the Space =>', this.spaceId);\n\n    // For plugins that need direct Janus references, call onJanusReady\n    for (const { plugin } of this.plugins) {\n      plugin.onJanusReady?.(this.janusClient);\n    }\n  }\n\n  /**\n   * Removes self from the speaker role and transitions back to a listener.\n   */\n  public async removeFromSpeaker(): Promise<void> {\n    if (!this.sessionUUID) {\n      throw new Error('[SpaceParticipant] No sessionUUID; cannot remove from speaker role.');\n    }\n    if (!this.authToken || !this.chatToken) {\n      throw new Error('[SpaceParticipant] Missing authToken or chatToken.');\n    }\n\n    this.logger.info('[SpaceParticipant] Removing from speaker role...');\n\n    // Stop the Janus session\n    if (this.janusClient) {\n      await this.janusClient.stop();\n      this.janusClient = undefined;\n    }\n\n    this.logger.info('[SpaceParticipant] Successfully removed from speaker role.');\n  }\n\n  /**\n   * Leaves the Space gracefully:\n   * - Stop Janus if we were a speaker\n   * - Stop watching as a viewer\n   * - Disconnect chat\n   */\n  public async leaveSpace(): Promise<void> {\n    this.logger.info('[SpaceParticipant] Leaving space...');\n\n    // If speaker, stop Janus\n    if (this.janusClient) {\n      await this.janusClient.stop();\n      this.janusClient = undefined;\n    }\n\n    // Stop watching\n    if (this.watchSession && this.cookie) {\n      await stopWatching(this.watchSession, this.cookie);\n    }\n\n    // Disconnect chat\n    if (this.chatClient) {\n      await this.chatClient.disconnect();\n      this.chatClient = undefined;\n    }\n\n    this.logger.info('[SpaceParticipant] Left space =>', this.spaceId);\n  }\n\n  /**\n   * Pushes PCM audio frames if we're speaker; otherwise logs a warning.\n   */\n  public pushAudio(samples: Int16Array, sampleRate: number) {\n    if (!this.janusClient) {\n      this.logger.warn('[SpaceParticipant] Not a speaker yet; ignoring pushAudio.');\n      return;\n    }\n    this.janusClient.pushLocalAudio(samples, sampleRate);\n  }\n\n  /**\n   * Internal handler for incoming PCM frames from Janus, forwarded to plugin.onAudioData if present.\n   */\n  private handleAudioData(data: AudioDataWithUser) {\n    for (const { plugin } of this.plugins) {\n      plugin.onAudioData?.(data);\n    }\n  }\n\n  /**\n   * Sets up chat events: \"occupancyUpdate\", \"newSpeakerAccepted\", etc.\n   */\n  private setupChatEvents() {\n    if (!this.chatClient) return;\n    setupCommonChatEvents(this.chatClient, this.logger, this);\n\n    this.chatClient.on('newSpeakerAccepted', ({ userId }) => {\n      this.logger.debug('[SpaceParticipant] newSpeakerAccepted =>', userId);\n\n      // If we haven't created Janus yet, skip\n      if (!this.janusClient) {\n        this.logger.warn('[SpaceParticipant] No janusClient yet; ignoring new speaker...');\n        return;\n      }\n      // If this is our own handle, skip\n      if (userId === this.janusClient.getHandleId()) {\n        return;\n      }\n\n      // Subscribe to this new speaker's audio\n      this.janusClient.subscribeSpeaker(userId).catch((err) => {\n        this.logger.error('[SpaceParticipant] subscribeSpeaker error =>', err);\n      });\n    });\n  }\n\n  /**\n   * Mute self if we are speaker: calls /audiospace/muteSpeaker with our sessionUUID.\n   */\n  public async muteSelf(): Promise<void> {\n    if (!this.authToken || !this.chatToken) {\n      throw new Error('[SpaceParticipant] Missing authToken or chatToken.');\n    }\n    if (!this.sessionUUID) {\n      throw new Error('[SpaceParticipant] No sessionUUID; are you a speaker?');\n    }\n\n    await muteSpeaker({\n      broadcastId: this.spaceId,\n      sessionUUID: this.sessionUUID,\n      chatToken: this.chatToken,\n      authToken: this.authToken,\n    });\n    this.logger.info('[SpaceParticipant] Successfully muted self.');\n  }\n\n  /**\n   * Unmute self if we are speaker: calls /audiospace/unmuteSpeaker with our sessionUUID.\n   */\n  public async unmuteSelf(): Promise<void> {\n    if (!this.authToken || !this.chatToken) {\n      throw new Error('[SpaceParticipant] Missing authToken or chatToken.');\n    }\n    if (!this.sessionUUID) {\n      throw new Error('[SpaceParticipant] No sessionUUID; are you a speaker?');\n    }\n\n    await unmuteSpeaker({\n      broadcastId: this.spaceId,\n      sessionUUID: this.sessionUUID,\n      chatToken: this.chatToken,\n      authToken: this.authToken,\n    });\n    this.logger.info('[SpaceParticipant] Successfully unmuted self.');\n  }\n}\n","// src/plugins/SttTtsPlugin.ts\n\nimport { spawn } from 'node:child_process';\nimport fs from 'node:fs';\nimport path from 'node:path';\nimport type { JanusClient } from '../core/JanusClient';\nimport type { Space } from '../core/Space';\nimport type { SpaceParticipant } from '../core/SpaceParticipant';\nimport { Logger } from '../logger';\nimport type { AudioDataWithUser, Plugin } from '../types';\nimport { logger } from '@elizaos/core';\n\n/**\n * Interface for configuring a plugin\n * @typedef {Object} PluginConfig\n * @property {string} [openAiApiKey] - API key for OpenAI used for STT & ChatGPT\n * @property {string} [elevenLabsApiKey] - API key for ElevenLabs used for TTS\n * @property {string} [sttLanguage] - Language code for speech-to-text (e.g., \"en\" for English)\n * @property {string} [gptModel] - Model for ChatGPT (e.g., \"gpt-3.5-turbo\" or \"gpt-4\")\n * @property {number} [silenceThreshold] - Amplitude threshold for ignoring silence\n * @property {string} [voiceId] - Specifies which ElevenLabs voice to use\n * @property {string} [elevenLabsModel] - Model for ElevenLabs (e.g., \"eleven_monolingual_v1\")\n * @property {string} [systemPrompt] - Default prompt for the AI assistant\n * @property {Array<{ role: \"system\" | \"user\" | \"assistant\"; content: string; }>} [chatContext] - Array of objects representing chat context\n * @property {boolean} [debug] - Flag to enable debug mode\n */\ninterface PluginConfig {\n  openAiApiKey?: string; // for STT & ChatGPT\n  elevenLabsApiKey?: string; // for TTS\n  sttLanguage?: string; // e.g., \"en\" for Whisper\n  gptModel?: string; // e.g., \"gpt-3.5-turbo\" or \"gpt-4\"\n  silenceThreshold?: number; // amplitude threshold for ignoring silence\n  voiceId?: string; // specify which ElevenLabs voice to use\n  elevenLabsModel?: string; // e.g., \"eleven_monolingual_v1\"\n  systemPrompt?: string; // e.g., \"You are a helpful AI assistant\"\n  chatContext?: Array<{\n    role: 'system' | 'user' | 'assistant';\n    content: string;\n  }>;\n  debug?: boolean;\n}\n\n/**\n * SttTtsPlugin\n * ------------\n * Provides an end-to-end flow of:\n *  - Speech-to-Text (OpenAI Whisper)\n *  - ChatGPT conversation\n *  - Text-to-Speech (ElevenLabs)\n *  - Streams TTS audio frames back to Janus\n *\n * Lifecycle:\n *  - onAttach(...) => minimal references\n *  - init(...) => space or participant has joined in basic mode\n *  - onJanusReady(...) => we have a JanusClient\n *  - onAudioData(...) => receiving PCM frames from speakers\n *  - cleanup(...) => release resources, stop timers, etc.\n */\n/**\n * Represents a plugin for speech-to-text and text-to-speech functionality.\n * @implements Plugin\n * @property {Space | SpaceParticipant} spaceOrParticipant - Reference to the space/participant using the plugin.\n * @property {JanusClient} janus - Reference to the Janus client for real-time communication.\n * @property {Logger} logger - Optional logger retrieved from the space or participant.\n */\nexport class SttTtsPlugin implements Plugin {\n  // References to the space/participant and the Janus client\n  private spaceOrParticipant?: Space | SpaceParticipant;\n  private janus?: JanusClient;\n\n  // Optional logger retrieved from the space or participant\n  private logger?: Logger;\n\n  // Credentials & config\n  private openAiApiKey?: string;\n  private elevenLabsApiKey?: string;\n  private sttLanguage = 'en';\n  private gptModel = 'gpt-3.5-turbo';\n  private voiceId = '21m00Tcm4TlvDq8ikWAM';\n  private elevenLabsModel = 'eleven_monolingual_v1';\n  private systemPrompt = 'You are a helpful AI assistant.';\n  private silenceThreshold = 50;\n\n  /**\n   * chatContext accumulates the conversation for GPT:\n   *  - system: persona instructions\n   *  - user/assistant: running conversation\n   */\n  private chatContext: Array<{\n    role: 'system' | 'user' | 'assistant';\n    content: string;\n  }> = [];\n\n  /**\n   * Maps each userId => array of Int16Array PCM chunks\n   * Only accumulates data if the speaker is unmuted\n   */\n  private pcmBuffers = new Map<string, Int16Array[]>();\n\n  /**\n   * Tracks which speakers are currently unmuted:\n   * userId => true/false\n   */\n  private speakerUnmuted = new Map<string, boolean>();\n\n  /**\n   * TTS queue for sequential playback\n   */\n  private ttsQueue: string[] = [];\n  private isSpeaking = false;\n\n  /**\n   * Called immediately after `.use(plugin)`.\n   * Usually used for storing references or minimal setup.\n   */\n  onAttach(params: { space: Space | SpaceParticipant; pluginConfig?: Record<string, any> }): void {\n    // Store a reference to the space or participant\n    this.spaceOrParticipant = params.space;\n\n    const debugEnabled = params.pluginConfig?.debug ?? false;\n    this.logger = new Logger(debugEnabled);\n\n    logger.debug('[SttTtsPlugin] onAttach => plugin attached');\n  }\n\n  /**\n   * Called after the space/participant has joined in basic mode (listener + chat).\n   * This is where we can finalize setup that doesn't require Janus or speaker mode.\n   */\n  init(params: { space: Space | SpaceParticipant; pluginConfig?: Record<string, any> }): void {\n    const config = params.pluginConfig as PluginConfig;\n\n    this.logger?.debug('[SttTtsPlugin] init => finalizing basic setup');\n\n    // Overwrite the local reference with a strong typed one\n    this.spaceOrParticipant = params.space;\n\n    // If space/participant has a Janus client already, we can store it,\n    // but typically we rely on \"onJanusReady\" for that.\n    this.janus = (this.spaceOrParticipant as any).janusClient;\n\n    // Merge plugin configuration\n    this.openAiApiKey = config?.openAiApiKey;\n    this.elevenLabsApiKey = config?.elevenLabsApiKey;\n    if (config?.sttLanguage) this.sttLanguage = config.sttLanguage;\n    if (config?.gptModel) this.gptModel = config.gptModel;\n    if (typeof config?.silenceThreshold === 'number') {\n      this.silenceThreshold = config.silenceThreshold;\n    }\n    if (config?.voiceId) this.voiceId = config.voiceId;\n    if (config?.elevenLabsModel) this.elevenLabsModel = config.elevenLabsModel;\n    if (config?.systemPrompt) this.systemPrompt = config.systemPrompt;\n    if (config?.chatContext) {\n      this.chatContext = config.chatContext;\n    }\n\n    this.logger?.debug('[SttTtsPlugin] Merged config =>', config);\n\n    // Example: watch for \"muteStateChanged\" events from the space or participant\n    this.spaceOrParticipant.on('muteStateChanged', (evt: { userId: string; muted: boolean }) => {\n      this.logger?.debug('[SttTtsPlugin] muteStateChanged =>', evt);\n      if (evt.muted) {\n        // If the user just muted, flush STT\n        this.handleMute(evt.userId).catch((err) => {\n          this.logger?.error('[SttTtsPlugin] handleMute error =>', err);\n        });\n      } else {\n        // Mark user as unmuted\n        this.speakerUnmuted.set(evt.userId, true);\n        if (!this.pcmBuffers.has(evt.userId)) {\n          this.pcmBuffers.set(evt.userId, []);\n        }\n      }\n    });\n  }\n\n  /**\n   * Called if/when the plugin needs direct access to a JanusClient.\n   * For example, once the participant becomes a speaker or if a host\n   * has finished setting up Janus.\n   */\n  onJanusReady(janusClient: JanusClient): void {\n    this.logger?.debug('[SttTtsPlugin] onJanusReady => JanusClient is now available');\n    this.janus = janusClient;\n  }\n\n  /**\n   * onAudioData: triggered for every incoming PCM frame from a speaker.\n   * We'll accumulate them if that speaker is currently unmuted.\n   */\n  onAudioData(data: AudioDataWithUser): void {\n    const { userId, samples } = data;\n    if (!this.speakerUnmuted.get(userId)) return;\n\n    // Basic amplitude check\n    let maxVal = 0;\n    for (let i = 0; i < samples.length; i++) {\n      const val = Math.abs(samples[i]);\n      if (val > maxVal) maxVal = val;\n    }\n    if (maxVal < this.silenceThreshold) return;\n\n    // Accumulate frames\n    const chunks = this.pcmBuffers.get(userId) ?? [];\n    chunks.push(samples);\n    this.pcmBuffers.set(userId, chunks);\n  }\n\n  /**\n   * handleMute: called when a speaker goes from unmuted to muted.\n   * We'll flush their collected PCM => STT => GPT => TTS => push to Janus\n   */\n  private async handleMute(userId: string): Promise<void> {\n    this.speakerUnmuted.set(userId, false);\n\n    const chunks = this.pcmBuffers.get(userId) || [];\n    this.pcmBuffers.set(userId, []); // reset\n\n    if (!chunks.length) {\n      this.logger?.debug('[SttTtsPlugin] No audio data => userId=', userId);\n      return;\n    }\n\n    this.logger?.info(\n      `[SttTtsPlugin] Flushing STT buffer => userId=${userId}, chunkCount=${chunks.length}`\n    );\n\n    // Merge into one Int16Array\n    const totalLen = chunks.reduce((acc, c) => acc + c.length, 0);\n    const merged = new Int16Array(totalLen);\n    let offset = 0;\n    for (const c of chunks) {\n      merged.set(c, offset);\n      offset += c.length;\n    }\n\n    // Convert to WAV\n    const wavPath = await this.convertPcmToWav(merged, 48000);\n    this.logger?.debug('[SttTtsPlugin] WAV created =>', wavPath);\n\n    // Whisper STT\n    const sttText = await this.transcribeWithOpenAI(wavPath, this.sttLanguage);\n    fs.unlinkSync(wavPath); // remove temp\n\n    if (!sttText.trim()) {\n      this.logger?.debug('[SttTtsPlugin] No speech recognized => userId=', userId);\n      return;\n    }\n    this.logger?.info(`[SttTtsPlugin] STT => userId=${userId}, text=\"${sttText}\"`);\n\n    // GPT response\n    const replyText = await this.askChatGPT(sttText);\n    this.logger?.info(`[SttTtsPlugin] GPT => userId=${userId}, reply=\"${replyText}\"`);\n\n    // Send TTS\n    await this.speakText(replyText);\n  }\n\n  /**\n   * speakText: Public method to enqueue a text message for TTS output\n   */\n  public async speakText(text: string): Promise<void> {\n    this.ttsQueue.push(text);\n\n    if (!this.isSpeaking) {\n      this.isSpeaking = true;\n      this.processTtsQueue().catch((err) => {\n        this.logger?.error('[SttTtsPlugin] processTtsQueue error =>', err);\n      });\n    }\n  }\n\n  /**\n   * processTtsQueue: Drains the TTS queue in order, sending frames to Janus\n   */\n  private async processTtsQueue(): Promise<void> {\n    while (this.ttsQueue.length > 0) {\n      const text = this.ttsQueue.shift();\n      if (!text) continue;\n      try {\n        const mp3Buf = await this.elevenLabsTts(text);\n        const pcm = await this.convertMp3ToPcm(mp3Buf, 48000);\n        await this.streamToJanus(pcm, 48000);\n      } catch (err) {\n        this.logger?.error('[SttTtsPlugin] TTS streaming error =>', err);\n      }\n    }\n    this.isSpeaking = false;\n  }\n\n  /**\n   * convertPcmToWav: Creates a temporary WAV file from raw PCM samples\n   */\n  private convertPcmToWav(samples: Int16Array, sampleRate: number): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const tmpPath = path.resolve('/tmp', `stt-${Date.now()}.wav`);\n      const ff = spawn('ffmpeg', [\n        '-f',\n        's16le',\n        '-ar',\n        sampleRate.toString(),\n        '-ac',\n        '1',\n        '-i',\n        'pipe:0',\n        '-y',\n        tmpPath,\n      ]);\n\n      ff.stdin.write(Buffer.from(samples.buffer));\n      ff.stdin.end();\n\n      ff.on('close', (code) => {\n        if (code === 0) {\n          resolve(tmpPath);\n        } else {\n          reject(new Error(`ffmpeg pcm->wav error code=${code}`));\n        }\n      });\n    });\n  }\n\n  /**\n   * transcribeWithOpenAI: sends the WAV file to OpenAI Whisper\n   */\n  private async transcribeWithOpenAI(wavPath: string, language: string): Promise<string> {\n    if (!this.openAiApiKey) {\n      throw new Error('[SttTtsPlugin] No OpenAI API key');\n    }\n\n    this.logger?.info('[SttTtsPlugin] Transcribing =>', wavPath);\n    const fileBuffer = fs.readFileSync(wavPath);\n    this.logger?.debug('[SttTtsPlugin] WAV size =>', fileBuffer.length);\n\n    const blob = new Blob([fileBuffer], { type: 'audio/wav' });\n    const formData = new FormData();\n    formData.append('file', blob, path.basename(wavPath));\n    formData.append('model', 'whisper-1');\n    formData.append('language', language);\n    formData.append('temperature', '0');\n\n    const resp = await fetch('https://api.openai.com/v1/audio/transcriptions', {\n      method: 'POST',\n      headers: { Authorization: `Bearer ${this.openAiApiKey}` },\n      body: formData,\n    });\n\n    if (!resp.ok) {\n      const errText = await resp.text();\n      this.logger?.error('[SttTtsPlugin] OpenAI STT error =>', errText);\n      throw new Error(`OpenAI STT => ${resp.status} ${errText}`);\n    }\n\n    const data = (await resp.json()) as { text: string };\n    return data.text.trim();\n  }\n\n  /**\n   * askChatGPT: sends user text to GPT, returns the assistant reply\n   */\n  private async askChatGPT(userText: string): Promise<string> {\n    if (!this.openAiApiKey) {\n      throw new Error('[SttTtsPlugin] No OpenAI API key (GPT) provided');\n    }\n\n    const messages = [\n      { role: 'system', content: this.systemPrompt },\n      ...this.chatContext,\n      { role: 'user', content: userText },\n    ];\n\n    const resp = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${this.openAiApiKey}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ model: this.gptModel, messages }),\n    });\n\n    if (!resp.ok) {\n      const errText = await resp.text();\n      throw new Error(`[SttTtsPlugin] ChatGPT error => ${resp.status} ${errText}`);\n    }\n\n    const json = await resp.json();\n    const reply = json.choices?.[0]?.message?.content || '';\n    // Keep conversation context\n    this.chatContext.push({ role: 'user', content: userText });\n    this.chatContext.push({ role: 'assistant', content: reply });\n    return reply.trim();\n  }\n\n  /**\n   * elevenLabsTts: fetches MP3 audio from ElevenLabs for a given text\n   */\n  private async elevenLabsTts(text: string): Promise<Buffer> {\n    if (!this.elevenLabsApiKey) {\n      throw new Error('[SttTtsPlugin] No ElevenLabs API key');\n    }\n\n    const url = `https://api.elevenlabs.io/v1/text-to-speech/${this.voiceId}`;\n    const resp = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'xi-api-key': this.elevenLabsApiKey,\n      },\n      body: JSON.stringify({\n        text,\n        model_id: this.elevenLabsModel,\n        voice_settings: { stability: 0.4, similarity_boost: 0.8 },\n      }),\n    });\n\n    if (!resp.ok) {\n      const errText = await resp.text();\n      throw new Error(`[SttTtsPlugin] ElevenLabs error => ${resp.status} ${errText}`);\n    }\n\n    const arrayBuffer = await resp.arrayBuffer();\n    return Buffer.from(arrayBuffer);\n  }\n\n  /**\n   * convertMp3ToPcm: uses ffmpeg to convert an MP3 buffer to raw PCM\n   */\n  private convertMp3ToPcm(mp3Buf: Buffer, outRate: number): Promise<Int16Array> {\n    return new Promise((resolve, reject) => {\n      const ff = spawn('ffmpeg', [\n        '-i',\n        'pipe:0',\n        '-f',\n        's16le',\n        '-ar',\n        outRate.toString(),\n        '-ac',\n        '1',\n        'pipe:1',\n      ]);\n\n      let raw = Buffer.alloc(0);\n\n      ff.stdout.on('data', (chunk: Buffer) => {\n        raw = Buffer.concat([raw, chunk]);\n      });\n      ff.stderr.on('data', () => {\n        // ignoring ffmpeg stderr\n      });\n      ff.on('close', (code) => {\n        if (code !== 0) {\n          reject(new Error(`ffmpeg mp3->pcm error code=${code}`));\n          return;\n        }\n        const samples = new Int16Array(raw.buffer, raw.byteOffset, raw.byteLength / 2);\n        resolve(samples);\n      });\n\n      ff.stdin.write(mp3Buf);\n      ff.stdin.end();\n    });\n  }\n\n  /**\n   * streamToJanus: push PCM frames to Janus in small increments (~10ms).\n   */\n  private async streamToJanus(samples: Int16Array, sampleRate: number): Promise<void> {\n    if (!this.janus) {\n      this.logger?.warn('[SttTtsPlugin] No JanusClient available, cannot send TTS audio');\n      return;\n    }\n\n    const frameSize = Math.floor(sampleRate * 0.01); // 10ms => e.g. 480 @ 48kHz\n\n    for (let offset = 0; offset + frameSize <= samples.length; offset += frameSize) {\n      const frame = new Int16Array(frameSize);\n      frame.set(samples.subarray(offset, offset + frameSize));\n      this.janus.pushLocalAudio(frame, sampleRate, 1);\n      await new Promise((r) => setTimeout(r, 10));\n    }\n  }\n\n  /**\n   * setSystemPrompt: update the GPT system prompt at runtime\n   */\n  public setSystemPrompt(prompt: string): void {\n    this.systemPrompt = prompt;\n    this.logger?.info('[SttTtsPlugin] setSystemPrompt =>', prompt);\n  }\n\n  /**\n   * setGptModel: switch GPT model (e.g. \"gpt-4\")\n   */\n  public setGptModel(model: string): void {\n    this.gptModel = model;\n    this.logger?.info('[SttTtsPlugin] setGptModel =>', model);\n  }\n\n  /**\n   * addMessage: manually add a system/user/assistant message to the chat context\n   */\n  public addMessage(role: 'system' | 'user' | 'assistant', content: string): void {\n    this.chatContext.push({ role, content });\n    this.logger?.debug(`[SttTtsPlugin] addMessage => role=${role}, content=\"${content}\"`);\n  }\n\n  /**\n   * clearChatContext: resets the GPT conversation\n   */\n  public clearChatContext(): void {\n    this.chatContext = [];\n    this.logger?.debug('[SttTtsPlugin] clearChatContext => done');\n  }\n\n  /**\n   * cleanup: release resources when the space/participant is stopping or plugin removed\n   */\n  cleanup(): void {\n    this.logger?.info('[SttTtsPlugin] cleanup => releasing resources');\n\n    this.pcmBuffers.clear();\n    this.speakerUnmuted.clear();\n    this.ttsQueue = [];\n    this.isSpeaking = false;\n  }\n}\n","import type { Space } from '../core/Space';\nimport { Logger } from '../logger';\nimport type { AudioDataWithUser, Plugin } from '../types';\n\n/**\n * IdleMonitorPlugin\n * -----------------\n * Monitors silence in both remote speaker audio and local (pushed) audio.\n * If no audio is detected for a specified duration, it emits an 'idleTimeout' event on the space.\n */\n/**\n * Class representing an Idle Monitor Plugin.\n * * @implements { Plugin }\n */\nexport class IdleMonitorPlugin implements Plugin {\n  private space?: Space;\n  private logger?: Logger;\n\n  private lastSpeakerAudioMs = Date.now();\n  private lastLocalAudioMs = Date.now();\n  private checkInterval?: NodeJS.Timeout;\n\n  /**\n   * @param idleTimeoutMs The duration (in ms) of total silence before triggering idle. (Default: 60s)\n   * @param checkEveryMs  How frequently (in ms) to check for silence. (Default: 10s)\n   */\n  constructor(\n    private idleTimeoutMs = 60_000,\n    private checkEveryMs = 10_000\n  ) {}\n\n  /**\n   * Called immediately after .use(plugin).\n   * Allows for minimal setup, including obtaining a debug logger if desired.\n   */\n  onAttach(params: { space: Space; pluginConfig?: Record<string, any> }): void {\n    this.space = params.space;\n    const debug = params.pluginConfig?.debug ?? false;\n    this.logger = new Logger(debug);\n\n    this.logger.info('[IdleMonitorPlugin] onAttach => plugin attached');\n  }\n\n  /**\n   * Called once the space has fully initialized (basic mode).\n   * We set up idle checks and override pushAudio to detect local audio activity.\n   */\n  init(params: { space: Space; pluginConfig?: Record<string, any> }): void {\n    this.space = params.space;\n    this.logger?.info('[IdleMonitorPlugin] init => setting up idle checks');\n\n    // Update lastSpeakerAudioMs on incoming speaker audio\n    // (Here we're hooking into an event triggered by Space for each speaker's PCM data.)\n    this.space.on('audioDataFromSpeaker', (_data: AudioDataWithUser) => {\n      this.lastSpeakerAudioMs = Date.now();\n    });\n\n    // Patch space.pushAudio to track local audio\n    const originalPushAudio = this.space.pushAudio.bind(this.space);\n    this.space.pushAudio = (samples, sampleRate) => {\n      this.lastLocalAudioMs = Date.now();\n      originalPushAudio(samples, sampleRate);\n    };\n\n    // Periodically check for silence\n    this.checkInterval = setInterval(() => this.checkIdle(), this.checkEveryMs) as any;\n  }\n\n  /**\n   * Checks if we've exceeded idleTimeoutMs with no audio activity.\n   * If so, emits an 'idleTimeout' event on the space with { idleMs } info.\n   */\n  private checkIdle() {\n    const now = Date.now();\n    const lastAudio = Math.max(this.lastSpeakerAudioMs, this.lastLocalAudioMs);\n    const idleMs = now - lastAudio;\n\n    if (idleMs >= this.idleTimeoutMs) {\n      this.logger?.warn(`[IdleMonitorPlugin] idleTimeout => no audio for ${idleMs}ms`);\n      this.space?.emit('idleTimeout', { idleMs });\n    }\n  }\n\n  /**\n   * Returns how many milliseconds have passed since any audio was detected (local or speaker).\n   */\n  public getIdleTimeMs(): number {\n    const now = Date.now();\n    const lastAudio = Math.max(this.lastSpeakerAudioMs, this.lastLocalAudioMs);\n    return now - lastAudio;\n  }\n\n  /**\n   * Cleans up resources (interval) when the plugin is removed or space stops.\n   */\n  cleanup(): void {\n    this.logger?.info('[IdleMonitorPlugin] cleanup => stopping idle checks');\n    if (this.checkInterval) {\n      clearInterval(this.checkInterval);\n      this.checkInterval = undefined;\n    }\n  }\n}\n","// src/plugins/SttTtsPlugin.ts\n\nimport { spawn } from 'node:child_process';\nimport type { Readable } from 'node:stream';\nimport {\n  ChannelType,\n  type Content,\n  EventType,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  ModelType,\n  type Plugin,\n  createUniqueUuid,\n  logger,\n} from '@elizaos/core';\nimport type { ClientBase } from './base';\nimport type { AudioDataWithUser, JanusClient, Space } from './client';\n\n/**\n * Interface for defining configuration options for a plugin.\n * @typedef {Object} PluginConfig\n * @property {IAgentRuntime} runtime - The runtime environment for the plugin.\n * @property {ClientBase} client - The client to interact with.\n * @property {string} spaceId - The ID of the space the plugin is associated with.\n */\ninterface PluginConfig {\n  runtime: IAgentRuntime;\n  client: ClientBase;\n  spaceId: string;\n}\n\nconst VOLUME_WINDOW_SIZE = 100;\nconst SPEAKING_THRESHOLD = 0.05;\nconst SILENCE_DETECTION_THRESHOLD_MS = 1000; // 1-second silence threshold\n\n/**\n * MVP plugin for speech-to-text (OpenAI) + conversation + TTS (ElevenLabs)\n * Approach:\n *   - Collect each speaker's unmuted PCM in a memory buffer (only if above silence threshold)\n *   - On speaker mute -> flush STT -> GPT -> TTS -> push to Janus\n */\n/**\n * Class representing a plugin for Speech-to-text (OpenAI) + conversation + TTS (ElevenLabs).\n * @class\n */\n\nexport class SttTtsPlugin implements Plugin {\n  name = 'SttTtsPlugin';\n  description = 'Speech-to-text (OpenAI) + conversation + TTS (ElevenLabs)';\n  private runtime: IAgentRuntime;\n  private spaceId: string;\n\n  private space?: Space;\n  private janus?: JanusClient;\n\n  /**\n   * userId => arrayOfChunks (PCM Int16)\n   */\n  private pcmBuffers = new Map<string, Int16Array[]>();\n\n  // TTS queue for sequentially speaking\n  private ttsQueue: string[] = [];\n  private isSpeaking = false;\n  private isProcessingAudio = false;\n\n  private userSpeakingTimer: NodeJS.Timer | null = null;\n  private volumeBuffers: Map<string, number[]>;\n  private ttsAbortController: AbortController | null = null;\n\n  onAttach(_space: Space) {\n    logger.log('[SttTtsPlugin] onAttach => space was attached');\n  }\n\n  async init(params): Promise<void> {\n    logger.log('[SttTtsPlugin] init => Space fully ready. Subscribing to events.');\n\n    this.space = params.space;\n    this.janus = (this.space as any)?.janusClient as JanusClient | undefined;\n\n    const config = params.pluginConfig as PluginConfig;\n    this.runtime = config?.runtime;\n    this.spaceId = config?.spaceId;\n\n    this.volumeBuffers = new Map<string, number[]>();\n  }\n\n  /**\n   * Called whenever we receive PCM from a speaker\n   */\n  onAudioData(data: AudioDataWithUser): void {\n    if (this.isProcessingAudio) {\n      return;\n    }\n    /**\n     * For ignoring near-silence frames (if amplitude < threshold)\n     */\n    const silenceThreshold = 50;\n    let maxVal = 0;\n    for (let i = 0; i < data.samples.length; i++) {\n      const val = Math.abs(data.samples[i]);\n      if (val > maxVal) maxVal = val;\n    }\n    if (maxVal < silenceThreshold) {\n      return;\n    }\n\n    if (this.userSpeakingTimer) {\n      clearTimeout(this.userSpeakingTimer);\n    }\n\n    let arr = this.pcmBuffers.get(data.userId);\n    if (!arr) {\n      arr = [];\n      this.pcmBuffers.set(data.userId, arr);\n    }\n    arr.push(data.samples);\n\n    if (!this.isSpeaking) {\n      this.userSpeakingTimer = setTimeout(() => {\n        logger.log('[SttTtsPlugin] start processing audio for user =>', data.userId);\n        this.userSpeakingTimer = null;\n        this.processAudio(data.userId).catch((err) =>\n          logger.error('[SttTtsPlugin] handleSilence error =>', err)\n        );\n      }, SILENCE_DETECTION_THRESHOLD_MS);\n    } else {\n      // check interruption\n      let volumeBuffer = this.volumeBuffers.get(data.userId);\n      if (!volumeBuffer) {\n        volumeBuffer = [];\n        this.volumeBuffers.set(data.userId, volumeBuffer);\n      }\n      const samples = new Int16Array(\n        data.samples.buffer,\n        data.samples.byteOffset,\n        data.samples.length / 2\n      );\n      const maxAmplitude = Math.max(...samples.map(Math.abs)) / 32768;\n      volumeBuffer.push(maxAmplitude);\n\n      if (volumeBuffer.length > VOLUME_WINDOW_SIZE) {\n        volumeBuffer.shift();\n      }\n      const avgVolume = volumeBuffer.reduce((sum, v) => sum + v, 0) / VOLUME_WINDOW_SIZE;\n\n      if (avgVolume > SPEAKING_THRESHOLD) {\n        volumeBuffer.length = 0;\n        if (this.ttsAbortController) {\n          this.ttsAbortController.abort();\n          this.isSpeaking = false;\n          logger.log('[SttTtsPlugin] TTS playback interrupted');\n        }\n      }\n    }\n  }\n\n  // /src/sttTtsPlugin.ts\n  private async convertPcmToWavInMemory(\n    pcmData: Int16Array,\n    sampleRate: number\n  ): Promise<ArrayBuffer> {\n    // number of channels\n    const numChannels = 1;\n    // byte rate = (sampleRate * numChannels * bitsPerSample/8)\n    const byteRate = sampleRate * numChannels * 2;\n    const blockAlign = numChannels * 2;\n    // data chunk size = pcmData.length * (bitsPerSample/8)\n    const dataSize = pcmData.length * 2;\n\n    // WAV header is 44 bytes\n    const buffer = new ArrayBuffer(44 + dataSize);\n    const view = new DataView(buffer);\n\n    // RIFF chunk descriptor\n    this.writeString(view, 0, 'RIFF');\n    view.setUint32(4, 36 + dataSize, true); // file size - 8\n    this.writeString(view, 8, 'WAVE');\n\n    // fmt sub-chunk\n    this.writeString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)\n    view.setUint16(20, 1, true); // AudioFormat (1 = PCM)\n    view.setUint16(22, numChannels, true); // NumChannels\n    view.setUint32(24, sampleRate, true); // SampleRate\n    view.setUint32(28, byteRate, true); // ByteRate\n    view.setUint16(32, blockAlign, true); // BlockAlign\n    view.setUint16(34, 16, true); // BitsPerSample (16)\n\n    // data sub-chunk\n    this.writeString(view, 36, 'data');\n    view.setUint32(40, dataSize, true);\n\n    // Write PCM samples\n    let offset = 44;\n    for (let i = 0; i < pcmData.length; i++, offset += 2) {\n      view.setInt16(offset, pcmData[i], true);\n    }\n\n    return buffer;\n  }\n\n  private writeString(view: DataView, offset: number, text: string) {\n    for (let i = 0; i < text.length; i++) {\n      view.setUint8(offset + i, text.charCodeAt(i));\n    }\n  }\n\n  /**\n   * On speaker silence => flush STT => GPT => TTS => push to Janus\n   */\n  private async processAudio(userId: string): Promise<void> {\n    if (this.isProcessingAudio) {\n      return;\n    }\n    this.isProcessingAudio = true;\n    try {\n      logger.log('[SttTtsPlugin] Starting audio processing for user:', userId);\n      const chunks = this.pcmBuffers.get(userId) || [];\n      this.pcmBuffers.clear();\n\n      if (!chunks.length) {\n        logger.warn('[SttTtsPlugin] No audio chunks for user =>', userId);\n        return;\n      }\n      logger.log(`[SttTtsPlugin] Flushing STT buffer for user=${userId}, chunks=${chunks.length}`);\n\n      const totalLen = chunks.reduce((acc, c) => acc + c.length, 0);\n      const merged = new Int16Array(totalLen);\n      let offset = 0;\n      for (const c of chunks) {\n        merged.set(c, offset);\n        offset += c.length;\n      }\n\n      // Convert PCM to WAV for STT\n      const wavBuffer = await this.convertPcmToWavInMemory(merged, 48000);\n\n      // Whisper STT\n      const sttText = await this.runtime.useModel(ModelType.TRANSCRIPTION, wavBuffer);\n\n      logger.log(`[SttTtsPlugin] Transcription result: \"${sttText}\"`);\n\n      if (!sttText || !sttText.trim()) {\n        logger.warn('[SttTtsPlugin] No speech recognized for user =>', userId);\n        return;\n      }\n      logger.log(`[SttTtsPlugin] STT => user=${userId}, text=\"${sttText}\"`);\n\n      // Get response\n      await this.handleUserMessage(sttText, userId);\n    } catch (error) {\n      logger.error('[SttTtsPlugin] processAudio error =>', error);\n    } finally {\n      this.isProcessingAudio = false;\n    }\n  }\n\n  /**\n   * Public method to queue a TTS request\n   */\n  public async speakText(text: string): Promise<void> {\n    this.ttsQueue.push(text);\n    if (!this.isSpeaking) {\n      this.isSpeaking = true;\n      this.processTtsQueue().catch((err) => {\n        logger.error('[SttTtsPlugin] processTtsQueue error =>', err);\n      });\n    }\n  }\n\n  /**\n   * Process TTS requests one by one\n   */\n  private async processTtsQueue(): Promise<void> {\n    while (this.ttsQueue.length > 0) {\n      const text = this.ttsQueue.shift();\n      if (!text) continue;\n\n      this.ttsAbortController = new AbortController();\n      const { signal } = this.ttsAbortController;\n\n      try {\n        const responseStream = await this.runtime.useModel(ModelType.TEXT_TO_SPEECH, text);\n        if (!responseStream) {\n          logger.error('[SttTtsPlugin] TTS responseStream is null');\n          continue;\n        }\n\n        logger.log('[SttTtsPlugin] Received ElevenLabs TTS stream');\n\n        // Convert the Readable Stream to PCM and stream to Janus\n        await this.streamTtsStreamToJanus(responseStream, 48000, signal);\n\n        if (signal.aborted) {\n          logger.log('[SttTtsPlugin] TTS interrupted after streaming');\n          return;\n        }\n      } catch (err) {\n        logger.error('[SttTtsPlugin] TTS streaming error =>', err);\n      } finally {\n        // Clean up the AbortController\n        this.ttsAbortController = null;\n      }\n    }\n    this.isSpeaking = false;\n  }\n\n  /**\n   * Handle User Message\n   */\n  private async handleUserMessage(\n    userText: string,\n    userId: string // This is the raw Twitter user ID like 'tw-1865462035586142208'\n  ): Promise<string> {\n    if (!userText || userText.trim() === '') {\n      return null;\n    }\n\n    // Extract the numeric ID part\n    const numericId = userId.replace('tw-', '');\n    const roomId = createUniqueUuid(this.runtime, `twitter_generate_room-${this.spaceId}`);\n\n    // Create consistent UUID for the user\n    const userUuid = createUniqueUuid(this.runtime, numericId);\n\n    const entity = await this.runtime.getEntityById(userUuid);\n    if (!entity) {\n      await this.runtime.createEntity({\n        id: userUuid,\n        names: [userId],\n        agentId: this.runtime.agentId,\n      });\n    }\n\n    // Ensure room exists and user is in it\n    await this.runtime.ensureRoomExists({\n      id: roomId,\n      name: 'Twitter Space',\n      source: 'twitter',\n      type: ChannelType.VOICE_GROUP,\n      channelId: null,\n      serverId: this.spaceId,\n    });\n    await this.runtime.ensureParticipantInRoom(userUuid, roomId);\n\n    const memory = {\n      id: createUniqueUuid(this.runtime, `${roomId}-voice-message-${Date.now()}`),\n      agentId: this.runtime.agentId,\n      content: {\n        text: userText,\n        source: 'twitter',\n      },\n      userId: userUuid,\n      roomId,\n      createdAt: Date.now(),\n    };\n\n    const callback: HandlerCallback = async (content: Content, _files: any[] = []) => {\n      try {\n        const responseMemory: Memory = {\n          id: createUniqueUuid(this.runtime, `${memory.id}-voice-response-${Date.now()}`),\n          entityId: this.runtime.agentId,\n          agentId: this.runtime.agentId,\n          content: {\n            ...content,\n            user: this.runtime.character.name,\n            inReplyTo: memory.id,\n            isVoiceMessage: true,\n          },\n          roomId,\n          createdAt: Date.now(),\n        };\n\n        if (responseMemory.content.text?.trim()) {\n          await this.runtime.createMemory(responseMemory);\n          this.isProcessingAudio = false;\n          this.volumeBuffers.clear();\n          await this.speakText(content.text);\n        }\n\n        return [responseMemory];\n      } catch (error) {\n        console.error('Error in voice message callback:', error);\n        return [];\n      }\n    };\n\n    // Emit voice-specific events\n    this.runtime.emitEvent(EventType.VOICE_MESSAGE_RECEIVED, {\n      runtime: this.runtime,\n      message: memory,\n      callback,\n    });\n  }\n\n  /**\n   * Convert MP3 => PCM via ffmpeg\n   */\n  private convertMp3ToPcm(mp3Buf: Buffer, outRate: number): Promise<Int16Array> {\n    return new Promise((resolve, reject) => {\n      const ff = spawn('ffmpeg', [\n        '-i',\n        'pipe:0',\n        '-f',\n        's16le',\n        '-ar',\n        outRate.toString(),\n        '-ac',\n        '1',\n        'pipe:1',\n      ]);\n      let raw = Buffer.alloc(0);\n\n      ff.stdout.on('data', (chunk: Buffer) => {\n        raw = Buffer.concat([raw, chunk]);\n      });\n      ff.stderr.on('data', () => {\n        // ignoring ffmpeg logs\n      });\n      ff.on('close', (code) => {\n        if (code !== 0) {\n          reject(new Error(`ffmpeg error code=${code}`));\n          return;\n        }\n        const samples = new Int16Array(raw.buffer, raw.byteOffset, raw.byteLength / 2);\n        resolve(samples);\n      });\n\n      ff.stdin.write(mp3Buf);\n      ff.stdin.end();\n    });\n  }\n\n  /**\n   * Push PCM back to Janus in small frames\n   * We'll do 10ms @48k => 960 samples per frame\n   */\n  private async streamToJanus(samples: Int16Array, sampleRate: number): Promise<void> {\n    // TODO: Check if better than 480 fixed\n    const FRAME_SIZE = Math.floor(sampleRate * 0.01); // 10ms frames => 480 @48kHz\n\n    for (let offset = 0; offset + FRAME_SIZE <= samples.length; offset += FRAME_SIZE) {\n      if (this.ttsAbortController?.signal.aborted) {\n        logger.log('[SttTtsPlugin] streamToJanus interrupted');\n        return;\n      }\n      const frame = new Int16Array(FRAME_SIZE);\n      frame.set(samples.subarray(offset, offset + FRAME_SIZE));\n      this.janus?.pushLocalAudio(frame, sampleRate, 1);\n\n      // Short pause so we don't overload\n      await new Promise((r) => setTimeout(r, 10));\n    }\n  }\n\n  private async streamTtsStreamToJanus(\n    stream: Readable,\n    sampleRate: number,\n    signal: AbortSignal\n  ): Promise<void> {\n    const chunks: Buffer[] = [];\n\n    return new Promise((resolve, reject) => {\n      stream.on('data', (chunk: Buffer) => {\n        if (signal.aborted) {\n          logger.log('[SttTtsPlugin] Stream aborted, stopping playback');\n          stream.destroy();\n          reject(new Error('TTS streaming aborted'));\n          return;\n        }\n        chunks.push(chunk);\n      });\n\n      stream.on('end', async () => {\n        if (signal.aborted) {\n          logger.log('[SttTtsPlugin] Stream ended but was aborted');\n          return reject(new Error('TTS streaming aborted'));\n        }\n\n        const mp3Buffer = Buffer.concat(chunks);\n\n        try {\n          // Convert MP3 to PCM\n          const pcmSamples = await this.convertMp3ToPcm(mp3Buffer, sampleRate);\n\n          // Stream PCM to Janus\n          await this.streamToJanus(pcmSamples, sampleRate);\n          resolve();\n        } catch (error) {\n          reject(error);\n        }\n      });\n\n      stream.on('error', (error) => {\n        logger.error('[SttTtsPlugin] Error in TTS stream', error);\n        reject(error);\n      });\n    });\n  }\n\n  cleanup(): void {\n    logger.log('[SttTtsPlugin] cleanup => releasing resources');\n    this.pcmBuffers.clear();\n    this.userSpeakingTimer = null;\n    this.ttsQueue = [];\n    this.isSpeaking = false;\n    this.volumeBuffers.clear();\n  }\n}\n","import fs from 'node:fs';\nimport path from 'node:path';\nimport type { Media, ModelTypeName, State } from '@elizaos/core';\nimport {\n  ChannelType,\n  type Content,\n  type IAgentRuntime,\n  type Memory,\n  ModelType,\n  type UUID,\n  composePrompt,\n  createUniqueUuid,\n  logger,\n} from '@elizaos/core';\nimport type { ClientBase } from './base';\nimport type { Tweet } from './client';\nimport type { Tweet as ClientTweet } from './client/tweets';\nimport type { SttTtsPlugin } from './sttTtsSpaces';\nimport type { ActionResponse, MediaData } from './types';\nimport type { Tweet as CoreTweet } from './types';\n\nexport const wait = (minTime = 1000, maxTime = 3000) => {\n  const waitTime = Math.floor(Math.random() * (maxTime - minTime + 1)) + minTime;\n  return new Promise((resolve) => setTimeout(resolve, waitTime));\n};\n\nexport const isValidTweet = (tweet: Tweet): boolean => {\n  // Filter out tweets with too many hashtags, @s, or $ signs, probably spam or garbage\n  const hashtagCount = (tweet.text?.match(/#/g) || []).length;\n  const atCount = (tweet.text?.match(/@/g) || []).length;\n  const dollarSignCount = (tweet.text?.match(/\\$/g) || []).length;\n  const totalCount = hashtagCount + atCount + dollarSignCount;\n\n  return hashtagCount <= 1 && atCount <= 2 && dollarSignCount <= 1 && totalCount <= 3;\n};\n\n/**\n * Builds a conversation thread starting from a given tweet.\n * @param {Tweet} tweet - The tweet to start building the thread from.\n * @param {ClientBase} client - The client base object.\n * @param {number} [maxReplies=10] - The maximum number of replies to include in the thread.\n * @returns {Promise<Tweet[]>} The conversation thread as an array of tweets.\n */\nexport async function buildConversationThread(\n  tweet: Tweet,\n  client: ClientBase,\n  maxReplies = 10\n): Promise<Tweet[]> {\n  const thread: Tweet[] = [];\n  const visited: Set<string> = new Set();\n\n  async function processThread(currentTweet: Tweet, depth = 0) {\n    logger.debug('Processing tweet:', {\n      id: currentTweet.id,\n      inReplyToStatusId: currentTweet.inReplyToStatusId,\n      depth: depth,\n    });\n\n    if (!currentTweet) {\n      logger.debug('No current tweet found for thread building');\n      return;\n    }\n\n    // Stop if we've reached our reply limit\n    if (depth >= maxReplies) {\n      logger.debug('Reached maximum reply depth', depth);\n      return;\n    }\n\n    // Handle memory storage\n    const memory = await client.runtime.getMemoryById(\n      createUniqueUuid(this.runtime, currentTweet.id)\n    );\n    if (!memory) {\n      const roomId = createUniqueUuid(this.runtime, currentTweet.conversationId);\n      const entityId = createUniqueUuid(this.runtime, currentTweet.userId);\n\n      await client.runtime.ensureConnection({\n        entityId,\n        roomId,\n        userName: currentTweet.username,\n        name: currentTweet.name,\n        source: 'twitter',\n        type: ChannelType.GROUP,\n      });\n\n      await client.runtime.createMemory(\n        {\n          id: createUniqueUuid(this.runtime, currentTweet.id),\n          agentId: client.runtime.agentId,\n          content: {\n            text: currentTweet.text,\n            source: 'twitter',\n            url: currentTweet.permanentUrl,\n            imageUrls: currentTweet.photos.map((p) => p.url) || [],\n            inReplyTo: currentTweet.inReplyToStatusId\n              ? createUniqueUuid(this.runtime, currentTweet.inReplyToStatusId)\n              : undefined,\n          },\n          createdAt: currentTweet.timestamp * 1000,\n          roomId,\n          entityId:\n            currentTweet.userId === client.profile.id\n              ? client.runtime.agentId\n              : createUniqueUuid(this.runtime, currentTweet.userId),\n        },\n        'messages'\n      );\n    }\n\n    if (visited.has(currentTweet.id)) {\n      logger.debug('Already visited tweet:', currentTweet.id);\n      return;\n    }\n\n    visited.add(currentTweet.id);\n    thread.unshift(currentTweet);\n\n    logger.debug('Current thread state:', {\n      length: thread.length,\n      currentDepth: depth,\n      tweetId: currentTweet.id,\n    });\n\n    // If there's a parent tweet, fetch and process it\n    if (currentTweet.inReplyToStatusId) {\n      logger.debug('Fetching parent tweet:', currentTweet.inReplyToStatusId);\n      try {\n        const parentTweet = await client.twitterClient.getTweet(currentTweet.inReplyToStatusId);\n\n        if (parentTweet) {\n          logger.debug('Found parent tweet:', {\n            id: parentTweet.id,\n            text: parentTweet.text?.slice(0, 50),\n          });\n          await processThread(parentTweet, depth + 1);\n        } else {\n          logger.debug('No parent tweet found for:', currentTweet.inReplyToStatusId);\n        }\n      } catch (error) {\n        logger.error('Error fetching parent tweet:', {\n          tweetId: currentTweet.inReplyToStatusId,\n          error,\n        });\n      }\n    } else {\n      logger.debug('Reached end of reply chain at:', currentTweet.id);\n    }\n  }\n\n  await processThread(tweet, 0);\n\n  logger.debug('Final thread built:', {\n    totalTweets: thread.length,\n    tweetIds: thread.map((t) => ({\n      id: t.id,\n      text: t.text?.slice(0, 50),\n    })),\n  });\n\n  return thread;\n}\n\n/**\n * Fetches media data from a list of attachments, supporting both HTTP URLs and local file paths.\n *\n * @param attachments Array of Media objects containing URLs or file paths to fetch media from\n * @returns Promise that resolves with an array of MediaData objects containing the fetched media data and content type\n */\nexport async function fetchMediaData(attachments: Media[]): Promise<MediaData[]> {\n  return Promise.all(\n    attachments.map(async (attachment: Media) => {\n      if (/^(http|https):\\/\\//.test(attachment.url)) {\n        // Handle HTTP URLs\n        const response = await fetch(attachment.url);\n        if (!response.ok) {\n          throw new Error(`Failed to fetch file: ${attachment.url}`);\n        }\n        const mediaBuffer = Buffer.from(await response.arrayBuffer());\n        const mediaType = attachment.contentType || 'image/png';\n        return { data: mediaBuffer, mediaType };\n      }\n      if (fs.existsSync(attachment.url)) {\n        // Handle local file paths\n        const mediaBuffer = await fs.promises.readFile(path.resolve(attachment.url));\n        const mediaType = attachment.contentType || 'image/png';\n        return { data: mediaBuffer, mediaType };\n      }\n      throw new Error(`File not found: ${attachment.url}. Make sure the path is correct.`);\n    })\n  );\n}\n\n/**\n * Sends a tweet on Twitter using the given client.\n *\n * @param {ClientBase} client The client used to send the tweet.\n * @param {Content} content The content of the tweet.\n * @param {UUID} roomId The ID of the room where the tweet will be sent.\n * @param {string} twitterUsername The Twitter username of the sender.\n * @param {string} inReplyTo The ID of the tweet to which the new tweet will reply.\n * @returns {Promise<Memory[]>} An array of memories representing the sent tweets.\n */\nexport async function sendTweet(\n  client: ClientBase,\n  content: Content,\n  roomId: UUID,\n  twitterUsername: string,\n  inReplyTo: string\n): Promise<Memory[]> {\n  const isLongTweet = content.text.length > 280 - 1;\n\n  const tweetChunks = splitTweetContent(content.text, 280 - 1);\n  const sentTweets: Tweet[] = [];\n  let previousTweetId = inReplyTo;\n\n  for (const chunk of tweetChunks) {\n    let mediaData = null;\n\n    if (content.attachments && content.attachments.length > 0) {\n      mediaData = await fetchMediaData(content.attachments);\n    }\n\n    const cleanChunk = deduplicateMentions(chunk.trim());\n\n    const result = await client.requestQueue.add(async () =>\n      isLongTweet\n        ? client.twitterClient.sendLongTweet(cleanChunk, previousTweetId, mediaData)\n        : client.twitterClient.sendTweet(cleanChunk, previousTweetId, mediaData)\n    );\n\n    const body = await result.json();\n    const tweetResult = isLongTweet\n      ? body?.data?.notetweet_create?.tweet_results?.result\n      : body?.data?.create_tweet?.tweet_results?.result;\n\n    // if we have a response\n    if (tweetResult) {\n      // Parse the response\n      const finalTweet: Tweet = {\n        id: tweetResult.rest_id,\n        text: tweetResult.legacy.full_text,\n        conversationId: tweetResult.legacy.conversation_id_str,\n        timestamp: new Date(tweetResult.legacy.created_at).getTime() / 1000,\n        userId: tweetResult.legacy.user_id_str,\n        inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,\n        permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,\n        hashtags: [],\n        mentions: [],\n        photos: [],\n        thread: [],\n        urls: [],\n        videos: [],\n      };\n      sentTweets.push(finalTweet);\n      previousTweetId = finalTweet.id;\n    } else {\n      logger.error('Error sending tweet chunk:', {\n        chunk,\n        response: body,\n      });\n    }\n\n    // Wait a bit between tweets to avoid rate limiting issues\n    await wait(1000, 2000);\n  }\n\n  const memories: Memory[] = sentTweets.map((tweet) => ({\n    id: createUniqueUuid(client.runtime, tweet.id),\n    agentId: client.runtime.agentId,\n    entityId: client.runtime.agentId,\n    content: {\n      tweetId: tweet.id,\n      text: tweet.text,\n      source: 'twitter',\n      url: tweet.permanentUrl,\n      imageUrls: tweet.photos.map((p) => p.url) || [],\n      inReplyTo: tweet.inReplyToStatusId\n        ? createUniqueUuid(client.runtime, tweet.inReplyToStatusId)\n        : undefined,\n    },\n    roomId,\n    createdAt: tweet.timestamp * 1000,\n  }));\n\n  return memories;\n}\n\n/**\n * Splits the given content into individual tweets based on the maximum length allowed for a tweet.\n * @param {string} content - The content to split into tweets.\n * @param {number} maxLength - The maximum length allowed for a single tweet.\n * @returns {string[]} An array of strings representing individual tweets.\n */\nfunction splitTweetContent(content: string, maxLength: number): string[] {\n  const paragraphs = content.split('\\n\\n').map((p) => p.trim());\n  const tweets: string[] = [];\n  let currentTweet = '';\n\n  for (const paragraph of paragraphs) {\n    if (!paragraph) continue;\n\n    if (`${currentTweet}\\n\\n${paragraph}`.trim().length <= maxLength) {\n      if (currentTweet) {\n        currentTweet += `\\n\\n${paragraph}`;\n      } else {\n        currentTweet = paragraph;\n      }\n    } else {\n      if (currentTweet) {\n        tweets.push(currentTweet.trim());\n      }\n      if (paragraph.length <= maxLength) {\n        currentTweet = paragraph;\n      } else {\n        // Split long paragraph into smaller chunks\n        const chunks = splitParagraph(paragraph, maxLength);\n        tweets.push(...chunks.slice(0, -1));\n        currentTweet = chunks[chunks.length - 1];\n      }\n    }\n  }\n\n  if (currentTweet) {\n    tweets.push(currentTweet.trim());\n  }\n\n  return tweets;\n}\n\n/**\n * Extracts URLs from a given paragraph and replaces them with placeholders.\n *\n * @param {string} paragraph - The paragraph containing URLs that need to be replaced\n * @returns {Object} An object containing the updated text with placeholders and a map of placeholders to original URLs\n */\nfunction extractUrls(paragraph: string): {\n  textWithPlaceholders: string;\n  placeholderMap: Map<string, string>;\n} {\n  // replace https urls with placeholder\n  const urlRegex = /https?:\\/\\/[^\\s]+/g;\n  const placeholderMap = new Map<string, string>();\n\n  let urlIndex = 0;\n  const textWithPlaceholders = paragraph.replace(urlRegex, (match) => {\n    // twitter url would be considered as 23 characters\n    // <<URL_CONSIDERER_23_1>> is also 23 characters\n    const placeholder = `<<URL_CONSIDERER_23_${urlIndex}>>`; // Placeholder without . ? ! etc\n    placeholderMap.set(placeholder, match);\n    urlIndex++;\n    return placeholder;\n  });\n\n  return { textWithPlaceholders, placeholderMap };\n}\n\n/**\n * Splits a given text into chunks based on the specified maximum length while preserving sentence boundaries.\n *\n * @param {string} text - The text to be split into chunks\n * @param {number} maxLength - The maximum length each chunk should not exceed\n *\n * @returns {string[]} An array of chunks where each chunk is within the specified maximum length\n */\nfunction splitSentencesAndWords(text: string, maxLength: number): string[] {\n  // Split by periods, question marks and exclamation marks\n  // Note that URLs in text have been replaced with `<<URL_xxx>>` and won't be split by dots\n  const sentences = text.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [text];\n  const chunks: string[] = [];\n  let currentChunk = '';\n\n  for (const sentence of sentences) {\n    if (`${currentChunk} ${sentence}`.trim().length <= maxLength) {\n      if (currentChunk) {\n        currentChunk += ` ${sentence}`;\n      } else {\n        currentChunk = sentence;\n      }\n    } else {\n      // Can't fit more, push currentChunk to results\n      if (currentChunk) {\n        chunks.push(currentChunk.trim());\n      }\n\n      // If current sentence itself is less than or equal to maxLength\n      if (sentence.length <= maxLength) {\n        currentChunk = sentence;\n      } else {\n        // Need to split sentence by spaces\n        const words = sentence.split(' ');\n        currentChunk = '';\n        for (const word of words) {\n          if (`${currentChunk} ${word}`.trim().length <= maxLength) {\n            if (currentChunk) {\n              currentChunk += ` ${word}`;\n            } else {\n              currentChunk = word;\n            }\n          } else {\n            if (currentChunk) {\n              chunks.push(currentChunk.trim());\n            }\n            currentChunk = word;\n          }\n        }\n      }\n    }\n  }\n\n  // Handle remaining content\n  if (currentChunk) {\n    chunks.push(currentChunk.trim());\n  }\n\n  return chunks;\n}\n\n/**\n * Deduplicates mentions at the beginning of a paragraph.\n *\n * @param {string} paragraph - The input paragraph containing mentions.\n * @returns {string} - The paragraph with deduplicated mentions.\n */\nfunction deduplicateMentions(paragraph: string) {\n  // Regex to match mentions at the beginning of the string\n  const mentionRegex = /^@(\\w+)(?:\\s+@(\\w+))*(\\s+|$)/;\n\n  // Find all matches\n  const matches = paragraph.match(mentionRegex);\n\n  if (!matches) {\n    return paragraph; // If no matches, return the original string\n  }\n\n  // Extract mentions from the match groups\n  let mentions = matches.slice(0, 1)[0].trim().split(' ');\n\n  // Deduplicate mentions\n  mentions = Array.from(new Set(mentions));\n\n  // Reconstruct the string with deduplicated mentions\n  const uniqueMentionsString = mentions.join(' ');\n\n  // Find where the mentions end in the original string\n  const endOfMentions = paragraph.indexOf(matches[0]) + matches[0].length;\n\n  // Construct the result by combining unique mentions with the rest of the string\n  return `${uniqueMentionsString} ${paragraph.slice(endOfMentions)}`;\n}\n\n/**\n * Restores the original URLs in the chunks by replacing placeholder URLs.\n *\n * @param {string[]} chunks - Array of strings representing chunks of text containing placeholder URLs.\n * @param {Map<string, string>} placeholderMap - Map with placeholder URLs as keys and original URLs as values.\n * @returns {string[]} - Array of strings with original URLs restored in each chunk.\n */\nfunction restoreUrls(chunks: string[], placeholderMap: Map<string, string>): string[] {\n  return chunks.map((chunk) => {\n    // Replace all <<URL_CONSIDERER_23_>> in chunk back to original URLs using regex\n    return chunk.replace(/<<URL_CONSIDERER_23_(\\d+)>>/g, (match) => {\n      const original = placeholderMap.get(match);\n      return original || match; // Return placeholder if not found (theoretically won't happen)\n    });\n  });\n}\n\n/**\n * Splits a paragraph into chunks of text with a maximum length, while preserving URLs.\n *\n * @param {string} paragraph - The paragraph to split.\n * @param {number} maxLength - The maximum length of each chunk.\n * @returns {string[]} An array of strings representing the splitted chunks of text.\n */\nfunction splitParagraph(paragraph: string, maxLength: number): string[] {\n  // 1) Extract URLs and replace with placeholders\n  const { textWithPlaceholders, placeholderMap } = extractUrls(paragraph);\n\n  // 2) Use first section's logic to split by sentences first, then do secondary split\n  const splittedChunks = splitSentencesAndWords(textWithPlaceholders, maxLength);\n\n  // 3) Replace placeholders back to original URLs\n  const restoredChunks = restoreUrls(splittedChunks, placeholderMap);\n\n  return restoredChunks;\n}\n\n/**\n * Parses the action response from the given text.\n *\n * @param {string} text - The text to parse actions from.\n * @returns {{ actions: ActionResponse }} The parsed actions with boolean values indicating if each action is present in the text.\n */\nexport const parseActionResponseFromText = (text: string): { actions: ActionResponse } => {\n  const actions: ActionResponse = {\n    like: false,\n    retweet: false,\n    quote: false,\n    reply: false,\n  };\n\n  // Regex patterns\n  const likePattern = /\\[LIKE\\]/i;\n  const retweetPattern = /\\[RETWEET\\]/i;\n  const quotePattern = /\\[QUOTE\\]/i;\n  const replyPattern = /\\[REPLY\\]/i;\n\n  // Check with regex\n  actions.like = likePattern.test(text);\n  actions.retweet = retweetPattern.test(text);\n  actions.quote = quotePattern.test(text);\n  actions.reply = replyPattern.test(text);\n\n  // Also do line by line parsing as backup\n  const lines = text.split('\\n');\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (trimmed === '[LIKE]') actions.like = true;\n    if (trimmed === '[RETWEET]') actions.retweet = true;\n    if (trimmed === '[QUOTE]') actions.quote = true;\n    if (trimmed === '[REPLY]') actions.reply = true;\n  }\n\n  return { actions };\n};\n\n/**\n * Generates tweet actions based on the given prompt and model type using the provided runtime.\n * @param {{\n *     runtime: IAgentRuntime;\n *     prompt: string;\n *     modelType: ModelTypeName;\n * }} params - Parameters including the runtime, prompt, and model type.\n * @returns {Promise<ActionResponse | null>} The generated actions or null if no valid response.\n */\nexport async function generateTweetActions({\n  runtime,\n  prompt,\n  modelType,\n}: {\n  runtime: IAgentRuntime;\n  prompt: string;\n  modelType: ModelTypeName;\n}): Promise<ActionResponse | null> {\n  let retryDelay = 1000;\n  while (true) {\n    try {\n      const response = await runtime.useModel(modelType, {\n        prompt,\n      });\n      logger.debug('Received response from generateText for tweet actions:', response);\n      const { actions } = parseActionResponseFromText(response.trim());\n      if (actions) {\n        logger.debug('Parsed tweet actions:', actions);\n        return actions;\n      }\n      logger.debug('generateTweetActions no valid response');\n    } catch (error) {\n      logger.error('Error in generateTweetActions:', error);\n      if (error instanceof TypeError && error.message.includes('queueTextCompletion')) {\n        logger.error(\"TypeError: Cannot read properties of null (reading 'queueTextCompletion')\");\n      }\n    }\n    logger.log(`Retrying in ${retryDelay}ms...`);\n    await new Promise((resolve) => setTimeout(resolve, retryDelay));\n    retryDelay *= 2;\n  }\n}\n\n/**\n * Generate short filler text via GPT\n */\n/**\n * Generates a short filler message for a Twitter Space based on the specified filler type.\n *\n * @param {IAgentRuntime} runtime - The agent runtime instance to use for generating the filler.\n * @param {string} fillerType - The type of filler message to generate.\n * @returns {Promise<string>} The generated filler message as a string.\n */\nexport async function generateFiller(runtime: IAgentRuntime, fillerType: string): Promise<string> {\n  try {\n    const prompt = composePrompt({\n      state: {\n        values: {\n          fillerType,\n        },\n      } as any as State,\n      template: `\n# INSTRUCTIONS:\nYou are generating a short filler message for a Twitter Space. The filler type is \"{{fillerType}}\".\nKeep it brief, friendly, and relevant. No more than two sentences.\nOnly return the text, no additional formatting.\n\n---\n`,\n    });\n    const output = await runtime.useModel(ModelType.TEXT_SMALL, {\n      prompt,\n    });\n    return output.trim();\n  } catch (err) {\n    logger.error('[generateFiller] Error generating filler:', err);\n    return '';\n  }\n}\n\n/**\n * Speak a filler message if STT/TTS plugin is available. Sleep a bit after TTS to avoid cutoff.\n */\nexport async function speakFiller(\n  runtime: IAgentRuntime,\n  sttTtsPlugin: SttTtsPlugin | undefined,\n  fillerType: string,\n  sleepAfterMs = 3000\n): Promise<void> {\n  if (!sttTtsPlugin) return;\n  const text = await generateFiller(runtime, fillerType);\n  if (!text) return;\n\n  logger.log(`[Space] Filler (${fillerType}) => ${text}`);\n  await sttTtsPlugin.speakText(text);\n\n  if (sleepAfterMs > 0) {\n    await new Promise((res) => setTimeout(res, sleepAfterMs));\n  }\n}\n\n/**\n * Generate topic suggestions via GPT if no topics are configured\n */\nexport async function generateTopicsIfEmpty(runtime: IAgentRuntime): Promise<string[]> {\n  try {\n    const prompt = composePrompt({\n      state: {} as any,\n      template: `\n# INSTRUCTIONS:\nPlease generate 5 short topic ideas for a Twitter Space about technology or random interesting subjects.\nReturn them as a comma-separated list, no additional formatting or numbering.\n\nExample:\n\"AI Advances, Futuristic Gadgets, Space Exploration, Quantum Computing, Digital Ethics\"\n---\n`,\n    });\n    const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n      prompt,\n    });\n    const topics = response\n      .split(',')\n      .map((t) => t.trim())\n      .filter(Boolean);\n    return topics.length ? topics : ['Random Tech Chat', 'AI Thoughts'];\n  } catch (err) {\n    logger.error('[generateTopicsIfEmpty] GPT error =>', err);\n    return ['Random Tech Chat', 'AI Thoughts'];\n  }\n}\n\nexport async function isAgentInSpace(client: ClientBase, spaceId: string): Promise<boolean> {\n  const space = await client.twitterClient.getAudioSpaceById(spaceId);\n  const agentName = client.state.TWITTER_USERNAME;\n\n  return (\n    space.participants.listeners.some(\n      (participant) => participant.twitter_screen_name === agentName\n    ) ||\n    space.participants.speakers.some((participant) => participant.twitter_screen_name === agentName)\n  );\n}\n","import {\n  ChannelType,\n  type Content,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type UUID,\n  createUniqueUuid,\n  logger,\n} from '@elizaos/core';\nimport { Client, type QueryTweetsResponse, SearchMode, type Tweet } from './client/index';\nimport { TwitterInteractionPayload } from './types';\n\ninterface TwitterUser {\n  id_str: string;\n  screen_name: string;\n  name: string;\n}\n\ninterface TwitterFollowersResponse {\n  users: TwitterUser[];\n}\n\n/**\n * Extracts the answer from the given text.\n *\n * @param {string} text - The text containing the answer\n * @returns {string} The extracted answer\n */\nexport function extractAnswer(text: string): string {\n  const startIndex = text.indexOf('Answer: ') + 8;\n  const endIndex = text.indexOf('<|endoftext|>', 11);\n  return text.slice(startIndex, endIndex);\n}\n\n/**\n * Represents a Twitter Profile.\n * @typedef {Object} TwitterProfile\n * @property {string} id - The unique identifier of the profile.\n * @property {string} username - The username of the profile.\n * @property {string} screenName - The screen name of the profile.\n * @property {string} bio - The biography of the profile.\n * @property {string[]} nicknames - An array of nicknames associated with the profile.\n */\ntype TwitterProfile = {\n  id: string;\n  username: string;\n  screenName: string;\n  bio: string;\n  nicknames: string[];\n};\n\n/**\n * Class representing a request queue for handling asynchronous requests in a controlled manner.\n */\n\nclass RequestQueue {\n  private queue: (() => Promise<any>)[] = [];\n  private processing = false;\n\n  /**\n   * Asynchronously adds a request to the queue, then processes the queue.\n   *\n   * @template T\n   * @param {() => Promise<T>} request - The request to be added to the queue\n   * @returns {Promise<T>} - A promise that resolves with the result of the request or rejects with an error\n   */\n  async add<T>(request: () => Promise<T>): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.queue.push(async () => {\n        try {\n          const result = await request();\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        }\n      });\n      this.processQueue();\n    });\n  }\n\n  /**\n   * Asynchronously processes the queue of requests.\n   *\n   * @returns A promise that resolves when the queue has been fully processed.\n   */\n  private async processQueue(): Promise<void> {\n    if (this.processing || this.queue.length === 0) {\n      return;\n    }\n    this.processing = true;\n\n    while (this.queue.length > 0) {\n      const request = this.queue.shift()!;\n      try {\n        await request();\n      } catch (error) {\n        console.error('Error processing request:', error);\n        this.queue.unshift(request);\n        await this.exponentialBackoff(this.queue.length);\n      }\n      await this.randomDelay();\n    }\n\n    this.processing = false;\n  }\n\n  /**\n   * Implements an exponential backoff strategy for retrying a task.\n   * @param {number} retryCount - The number of retries attempted so far.\n   * @returns {Promise<void>} - A promise that resolves after a delay based on the retry count.\n   */\n  private async exponentialBackoff(retryCount: number): Promise<void> {\n    const delay = 2 ** retryCount * 1000;\n    await new Promise((resolve) => setTimeout(resolve, delay));\n  }\n\n  /**\n   * Asynchronous method that creates a random delay between 1500ms and 3500ms.\n   *\n   * @returns A Promise that resolves after the random delay has passed.\n   */\n  private async randomDelay(): Promise<void> {\n    const delay = Math.floor(Math.random() * 2000) + 1500;\n    await new Promise((resolve) => setTimeout(resolve, delay));\n  }\n}\n\n/**\n * Class representing a base client for interacting with Twitter.\n * @extends EventEmitter\n */\nexport class ClientBase {\n  static _twitterClients: { [accountIdentifier: string]: Client } = {};\n  twitterClient: Client;\n  runtime: IAgentRuntime;\n  lastCheckedTweetId: bigint | null = null;\n  temperature = 0.5;\n\n  requestQueue: RequestQueue = new RequestQueue();\n\n  profile: TwitterProfile | null;\n\n  /**\n   * Caches a tweet in the database.\n   *\n   * @param {Tweet} tweet - The tweet to cache.\n   * @returns {Promise<void>} A promise that resolves once the tweet is cached.\n   */\n  async cacheTweet(tweet: Tweet): Promise<void> {\n    if (!tweet) {\n      console.warn('Tweet is undefined, skipping cache');\n      return;\n    }\n\n    this.runtime.setCache<Tweet>(`twitter/tweets/${tweet.id}`, tweet);\n  }\n\n  /**\n   * Retrieves a cached tweet by its ID.\n   * @param {string} tweetId - The ID of the tweet to retrieve from the cache.\n   * @returns {Promise<Tweet | undefined>} A Promise that resolves to the cached tweet, or undefined if the tweet is not found in the cache.\n   */\n  async getCachedTweet(tweetId: string): Promise<Tweet | undefined> {\n    const cached = await this.runtime.getCache<Tweet>(`twitter/tweets/${tweetId}`);\n\n    if (!cached) {\n      return undefined;\n    }\n\n    return cached;\n  }\n\n  /**\n   * Asynchronously retrieves a tweet with the specified ID.\n   * If the tweet is found in the cache, it is returned from the cache.\n   * If not, a request is made to the Twitter API to get the tweet, which is then cached and returned.\n   * @param {string} tweetId - The ID of the tweet to retrieve.\n   * @returns {Promise<Tweet>} A Promise that resolves to the retrieved tweet.\n   */\n  async getTweet(tweetId: string): Promise<Tweet> {\n    const cachedTweet = await this.getCachedTweet(tweetId);\n\n    if (cachedTweet) {\n      return cachedTweet;\n    }\n\n    const tweet = await this.requestQueue.add(() => this.twitterClient.getTweet(tweetId));\n\n    await this.cacheTweet(tweet);\n    return tweet;\n  }\n\n  callback: (self: ClientBase) => any = null;\n\n  /**\n   * This method is called when the application is ready.\n   * It throws an error indicating that it is not implemented in the base class\n   * and should be implemented in the subclass.\n   */\n  onReady() {\n    throw new Error('Not implemented in base class, please call from subclass');\n  }\n\n  /**\n   * Parse the raw tweet data into a standardized Tweet object.\n   */\n  /**\n   * Parses a raw tweet object into a structured Tweet object.\n   *\n   * @param {any} raw - The raw tweet object to parse.\n   * @param {number} [depth=0] - The current depth of parsing nested quotes/retweets.\n   * @param {number} [maxDepth=3] - The maximum depth allowed for parsing nested quotes/retweets.\n   * @returns {Tweet} The parsed Tweet object.\n   */\n  parseTweet(raw: any, depth = 0, maxDepth = 3): Tweet {\n    // If we've reached maxDepth, don't parse nested quotes/retweets further\n    const canRecurse = depth < maxDepth;\n\n    const quotedStatus =\n      raw.quoted_status_result?.result && canRecurse\n        ? this.parseTweet(raw.quoted_status_result.result, depth + 1, maxDepth)\n        : undefined;\n\n    const retweetedStatus =\n      raw.retweeted_status_result?.result && canRecurse\n        ? this.parseTweet(raw.retweeted_status_result.result, depth + 1, maxDepth)\n        : undefined;\n\n    const t: Tweet = {\n      bookmarkCount: raw.bookmarkCount ?? raw.legacy?.bookmark_count ?? undefined,\n      conversationId: raw.conversationId ?? raw.legacy?.conversation_id_str,\n      hashtags: raw.hashtags ?? raw.legacy?.entities?.hashtags ?? [],\n      html: raw.html,\n      id: raw.id ?? raw.rest_id ?? raw.legacy.id_str ?? raw.id_str ?? undefined,\n      inReplyToStatus: raw.inReplyToStatus,\n      inReplyToStatusId:\n        raw.inReplyToStatusId ?? raw.legacy?.in_reply_to_status_id_str ?? undefined,\n      isQuoted: raw.legacy?.is_quote_status === true,\n      isPin: raw.isPin,\n      isReply: raw.isReply,\n      isRetweet: raw.legacy?.retweeted === true,\n      isSelfThread: raw.isSelfThread,\n      language: raw.legacy?.lang,\n      likes: raw.legacy?.favorite_count ?? 0,\n      name:\n        raw.name ??\n        raw?.user_results?.result?.legacy?.name ??\n        raw.core?.user_results?.result?.legacy?.name,\n      mentions: raw.mentions ?? raw.legacy?.entities?.user_mentions ?? [],\n      permanentUrl:\n        raw.permanentUrl ??\n        (raw.core?.user_results?.result?.legacy?.screen_name && raw.rest_id\n          ? `https://x.com/${raw.core?.user_results?.result?.legacy?.screen_name}/status/${raw.rest_id}`\n          : undefined),\n      photos:\n        raw.photos ??\n        (raw.legacy?.entities?.media\n          ?.filter((media: any) => media.type === 'photo')\n          .map((media: any) => ({\n            id: media.id_str || media.rest_id || media.legacy.id_str,\n            url: media.media_url_https,\n            alt_text: media.alt_text,\n          })) ||\n          []),\n      place: raw.place,\n      poll: raw.poll ?? null,\n      quotedStatus,\n      quotedStatusId: raw.quotedStatusId ?? raw.legacy?.quoted_status_id_str ?? undefined,\n      quotes: raw.legacy?.quote_count ?? 0,\n      replies: raw.legacy?.reply_count ?? 0,\n      retweets: raw.legacy?.retweet_count ?? 0,\n      retweetedStatus,\n      retweetedStatusId: raw.legacy?.retweeted_status_id_str ?? undefined,\n      text: raw.text ?? raw.legacy?.full_text ?? undefined,\n      thread: raw.thread || [],\n      timeParsed: raw.timeParsed\n        ? new Date(raw.timeParsed)\n        : raw.legacy?.created_at\n          ? new Date(raw.legacy?.created_at)\n          : undefined,\n      timestamp:\n        raw.timestamp ??\n        (raw.legacy?.created_at ? new Date(raw.legacy.created_at).getTime() / 1000 : undefined),\n      urls: raw.urls ?? raw.legacy?.entities?.urls ?? [],\n      userId: raw.userId ?? raw.legacy?.user_id_str ?? undefined,\n      username: raw.username ?? raw.core?.user_results?.result?.legacy?.screen_name ?? undefined,\n      videos:\n        raw.videos ??\n        raw.legacy?.entities?.media?.filter((media: any) => media.type === 'video') ??\n        [],\n      views: raw.views?.count ? Number(raw.views.count) : 0,\n      sensitiveContent: raw.sensitiveContent,\n    };\n\n    return t;\n  }\n\n  state: any;\n\n  constructor(runtime: IAgentRuntime, state: any) {\n    this.runtime = runtime;\n    this.state = state;\n    const username =\n      state?.TWITTER_USERNAME || (this.runtime.getSetting('TWITTER_USERNAME') as string);\n    if (ClientBase._twitterClients[username]) {\n      this.twitterClient = ClientBase._twitterClients[username];\n    } else {\n      this.twitterClient = new Client();\n      ClientBase._twitterClients[username] = this.twitterClient;\n    }\n  }\n\n  async init() {\n    // First ensure the agent exists in the database\n    await this.runtime.ensureAgentExists(this.runtime.character);\n\n    const username = this.state?.TWITTER_USERNAME || this.runtime.getSetting('TWITTER_USERNAME');\n    const password = this.state?.TWITTER_PASSWORD || this.runtime.getSetting('TWITTER_PASSWORD');\n    const email = this.state?.TWITTER_EMAIL || this.runtime.getSetting('TWITTER_EMAIL');\n    const twitter2faSecret =\n      this.state?.TWITTER_2FA_SECRET || this.runtime.getSetting('TWITTER_2FA_SECRET');\n\n    // Validate required credentials\n    if (!username || !password || !email) {\n      const missing = [];\n      if (!username) missing.push('TWITTER_USERNAME');\n      if (!password) missing.push('TWITTER_PASSWORD');\n      if (!email) missing.push('TWITTER_EMAIL');\n      throw new Error(`Missing required Twitter credentials: ${missing.join(', ')}`);\n    }\n\n    const maxRetries = 3;\n    let retryCount = 0;\n    let lastError: Error | null = null;\n\n    while (retryCount < maxRetries) {\n      try {\n        const authToken =\n          this.state?.TWITTER_COOKIES_AUTH_TOKEN ||\n          this.runtime.getSetting('TWITTER_COOKIES_AUTH_TOKEN');\n        const ct0 =\n          this.state?.TWITTER_COOKIES_CT0 || this.runtime.getSetting('TWITTER_COOKIES_CT0');\n        const guestId =\n          this.state?.TWITTER_COOKIES_GUEST_ID ||\n          this.runtime.getSetting('TWITTER_COOKIES_GUEST_ID');\n\n        const createTwitterCookies = (authToken: string, ct0: string, guestId: string) =>\n          authToken && ct0 && guestId\n            ? [\n                { key: 'auth_token', value: authToken, domain: '.twitter.com' },\n                { key: 'ct0', value: ct0, domain: '.twitter.com' },\n                { key: 'guest_id', value: guestId, domain: '.twitter.com' },\n              ]\n            : null;\n\n        const cachedCookies =\n          (await this.getCachedCookies(username)) || createTwitterCookies(authToken, ct0, guestId);\n\n        if (cachedCookies) {\n          logger.info('Using cached cookies');\n          await this.setCookiesFromArray(cachedCookies);\n        }\n\n        logger.log('Waiting for Twitter login');\n        if (await this.twitterClient.isLoggedIn()) {\n          // cookies are valid, no login required\n          logger.info('Successfully logged in.');\n          break;\n        }\n        await this.twitterClient.login(username, password, email, twitter2faSecret);\n        if (await this.twitterClient.isLoggedIn()) {\n          // fresh login, store new cookies\n          logger.info('Successfully logged in.');\n          logger.info('Caching cookies');\n          await this.cacheCookies(username, await this.twitterClient.getCookies());\n          break;\n        }\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n        logger.error(`Login attempt ${retryCount + 1} failed: ${lastError.message}`);\n        retryCount++;\n\n        if (retryCount < maxRetries) {\n          const delay = 2 ** retryCount * 1000; // Exponential backoff\n          logger.info(`Retrying in ${delay / 1000} seconds...`);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n      }\n    }\n\n    if (retryCount >= maxRetries) {\n      throw new Error(\n        `Twitter login failed after ${maxRetries} attempts. Last error: ${lastError?.message}`\n      );\n    }\n\n    // Initialize Twitter profile\n    this.profile = await this.fetchProfile(username);\n\n    if (this.profile) {\n      logger.log('Twitter user ID:', this.profile.id);\n      logger.log('Twitter loaded:', JSON.stringify(this.profile, null, 10));\n      // Store profile info for use in responses\n      this.profile = {\n        id: this.profile.id,\n        username: this.profile.username,\n        screenName: this.profile.screenName,\n        bio: this.profile.bio,\n        nicknames: this.profile.nicknames,\n      };\n    } else {\n      throw new Error('Failed to load profile');\n    }\n\n    await this.loadLatestCheckedTweetId();\n    await this.populateTimeline();\n  }\n\n  async fetchOwnPosts(count: number): Promise<Tweet[]> {\n    logger.debug('fetching own posts');\n    const homeTimeline = await this.twitterClient.getUserTweets(this.profile.id, count);\n    // Use parseTweet on each tweet\n    return homeTimeline.tweets.map((t) => this.parseTweet(t));\n  }\n\n  /**\n   * Fetch timeline for twitter account, optionally only from followed accounts\n   */\n  async fetchHomeTimeline(count: number, following?: boolean): Promise<Tweet[]> {\n    logger.debug('fetching home timeline');\n    const homeTimeline = following\n      ? await this.twitterClient.fetchFollowingTimeline(count, [])\n      : await this.twitterClient.fetchHomeTimeline(count, []);\n\n    const processedTimeline = homeTimeline\n      .filter((t) => t.__typename !== 'TweetWithVisibilityResults') // what's this about?\n      .map((tweet) => this.parseTweet(tweet));\n\n    //logger.debug(\"process homeTimeline\", processedTimeline);\n    return processedTimeline;\n  }\n\n  async fetchSearchTweets(\n    query: string,\n    maxTweets: number,\n    searchMode: SearchMode,\n    cursor?: string\n  ): Promise<QueryTweetsResponse> {\n    try {\n      // Sometimes this fails because we are rate limited. in this case, we just need to return an empty array\n      // if we dont get a response in 5 seconds, something is wrong\n      const timeoutPromise = new Promise((resolve) =>\n        setTimeout(() => resolve({ tweets: [] }), 15000)\n      );\n\n      try {\n        const result = await this.requestQueue.add(\n          async () =>\n            await Promise.race([\n              this.twitterClient.fetchSearchTweets(query, maxTweets, searchMode, cursor),\n              timeoutPromise,\n            ])\n        );\n        return (result ?? { tweets: [] }) as QueryTweetsResponse;\n      } catch (error) {\n        logger.error('Error fetching search tweets:', error);\n        return { tweets: [] };\n      }\n    } catch (error) {\n      logger.error('Error fetching search tweets:', error);\n      return { tweets: [] };\n    }\n  }\n\n  private async populateTimeline() {\n    logger.debug('populating timeline...');\n\n    const cachedTimeline = await this.getCachedTimeline();\n\n    // Check if the cache file exists\n    if (cachedTimeline) {\n      // Read the cached search results from the file\n\n      // Get the existing memories from the database\n      const existingMemories = await this.runtime.getMemoriesByRoomIds({\n        tableName: 'messages',\n        roomIds: cachedTimeline.map((tweet) =>\n          createUniqueUuid(this.runtime, tweet.conversationId)\n        ),\n      });\n\n      //TODO: load tweets not in cache?\n\n      // Create a Set to store the IDs of existing memories\n      const existingMemoryIds = new Set(existingMemories.map((memory) => memory.id.toString()));\n\n      // Check if any of the cached tweets exist in the existing memories\n      const someCachedTweetsExist = cachedTimeline.some((tweet) =>\n        existingMemoryIds.has(createUniqueUuid(this.runtime, tweet.id))\n      );\n\n      if (someCachedTweetsExist) {\n        // Filter out the cached tweets that already exist in the database\n        const tweetsToSave = cachedTimeline.filter(\n          (tweet) =>\n            tweet.userId !== this.profile.id &&\n            !existingMemoryIds.has(createUniqueUuid(this.runtime, tweet.id))\n        );\n\n        // Save the missing tweets as memories\n        for (const tweet of tweetsToSave) {\n          logger.log('Saving Tweet', tweet.id);\n\n          if (tweet.userId === this.profile.id) {\n            continue;\n          }\n\n          // Create a world for this Twitter user if it doesn't exist\n          const worldId = createUniqueUuid(this.runtime, tweet.userId) as UUID;\n          await this.runtime.ensureWorldExists({\n            id: worldId,\n            name: `${tweet.username}'s Twitter`,\n            agentId: this.runtime.agentId,\n            serverId: tweet.userId,\n            metadata: {\n              ownership: { ownerId: tweet.userId },\n              twitter: {\n                username: tweet.username,\n                id: tweet.userId,\n              },\n            },\n          });\n\n          const roomId = createUniqueUuid(this.runtime, tweet.conversationId);\n\n          // Ensure the room exists with proper world association\n          await this.runtime.ensureRoomExists({\n            id: roomId,\n            name: `${tweet.username}'s Thread`,\n            source: 'twitter',\n            type: ChannelType.FEED,\n            channelId: tweet.conversationId,\n            serverId: tweet.userId,\n            worldId: worldId,\n          });\n\n          const entityId =\n            tweet.userId === this.profile.id\n              ? this.runtime.agentId\n              : createUniqueUuid(this.runtime, tweet.userId);\n\n          // Ensure the entity exists with proper world association\n          await this.runtime.ensureConnection({\n            entityId,\n            roomId,\n            userName: tweet.username,\n            name: tweet.name,\n            source: 'twitter',\n            type: ChannelType.FEED,\n            worldId: worldId,\n          });\n\n          const content = {\n            text: tweet.text,\n            url: tweet.permanentUrl,\n            source: 'twitter',\n            inReplyTo: tweet.inReplyToStatusId\n              ? createUniqueUuid(this.runtime, tweet.inReplyToStatusId)\n              : undefined,\n          } as Content;\n\n          await this.runtime.createMemory(\n            {\n              id: createUniqueUuid(this.runtime, tweet.id),\n              entityId,\n              content: content,\n              agentId: this.runtime.agentId,\n              roomId,\n              createdAt: tweet.timestamp * 1000,\n            },\n            'messages'\n          );\n\n          await this.cacheTweet(tweet);\n        }\n\n        logger.log(`Populated ${tweetsToSave.length} missing tweets from the cache.`);\n        return;\n      }\n    }\n\n    const timeline = await this.fetchHomeTimeline(cachedTimeline ? 10 : 50);\n    const username = this.runtime.getSetting('TWITTER_USERNAME');\n\n    // Get the most recent 20 mentions and interactions\n    const mentionsAndInteractions = await this.fetchSearchTweets(\n      `@${username}`,\n      20,\n      SearchMode.Latest\n    );\n\n    // Combine the timeline tweets and mentions/interactions\n    const allTweets = [...timeline, ...mentionsAndInteractions.tweets];\n\n    // Create a Set to store unique tweet IDs\n    const tweetIdsToCheck = new Set<string>();\n    const roomIds = new Set<UUID>();\n\n    // Add tweet IDs to the Set\n    for (const tweet of allTweets) {\n      tweetIdsToCheck.add(tweet.id);\n      roomIds.add(createUniqueUuid(this.runtime, tweet.conversationId));\n    }\n\n    // Check the existing memories in the database\n    const existingMemories = await this.runtime.getMemoriesByRoomIds({\n      tableName: 'messages',\n      roomIds: Array.from(roomIds),\n    });\n\n    // Create a Set to store the existing memory IDs\n    const existingMemoryIds = new Set<UUID>(existingMemories.map((memory) => memory.id));\n\n    // Filter out the tweets that already exist in the database\n    const tweetsToSave = allTweets.filter(\n      (tweet) =>\n        tweet.userId !== this.profile.id &&\n        !existingMemoryIds.has(createUniqueUuid(this.runtime, tweet.id))\n    );\n\n    logger.debug({\n      processingTweets: tweetsToSave.map((tweet) => tweet.id).join(','),\n    });\n\n    // Save the new tweets as memories\n    for (const tweet of tweetsToSave) {\n      logger.log('Saving Tweet', tweet.id);\n\n      if (tweet.userId === this.profile.id) {\n        continue;\n      }\n\n      // Create a world for this Twitter user if it doesn't exist\n      const worldId = createUniqueUuid(this.runtime, tweet.userId) as UUID;\n      await this.runtime.ensureWorldExists({\n        id: worldId,\n        name: `${tweet.username}'s Twitter`,\n        agentId: this.runtime.agentId,\n        serverId: tweet.userId,\n        metadata: {\n          ownership: { ownerId: tweet.userId },\n          twitter: {\n            username: tweet.username,\n            id: tweet.userId,\n          },\n        },\n      });\n\n      const roomId = createUniqueUuid(this.runtime, tweet.conversationId);\n\n      // Ensure the room exists with proper world association\n      await this.runtime.ensureRoomExists({\n        id: roomId,\n        name: `${tweet.username}'s Thread`,\n        source: 'twitter',\n        type: ChannelType.FEED,\n        channelId: tweet.conversationId,\n        serverId: tweet.userId,\n        worldId: worldId,\n      });\n\n      const entityId =\n        tweet.userId === this.profile.id\n          ? this.runtime.agentId\n          : createUniqueUuid(this.runtime, tweet.userId);\n\n      // Ensure the entity exists with proper world association\n      await this.runtime.ensureConnection({\n        entityId,\n        roomId,\n        userName: tweet.username,\n        name: tweet.name,\n        source: 'twitter',\n        type: ChannelType.FEED,\n        worldId: worldId,\n      });\n\n      const content = {\n        text: tweet.text,\n        url: tweet.permanentUrl,\n        source: 'twitter',\n        inReplyTo: tweet.inReplyToStatusId\n          ? createUniqueUuid(this.runtime, tweet.inReplyToStatusId)\n          : undefined,\n      } as Content;\n\n      await this.runtime.createMemory(\n        {\n          id: createUniqueUuid(this.runtime, tweet.id),\n          entityId,\n          content: content,\n          agentId: this.runtime.agentId,\n          roomId,\n          createdAt: tweet.timestamp * 1000,\n        },\n        'messages'\n      );\n\n      await this.cacheTweet(tweet);\n    }\n\n    // Cache\n    await this.cacheTimeline(timeline);\n    await this.cacheMentions(mentionsAndInteractions.tweets);\n  }\n\n  async setCookiesFromArray(cookiesArray: any[]) {\n    const cookieStrings = cookiesArray.map(\n      (cookie) =>\n        `${cookie.key}=${cookie.value}; Domain=${cookie.domain}; Path=${\n          cookie.path\n        }; ${cookie.secure ? 'Secure' : ''}; ${\n          cookie.httpOnly ? 'HttpOnly' : ''\n        }; SameSite=${cookie.sameSite || 'Lax'}`\n    );\n    await this.twitterClient.setCookies(cookieStrings);\n  }\n\n  async saveRequestMessage(message: Memory, state: State) {\n    if (message.content.text) {\n      const recentMessage = await this.runtime.getMemories({\n        tableName: 'messages',\n        roomId: message.roomId,\n        count: 1,\n        unique: false,\n      });\n\n      if (recentMessage.length > 0 && recentMessage[0].content === message.content) {\n        logger.debug('Message already saved', recentMessage[0].id);\n      } else {\n        await this.runtime.createMemory(message, 'messages');\n      }\n\n      await this.runtime.evaluate(message, {\n        ...state,\n        twitterClient: this.twitterClient,\n      });\n    }\n  }\n\n  async loadLatestCheckedTweetId(): Promise<void> {\n    const latestCheckedTweetId = await this.runtime.getCache<string>(\n      `twitter/${this.profile.username}/latest_checked_tweet_id`\n    );\n\n    if (latestCheckedTweetId) {\n      this.lastCheckedTweetId = BigInt(latestCheckedTweetId);\n    }\n  }\n\n  async cacheLatestCheckedTweetId() {\n    if (this.lastCheckedTweetId) {\n      await this.runtime.setCache<string>(\n        `twitter/${this.profile.username}/latest_checked_tweet_id`,\n        this.lastCheckedTweetId.toString()\n      );\n    }\n  }\n\n  async getCachedTimeline(): Promise<Tweet[] | undefined> {\n    const cached = await this.runtime.getCache<Tweet[]>(\n      `twitter/${this.profile.username}/timeline`\n    );\n\n    if (!cached) {\n      return undefined;\n    }\n\n    return cached;\n  }\n\n  async cacheTimeline(timeline: Tweet[]) {\n    await this.runtime.setCache<Tweet[]>(`twitter/${this.profile.username}/timeline`, timeline);\n  }\n\n  async cacheMentions(mentions: Tweet[]) {\n    await this.runtime.setCache<Tweet[]>(`twitter/${this.profile.username}/mentions`, mentions);\n  }\n\n  async getCachedCookies(username: string) {\n    const cached = await this.runtime.getCache<any[]>(`twitter/${username}/cookies`);\n\n    if (!cached) {\n      return undefined;\n    }\n\n    return cached;\n  }\n\n  async cacheCookies(username: string, cookies: any[]) {\n    await this.runtime.setCache<any[]>(`twitter/${username}/cookies`, cookies);\n  }\n\n  async fetchProfile(username: string): Promise<TwitterProfile> {\n    try {\n      const profile = await this.requestQueue.add(async () => {\n        const profile = await this.twitterClient.getProfile(username);\n        return {\n          id: profile.userId,\n          username,\n          screenName: profile.name || this.runtime.character.name,\n          bio:\n            profile.biography || typeof this.runtime.character.bio === 'string'\n              ? (this.runtime.character.bio as string)\n              : this.runtime.character.bio.length > 0\n                ? this.runtime.character.bio[0]\n                : '',\n          nicknames: this.profile?.nicknames || [],\n        } satisfies TwitterProfile;\n      });\n\n      return profile;\n    } catch (error) {\n      console.error('Error fetching Twitter profile:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Fetches recent interactions (likes, retweets, quotes) for the authenticated user's tweets\n   */\n  async fetchInteractions() {\n    try {\n      const username = this.profile.username;\n      // Use fetchSearchTweets to get mentions instead of the non-existent get method\n      const mentionsResponse = await this.requestQueue.add(() =>\n        this.twitterClient.fetchSearchTweets(`@${username}`, 100, SearchMode.Latest)\n      );\n\n      // Process tweets directly into the expected interaction format\n      return mentionsResponse.tweets.map((tweet) => this.formatTweetToInteraction(tweet));\n    } catch (error) {\n      logger.error('Error fetching Twitter interactions:', error);\n      return [];\n    }\n  }\n\n  formatTweetToInteraction(tweet): TwitterInteractionPayload | null {\n    if (!tweet) return null;\n\n    const isQuote = tweet.isQuoted;\n    const isRetweet = !!tweet.retweetedStatus;\n    const type = isQuote ? 'quote' : isRetweet ? 'retweet' : 'like';\n\n    return {\n      id: tweet.id,\n      type,\n      userId: tweet.userId,\n      username: tweet.username,\n      name: tweet.name || tweet.username,\n      targetTweetId: tweet.inReplyToStatusId || tweet.quotedStatusId,\n      targetTweet: tweet.quotedStatus || tweet,\n      quoteTweet: isQuote ? tweet : undefined,\n      retweetId: tweet.retweetedStatus?.id,\n    };\n  }\n}\n","export const TWITTER_SERVICE_NAME = 'twitter';\n","import {\n  ChannelType,\n  type Content,\n  EventType,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  type MessagePayload,\n  ModelType,\n  composePrompt,\n  createUniqueUuid,\n  logger,\n} from '@elizaos/core';\nimport type { ClientBase } from './base';\nimport { SearchMode } from './client/index';\nimport type { Tweet as ClientTweet } from './client/tweets';\nimport type {\n  Tweet as CoreTweet,\n  TwitterInteractionMemory,\n  TwitterInteractionPayload,\n  TwitterLikeReceivedPayload,\n  TwitterMemory,\n  TwitterMentionReceivedPayload,\n  TwitterQuoteReceivedPayload,\n  TwitterRetweetReceivedPayload,\n  TwitterUserFollowedPayload,\n  TwitterUserUnfollowedPayload,\n} from './types';\nimport { TwitterEventTypes } from './types';\nimport { buildConversationThread } from './utils';\n\n/**\n * Template for generating dialog and actions for a Twitter message handler.\n *\n * @type {string}\n */\nexport const twitterMessageHandlerTemplate = `# Task: Generate dialog and actions for {{agentName}}.\n{{providers}}\nHere is the current post text again. Remember to include an action if the current post text includes a prompt that asks for one of the available actions mentioned above (does not need to be exact)\n{{currentPost}}\n{{imageDescriptions}}\n\n# Instructions: Write the next message for {{agentName}}. Include the appropriate action from the list: {{actionNames}}\nResponse format should be formatted in a valid JSON block like this:\n\\`\\`\\`json\n{ \"thought\": \"<string>\", \"name\": \"{{agentName}}\", \"text\": \"<string>\", \"action\": \"<string>\" }\n\\`\\`\\`\n\nThe \"action\" field should be one of the options in [Available Actions] and the \"text\" field should be the response you want to send. Do not including any thinking or internal reflection in the \"text\" field. \"thought\" should be a short description of what the agent is thinking about before responding, inlcuding a brief justification for the response.`;\n\n// Add conversion functions\nconst convertToCoreTweet = (tweet: ClientTweet): CoreTweet => ({\n  id: tweet.id,\n  text: tweet.text,\n  conversationId: tweet.conversationId,\n  timestamp: tweet.timestamp,\n  userId: tweet.userId,\n  username: tweet.username,\n  name: tweet.name,\n  inReplyToStatusId: tweet.inReplyToStatusId,\n  permanentUrl: tweet.permanentUrl,\n  photos: tweet.photos,\n  hashtags: tweet.hashtags,\n  mentions: tweet.mentions.map((mention) => mention.username),\n  urls: tweet.urls,\n  videos: tweet.videos,\n  thread: tweet.thread,\n});\n\nconst convertToCoreTweets = (tweets: ClientTweet[]): CoreTweet[] => tweets.map(convertToCoreTweet);\n\n/**\n * Class representing a client for interacting with Twitter.\n */\nexport class TwitterInteractionClient {\n  client: ClientBase;\n  runtime: IAgentRuntime;\n  private isDryRun: boolean;\n  private state: any;\n  /**\n   * Constructor for setting up a new instance with the provided client, runtime, and state.\n   * @param {ClientBase} client - The client being used for communication.\n   * @param {IAgentRuntime} runtime - The runtime environment for the agent.\n   * @param {any} state - The initial state of the agent.\n   */\n  constructor(client: ClientBase, runtime: IAgentRuntime, state: any) {\n    this.client = client;\n    this.runtime = runtime;\n    this.state = state;\n    this.isDryRun =\n      this.state?.TWITTER_DRY_RUN ||\n      (this.runtime.getSetting('TWITTER_DRY_RUN') as unknown as boolean);\n  }\n\n  /**\n   * Asynchronously starts the process of handling Twitter interactions on a loop.\n   * Uses an interval based on the 'TWITTER_POLL_INTERVAL' setting, or defaults to 2 minutes if not set.\n   */\n  async start() {\n    const handleTwitterInteractionsLoop = () => {\n      // Defaults to 2 minutes\n      const interactionInterval =\n        (this.state?.TWITTER_POLL_INTERVAL ||\n          (this.runtime.getSetting('TWITTER_POLL_INTERVAL') as unknown as number) ||\n          120) * 1000;\n\n      this.handleTwitterInteractions();\n      setTimeout(handleTwitterInteractionsLoop, interactionInterval);\n    };\n    handleTwitterInteractionsLoop();\n  }\n\n  /**\n   * Asynchronously handles Twitter interactions by checking for mentions, processing tweets, and updating the last checked tweet ID.\n   */\n  async handleTwitterInteractions() {\n    logger.log('Checking Twitter interactions');\n\n    const twitterUsername = this.client.profile?.username;\n    try {\n      // Check for mentions\n      const cursorKey = `twitter/${twitterUsername}/mention_cursor`;\n      const cachedCursor = await this.runtime.getCache<string>(cursorKey);\n\n      const searchResult = await this.client.fetchSearchTweets(\n        `@${twitterUsername}`,\n        20,\n        SearchMode.Latest,\n        cachedCursor\n      );\n\n      const mentionCandidates = searchResult.tweets;\n\n      // If we got tweets and there's a valid cursor, cache it\n      if (mentionCandidates.length > 0 && searchResult.previous) {\n        await this.runtime.setCache(cursorKey, searchResult.previous);\n      } else if (!searchResult.previous && !searchResult.next) {\n        // If both previous and next are missing, clear the outdated cursor\n        await this.runtime.setCache(cursorKey, null);\n      }\n\n      await this.processMentionTweets(mentionCandidates);\n\n      // 2. Format mentions into interactions\n      // TODO: EventType.REACTION_RECEIVED are not fully handled yet, re-enable once properly processed\n      // const interactionCandidates = mentionCandidates\n      //   .map((tweet) => this.client.formatTweetToInteraction?.(tweet))\n      //   .filter((i) => i?.targetTweet?.conversationId);\n\n      // for (const interaction of interactionCandidates) {\n      //   try {\n      //     await this.handleInteraction(interaction);\n      //   } catch (error) {\n      //     logger.erro(`Failed to process interaction ${interaction.id}`)\n      //   }\n      // }\n\n      // For follower changes:\n      // const processFollowerChange = async (\n      //   change: { type: string; userId: string },\n      //   profileId: string | undefined\n      // ) => {\n      //   if (change?.type && change?.userId && profileId) {\n      //     const followerMemory = this.createMemoryObject(\n      //       change.type,\n      //       `${change.type}-${change.userId}`,\n      //       change.userId,\n      //       profileId\n      //     );\n\n      //     await this.runtime.createMemory(followerMemory, 'follower-changes');\n      //   }\n      // };\n\n      // Save the latest checked tweet ID to the file\n      await this.client.cacheLatestCheckedTweetId();\n\n      logger.log('Finished checking Twitter interactions');\n    } catch (error) {\n      logger.error('Error handling Twitter interactions:', error);\n    }\n  }\n\n  /**\n   * Processes all incoming tweets that mention the bot.\n   * For each new tweet:\n   *  - Ensures world, room, and connection exist\n   *  - Saves the tweet as memory\n   *  - Emits thread-related events (THREAD_CREATED / THREAD_UPDATED)\n   *  - Delegates tweet content to `handleTweet` for reply generation\n   *\n   * Note: MENTION_RECEIVED is currently disabled (see TODO below)\n   */\n  async processMentionTweets(mentionCandidates: ClientTweet[]) {\n    logger.log('Completed checking mentioned tweets:', mentionCandidates.length);\n    let uniqueTweetCandidates = [...mentionCandidates];\n\n    // Sort tweet candidates by ID in ascending order\n    uniqueTweetCandidates = uniqueTweetCandidates\n      .sort((a, b) => a.id.localeCompare(b.id))\n      .filter((tweet) => tweet.userId !== this.client.profile.id);\n\n    // for each tweet candidate, handle the tweet\n    for (const tweet of uniqueTweetCandidates) {\n      if (!this.client.lastCheckedTweetId || BigInt(tweet.id) > this.client.lastCheckedTweetId) {\n        // Generate the tweetId UUID the same way it's done in handleTweet\n        const tweetId = createUniqueUuid(this.runtime, tweet.id);\n\n        // Check if we've already processed this tweet\n        const existingResponse = await this.runtime.getMemoryById(tweetId);\n\n        if (existingResponse) {\n          logger.log(`Already responded to tweet ${tweet.id}, skipping`);\n          continue;\n        }\n        logger.log('New Tweet found', tweet.permanentUrl);\n\n        const entityId = createUniqueUuid(\n          this.runtime,\n          tweet.userId === this.client.profile.id ? this.runtime.agentId : tweet.userId\n        );\n\n        // Create standardized world and room IDs\n        const worldId = createUniqueUuid(this.runtime, tweet.userId);\n        const roomId = createUniqueUuid(this.runtime, tweet.conversationId);\n\n        // Ensure world exists first\n        await this.runtime.ensureWorldExists({\n          id: worldId,\n          name: `${tweet.name}'s Twitter`,\n          agentId: this.runtime.agentId,\n          serverId: tweet.userId,\n          metadata: {\n            ownership: { ownerId: tweet.userId },\n            twitter: {\n              username: tweet.username,\n              id: tweet.userId,\n              name: tweet.name,\n            },\n          },\n        });\n\n        await this.runtime.ensureConnection({\n          entityId,\n          roomId,\n          userName: tweet.username,\n          name: tweet.name,\n          source: 'twitter',\n          type: ChannelType.GROUP,\n          channelId: tweet.conversationId,\n          serverId: tweet.userId,\n          worldId: worldId,\n        });\n\n        // Ensure conversation room exists\n        await this.runtime.ensureRoomExists({\n          id: roomId,\n          name: `Conversation with ${tweet.name}`,\n          source: 'twitter',\n          type: ChannelType.GROUP,\n          channelId: tweet.conversationId,\n          serverId: tweet.userId,\n          worldId: worldId,\n        });\n\n        // Create standardized message memory\n        const memory: Memory = {\n          id: tweetId,\n          agentId: this.runtime.agentId,\n          content: {\n            text: tweet.text,\n            url: tweet.permanentUrl,\n            imageUrls: tweet.photos?.map((photo) => photo.url) || [],\n            inReplyTo: tweet.inReplyToStatusId\n              ? createUniqueUuid(this.runtime, tweet.inReplyToStatusId)\n              : undefined,\n            source: 'twitter',\n            channelType: ChannelType.GROUP,\n            tweet,\n          },\n          entityId,\n          roomId,\n          createdAt: tweet.timestamp * 1000,\n        };\n        await this.runtime.createMemory(memory, 'messages');\n\n        // Emit mention received events\n        // TODO: Handle MENTION_RECEIVED event correctly before enabling again\n        // if (tweet.text.includes(`@${twitterUsername}`)) {\n        //   const messagePayload: MessagePayload = {\n        //     runtime: this.runtime,\n        //     message: {\n        //       ...memory,\n        //       source: 'twitter',\n        //     } as TwitterMemory,\n        //     source: 'twitter',\n        //     callback: async (response) => {\n        //       logger.info('Received message response:', response);\n        //       return [];\n        //     },\n        //   };\n\n        //   // Emit platform-specific MENTION_RECEIVED event\n        //   const mentionPayload: TwitterMentionReceivedPayload = {\n        //     runtime: this.runtime,\n        //     message: {\n        //       ...memory,\n        //       source: 'twitter',\n        //     } as TwitterMemory,\n        //     tweet: convertToCoreTweet(tweet),\n        //     user: {\n        //       id: tweet.userId,\n        //       username: tweet.username,\n        //       name: tweet.name,\n        //     },\n        //     source: 'twitter',\n        //     callback: async (response) => {\n        //       logger.info('Received mention response:', response);\n        //       return [];\n        //     },\n        //   };\n\n        //   this.runtime.emitEvent(TwitterEventTypes.MENTION_RECEIVED, mentionPayload);\n        // }\n\n        // Handle thread events\n        if (tweet.thread.length > 1) {\n          const threadPayload = {\n            runtime: this.runtime,\n            tweets: convertToCoreTweets(tweet.thread),\n            user: {\n              id: tweet.userId,\n              username: tweet.username,\n              name: tweet.name,\n            },\n            source: 'twitter',\n          };\n\n          if (tweet.thread[tweet.thread.length - 1].id === tweet.id) {\n            // This is a new tweet in an existing thread\n            this.runtime.emitEvent(TwitterEventTypes.THREAD_UPDATED, {\n              ...threadPayload,\n              newTweet: convertToCoreTweet(tweet),\n            });\n          } else if (tweet.thread[0].id === tweet.id) {\n            // This is the start of a new thread\n            this.runtime.emitEvent(TwitterEventTypes.THREAD_CREATED, threadPayload);\n          }\n        }\n\n        await this.handleTweet({\n          tweet,\n          message: memory,\n          thread: tweet.thread,\n        });\n\n        // Update the last checked tweet ID after processing each tweet\n        this.client.lastCheckedTweetId = BigInt(tweet.id);\n      }\n    }\n  }\n\n  /**\n   * Handles Twitter interactions such as likes, retweets, and quotes.\n   * For each interaction:\n   *  - Creates a memory object\n   *  - Emits platform-specific events (LIKE_RECEIVED, RETWEET_RECEIVED, QUOTE_RECEIVED)\n   *  - Emits a generic REACTION_RECEIVED event with metadata\n   */\n  async handleInteraction(interaction: TwitterInteractionPayload) {\n    if (interaction?.targetTweet?.conversationId) {\n      const memory = this.createMemoryObject(\n        interaction.type,\n        `${interaction.id}-${interaction.type}`,\n        interaction.userId,\n        interaction.targetTweet.conversationId\n      );\n\n      await this.runtime.createMemory(memory, 'messages');\n\n      // Create message for reaction\n      const reactionMessage: TwitterMemory = {\n        id: createUniqueUuid(this.runtime, interaction.targetTweetId),\n        content: {\n          text: interaction.targetTweet.text,\n          source: 'twitter',\n        },\n        entityId: createUniqueUuid(this.runtime, interaction.targetTweet.userId),\n        roomId: createUniqueUuid(this.runtime, interaction.targetTweet.conversationId),\n        agentId: this.runtime.agentId,\n      };\n\n      // Create base event payload\n      const basePayload = {\n        runtime: this.runtime,\n        user: {\n          id: interaction.userId,\n          username: interaction.username,\n          name: interaction.name,\n        },\n        source: 'twitter' as const,\n      };\n\n      // Emit platform-specific event\n      switch (interaction.type) {\n        case 'like': {\n          const likePayload: TwitterLikeReceivedPayload = {\n            ...basePayload,\n            tweet: interaction.targetTweet as unknown as CoreTweet,\n          };\n          // Emit platform-specific event\n          this.runtime.emitEvent(TwitterEventTypes.LIKE_RECEIVED, likePayload);\n\n          // Emit generic REACTION_RECEIVED event\n          this.runtime.emitEvent(EventType.REACTION_RECEIVED, {\n            ...basePayload,\n            reaction: {\n              type: 'like',\n              entityId: createUniqueUuid(this.runtime, interaction.userId),\n            },\n            message: reactionMessage,\n            callback: async () => {\n              return [];\n            },\n          } as MessagePayload);\n          break;\n        }\n\n        case 'retweet': {\n          const retweetPayload: TwitterRetweetReceivedPayload = {\n            ...basePayload,\n            tweet: interaction.targetTweet as unknown as CoreTweet,\n            retweetId: interaction.retweetId,\n          };\n          // Emit platform-specific event\n          this.runtime.emitEvent(TwitterEventTypes.RETWEET_RECEIVED, retweetPayload);\n\n          // Emit generic REACTION_RECEIVED event\n          this.runtime.emitEvent(EventType.REACTION_RECEIVED, {\n            ...basePayload,\n            reaction: {\n              type: 'retweet',\n              entityId: createUniqueUuid(this.runtime, interaction.userId),\n            },\n            message: reactionMessage,\n            callback: async () => {\n              return [];\n            },\n          } as MessagePayload);\n          break;\n        }\n\n        case 'quote': {\n          const quotePayload: TwitterQuoteReceivedPayload = {\n            ...basePayload,\n            message: reactionMessage,\n            quotedTweet: interaction.targetTweet as unknown as CoreTweet,\n            quoteTweet: (interaction.quoteTweet || interaction.targetTweet) as unknown as CoreTweet,\n            callback: async () => [],\n            reaction: {\n              type: 'quote',\n              entityId: createUniqueUuid(this.runtime, interaction.userId),\n            },\n          };\n          // Emit platform-specific event\n          this.runtime.emitEvent(TwitterEventTypes.QUOTE_RECEIVED, quotePayload);\n\n          // Emit generic REACTION_RECEIVED event\n          this.runtime.emitEvent(EventType.REACTION_RECEIVED, {\n            ...basePayload,\n            reaction: {\n              type: 'quote',\n              entityId: createUniqueUuid(this.runtime, interaction.userId),\n            },\n            message: reactionMessage,\n            callback: async () => {\n              return [];\n            },\n          } as MessagePayload);\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Handles a tweet by processing its content, formatting it, generating image descriptions,\n   * saving the tweet if it doesn't already exist, determining if a response should be sent,\n   * composing a response prompt, generating a response based on the prompt, handling the response\n   * tweet, and saving information about the response.\n   *\n   * @param {object} params - The parameters object containing the tweet, message, and thread.\n   * @param {Tweet} params.tweet - The tweet object to handle.\n   * @param {Memory} params.message - The memory object associated with the tweet.\n   * @param {Tweet[]} params.thread - The array of tweets in the thread.\n   * @returns {object} - An object containing the text of the response and any relevant actions.\n   */\n  async handleTweet({\n    tweet,\n    message,\n    thread,\n  }: {\n    tweet: ClientTweet;\n    message: Memory;\n    thread: ClientTweet[];\n  }) {\n    if (!message.content.text) {\n      logger.log('Skipping Tweet with no text', tweet.id);\n      return { text: '', actions: ['IGNORE'] };\n    }\n\n    logger.log('Processing Tweet: ', tweet.id);\n    const formatTweet = (tweet: ClientTweet) => {\n      return `  ID: ${tweet.id}\n  From: ${tweet.name} (@${tweet.username})\n  Text: ${tweet.text}`;\n    };\n    const currentPost = formatTweet(tweet);\n\n    const formattedConversation = thread\n      .map(\n        (tweet) => `@${tweet.username} (${new Date(tweet.timestamp * 1000).toLocaleString('en-US', {\n          hour: '2-digit',\n          minute: '2-digit',\n          month: 'short',\n          day: 'numeric',\n        })}):\n        ${tweet.text}`\n      )\n      .join('\\n\\n');\n\n    const imageDescriptionsArray = [];\n    try {\n      for (const photo of tweet.photos) {\n        const description = await this.runtime.useModel(ModelType.IMAGE_DESCRIPTION, photo.url);\n        imageDescriptionsArray.push(description);\n      }\n    } catch (error) {\n      // Handle the error\n      logger.error('Error Occured during describing image: ', error);\n    }\n\n    // Create a callback for handling the response\n    const callback: HandlerCallback = async (response: Content, tweetId?: string) => {\n      try {\n        if (!response.text) {\n          logger.warn('No text content in response, skipping tweet reply');\n          return [];\n        }\n\n        const tweetToReplyTo = tweetId || tweet.id;\n\n        if (this.isDryRun) {\n          logger.info(`[DRY RUN] Would have replied to ${tweet.username} with: ${response.text}`);\n          return [];\n        }\n\n        logger.info(`Replying to tweet ${tweetToReplyTo}`);\n\n        // Create the actual tweet using the Twitter API through the client\n        const replyTweetResult = await this.client.requestQueue.add(() =>\n          this.client.twitterClient.sendTweet(response.text.substring(0, 280), tweetToReplyTo)\n        );\n\n        if (!replyTweetResult) {\n          throw new Error('Failed to create tweet response');\n        }\n\n        // Parse the response to get the tweet ID\n        const responseBody = await (replyTweetResult as Response).json();\n        const tweetResult = responseBody?.data?.create_tweet?.tweet_results?.result;\n\n        if (!tweetResult) {\n          throw new Error('Failed to get tweet result from response');\n        }\n\n        // Create memory for our response\n        const responseId = createUniqueUuid(this.runtime, tweetResult.rest_id);\n        const responseMemory: Memory = {\n          id: responseId,\n          entityId: this.runtime.agentId,\n          agentId: this.runtime.agentId,\n          roomId: message.roomId,\n          content: {\n            ...response,\n            inReplyTo: message.id,\n          },\n          createdAt: Date.now(),\n        };\n\n        // Save the response to memory\n        await this.runtime.createMemory(responseMemory, 'messages');\n\n        return [responseMemory];\n      } catch (error) {\n        logger.error('Error replying to tweet:', error);\n        return [];\n      }\n    };\n\n    // Emit standardized event for handling the message\n    this.runtime.emitEvent(EventType.MESSAGE_RECEIVED, {\n      runtime: this.runtime,\n      message,\n      callback,\n      source: 'twitter',\n    } as MessagePayload);\n\n    return { text: '', actions: ['RESPOND'] };\n  }\n\n  /**\n   * Build a conversation thread based on a given tweet.\n   *\n   * @param {Tweet} tweet - The tweet to start the thread from.\n   * @param {number} [maxReplies=10] - The maximum number of replies to include in the thread.\n   * @returns {Promise<Tweet[]>} The conversation thread as an array of tweets.\n   */\n  async buildConversationThread(tweet: ClientTweet, maxReplies = 10): Promise<ClientTweet[]> {\n    const thread: ClientTweet[] = [];\n    const visited: Set<string> = new Set();\n\n    async function processThread(currentTweet: ClientTweet, depth = 0) {\n      logger.log('Processing tweet:', {\n        id: currentTweet.id,\n        inReplyToStatusId: currentTweet.inReplyToStatusId,\n        depth: depth,\n      });\n\n      if (!currentTweet) {\n        logger.log('No current tweet found for thread building');\n        return;\n      }\n\n      if (depth >= maxReplies) {\n        logger.log('Reached maximum reply depth', depth);\n        return;\n      }\n\n      // Handle memory storage\n      const memory = await this.runtime.getMemoryById(\n        createUniqueUuid(this.runtime, currentTweet.id)\n      );\n      if (!memory) {\n        const roomId = createUniqueUuid(this.runtime, tweet.conversationId);\n        const entityId = createUniqueUuid(this.runtime, currentTweet.userId);\n\n        await this.runtime.ensureConnection({\n          entityId,\n          roomId,\n          userName: currentTweet.username,\n          name: currentTweet.name,\n          source: 'twitter',\n          type: ChannelType.GROUP,\n        });\n\n        this.runtime.createMemory(\n          {\n            id: createUniqueUuid(this.runtime, currentTweet.id),\n            agentId: this.runtime.agentId,\n            content: {\n              text: currentTweet.text,\n              source: 'twitter',\n              url: currentTweet.permanentUrl,\n              imageUrls: currentTweet.photos?.map((photo) => photo.url) || [],\n              inReplyTo: currentTweet.inReplyToStatusId\n                ? createUniqueUuid(this.runtime, currentTweet.inReplyToStatusId)\n                : undefined,\n            },\n            createdAt: currentTweet.timestamp * 1000,\n            roomId,\n            entityId:\n              currentTweet.userId === this.twitterUserId\n                ? this.runtime.agentId\n                : createUniqueUuid(this.runtime, currentTweet.userId),\n          },\n          'messages'\n        );\n      }\n\n      if (visited.has(currentTweet.id)) {\n        logger.log('Already visited tweet:', currentTweet.id);\n        return;\n      }\n\n      visited.add(currentTweet.id);\n      thread.unshift(currentTweet);\n\n      if (currentTweet.inReplyToStatusId) {\n        logger.log('Fetching parent tweet:', currentTweet.inReplyToStatusId);\n        try {\n          const parentTweet = await this.twitterClient.getTweet(currentTweet.inReplyToStatusId);\n\n          if (parentTweet) {\n            logger.log('Found parent tweet:', {\n              id: parentTweet.id,\n              text: parentTweet.text?.slice(0, 50),\n            });\n            await processThread(parentTweet, depth + 1);\n          } else {\n            logger.log('No parent tweet found for:', currentTweet.inReplyToStatusId);\n          }\n        } catch (error) {\n          logger.log('Error fetching parent tweet:', {\n            tweetId: currentTweet.inReplyToStatusId,\n            error,\n          });\n        }\n      } else {\n        logger.log('Reached end of reply chain at:', currentTweet.id);\n      }\n    }\n\n    // Need to bind this prompt for the inner function\n    await processThread.bind(this)(tweet, 0);\n\n    return thread;\n  }\n\n  private createMemoryObject(\n    type: string,\n    id: string,\n    userId: string,\n    roomId: string\n  ): TwitterInteractionMemory {\n    return {\n      id: createUniqueUuid(this.runtime, id),\n      agentId: this.runtime.agentId,\n      entityId: createUniqueUuid(this.runtime, userId),\n      roomId: createUniqueUuid(this.runtime, roomId),\n      content: {\n        type,\n        source: 'twitter',\n      },\n      createdAt: Date.now(),\n    };\n  }\n}\n","import {\n  ChannelType,\n  type Content,\n  EventType,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  type UUID,\n  createUniqueUuid,\n  logger,\n  parseBooleanFromText,\n  truncateToCompleteSentence,\n} from '@elizaos/core';\nimport type { ClientBase } from './base';\nimport type { Tweet } from './client/index';\nimport type { MediaData } from './types';\nimport { TwitterEventTypes } from './types';\n/**\n * Class representing a Twitter post client for generating and posting tweets.\n */\nexport class TwitterPostClient {\n  client: ClientBase;\n  runtime: IAgentRuntime;\n  twitterUsername: string;\n  private isDryRun: boolean;\n  private state: any;\n\n  /**\n   * Constructor for initializing a new Twitter client with the provided client, runtime, and state\n   * @param {ClientBase} client - The client used for interacting with Twitter API\n   * @param {IAgentRuntime} runtime - The runtime environment for the agent\n   * @param {any} state - The state object containing configuration settings\n   */\n  constructor(client: ClientBase, runtime: IAgentRuntime, state: any) {\n    this.client = client;\n    this.state = state;\n    this.runtime = runtime;\n    this.twitterUsername =\n      state?.TWITTER_USERNAME || (this.runtime.getSetting('TWITTER_USERNAME') as string);\n    this.isDryRun =\n      this.state?.TWITTER_DRY_RUN ||\n      (this.runtime.getSetting('TWITTER_DRY_RUN') as unknown as boolean);\n\n    // Log configuration on initialization\n    logger.log('Twitter Client Configuration:');\n    logger.log(`- Username: ${this.twitterUsername}`);\n    logger.log(`- Dry Run Mode: ${this.isDryRun ? 'Enabled' : 'Disabled'}`);\n\n    this.state.isTwitterEnabled = parseBooleanFromText(\n      String(\n        this.state?.TWITTER_ENABLE_POST_GENERATION ||\n          this.runtime.getSetting('TWITTER_ENABLE_POST_GENERATION') ||\n          ''\n      )\n    );\n\n    logger.log(`- Auto-post: ${this.state.isTwitterEnabled ? 'enabled' : 'disabled'}`);\n\n    logger.log(\n      `- Post Interval: ${this.state?.TWITTER_POST_INTERVAL_MIN || this.runtime.getSetting('TWITTER_POST_INTERVAL_MIN')}-${this.state?.TWITTER_POST_INTERVAL_MAX || this.runtime.getSetting('TWITTER_POST_INTERVAL_MAX')} minutes`\n    );\n    logger.log(\n      `- Post Immediately: ${\n        this.state?.TWITTER_POST_IMMEDIATELY || this.runtime.getSetting('TWITTER_POST_IMMEDIATELY')\n          ? 'enabled'\n          : 'disabled'\n      }`\n    );\n\n    if (this.isDryRun) {\n      logger.log('Twitter client initialized in dry run mode - no actual tweets should be posted');\n    }\n  }\n\n  /**\n   * Starts the Twitter post client, setting up a loop to periodically generate new tweets.\n   */\n  async start() {\n    logger.log('Starting Twitter post client...');\n    const tweetGeneration = this.state.isTwitterEnabled;\n    if (tweetGeneration === false) {\n      logger.log('Tweet generation is disabled');\n      return;\n    }\n\n    const generateNewTweetLoop = async () => {\n      // Defaults to 30 minutes\n      const interval =\n        (this.state?.TWITTER_POST_INTERVAL ||\n          (this.runtime.getSetting('TWITTER_POST_INTERVAL') as unknown as number) ||\n          30) *\n        60 *\n        1000;\n\n      this.generateNewTweet();\n      setTimeout(generateNewTweetLoop, interval);\n    };\n\n    // Start the loop after a 1 minute delay to allow other services to initialize\n    setTimeout(generateNewTweetLoop, 60 * 1000);\n    if (this.runtime.getSetting('TWITTER_POST_IMMEDIATELY')) {\n      // await 1 second\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n      this.generateNewTweet();\n    }\n  }\n\n  /**\n   * Creates a Tweet object based on the tweet result, client information, and Twitter username.\n   *\n   * @param {any} tweetResult - The result object from the Twitter API representing a tweet.\n   * @param {any} client - The client object containing profile information.\n   * @param {string} twitterUsername - The Twitter username of the user.\n   * @returns {Tweet} A Tweet object with specific properties extracted from the tweet result and client information.\n   */\n  createTweetObject(tweetResult: any, client: any, twitterUsername: string): Tweet {\n    return {\n      id: tweetResult.rest_id,\n      name: client.profile.screenName,\n      username: client.profile.username,\n      text: tweetResult.legacy.full_text,\n      conversationId: tweetResult.legacy.conversation_id_str,\n      createdAt: tweetResult.legacy.created_at,\n      timestamp: new Date(tweetResult.legacy.created_at).getTime(),\n      userId: client.profile.id,\n      inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,\n      permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,\n      hashtags: [],\n      mentions: [],\n      photos: [],\n      thread: [],\n      urls: [],\n      videos: [],\n    } as Tweet;\n  }\n\n  /**\n   * Processes and caches a tweet.\n   *\n   * @param {IAgentRuntime} runtime - The agent runtime.\n   * @param {ClientBase} client - The client object.\n   * @param {Tweet} tweet - The tweet to be processed and cached.\n   * @param {UUID} roomId - The ID of the room where the tweet will be stored.\n   * @param {string} rawTweetContent - The raw content of the tweet.\n   */\n  async processAndCacheTweet(\n    runtime: IAgentRuntime,\n    client: ClientBase,\n    tweet: Tweet,\n    roomId: UUID,\n    rawTweetContent: string\n  ) {\n    // Cache the last post details\n    await runtime.setCache<any>(`twitter/${client.profile.username}/lastPost`, {\n      id: tweet.id,\n      timestamp: Date.now(),\n    });\n\n    // Cache the tweet\n    await client.cacheTweet(tweet);\n\n    // Log the posted tweet\n    logger.log(`Tweet posted:\\n ${tweet.permanentUrl}`);\n\n    // Ensure the room and participant exist\n    await runtime.ensureRoomExists({\n      id: roomId,\n      name: 'Twitter Feed',\n      source: 'twitter',\n      type: ChannelType.FEED,\n    });\n    await runtime.ensureParticipantInRoom(runtime.agentId, roomId);\n\n    // Create a memory for the tweet\n    await runtime.createMemory(\n      {\n        id: createUniqueUuid(this.runtime, tweet.id),\n        entityId: runtime.agentId,\n        agentId: runtime.agentId,\n        content: {\n          text: rawTweetContent.trim(),\n          url: tweet.permanentUrl,\n          source: 'twitter',\n        },\n        roomId,\n        createdAt: tweet.timestamp,\n      },\n      'messages'\n    );\n  }\n\n  /**\n   * Handles sending a note tweet with optional media data.\n   *\n   * @param {ClientBase} client - The client object used for sending the note tweet.\n   * @param {string} content - The content of the note tweet.\n   * @param {string} [tweetId] - Optional Tweet ID to reply to.\n   * @param {MediaData[]} [mediaData] - Optional media data to attach to the note tweet.\n   * @returns {Promise<Object>} - The result of the note tweet operation.\n   * @throws {Error} - If the note tweet operation fails.\n   */\n  async handleNoteTweet(\n    client: ClientBase,\n    content: string,\n    tweetId?: string,\n    mediaData?: MediaData[]\n  ) {\n    try {\n      const noteTweetResult = await client.requestQueue.add(\n        async () => await client.twitterClient.sendNoteTweet(content, tweetId, mediaData)\n      );\n\n      if (noteTweetResult.errors && noteTweetResult.errors.length > 0) {\n        // Note Tweet failed due to authorization. Falling back to standard Tweet.\n        const truncateContent = truncateToCompleteSentence(content, 280 - 1);\n        return await this.sendStandardTweet(client, truncateContent, tweetId);\n      }\n      return noteTweetResult.data.notetweet_create.tweet_results.result;\n    } catch (error) {\n      throw new Error(`Note Tweet failed: ${error}`);\n    }\n  }\n\n  /**\n   * Asynchronously sends a standard tweet using the provided Twitter client.\n   *\n   * @param {ClientBase} client - The client used to make the request.\n   * @param {string} content - The content of the tweet.\n   * @param {string} [tweetId] - Optional tweet ID to reply to.\n   * @param {MediaData[]} [mediaData] - Optional array of media data to attach to the tweet.\n   * @returns {Promise<string>} The result of sending the tweet.\n   */\n  async sendStandardTweet(\n    client: ClientBase,\n    content: string,\n    tweetId?: string,\n    mediaData?: MediaData[]\n  ) {\n    try {\n      const standardTweetResult = await client.requestQueue.add(\n        async () => await client.twitterClient.sendTweet(content, tweetId, mediaData)\n      );\n      const body = await standardTweetResult.json();\n      if (!body?.data?.create_tweet?.tweet_results?.result) {\n        logger.error('Error sending tweet; Bad response:', body);\n        return;\n      }\n      return body.data.create_tweet.tweet_results.result;\n    } catch (error) {\n      logger.error('Error sending standard Tweet:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Posts a new tweet with the provided tweet content and optional media data.\n   *\n   * @param {IAgentRuntime} runtime - The runtime environment for the agent.\n   * @param {ClientBase} client - The Twitter client used to post the tweet.\n   * @param {string} tweetTextForPosting - The text content of the tweet.\n   * @param {UUID} roomId - The ID of the room where the tweet will be posted.\n   * @param {string} rawTweetContent - The raw content of the tweet.\n   * @param {string} twitterUsername - The username associated with the Twitter account.\n   * @param {MediaData[]} [mediaData] - Optional media data to be included in the tweet.\n   * @returns {Promise<void>} - A Promise that resolves when the tweet is successfully posted.\n   */\n  async postTweet(\n    runtime: IAgentRuntime,\n    client: ClientBase,\n    tweetTextForPosting: string,\n    roomId: UUID,\n    rawTweetContent: string,\n    twitterUsername: string,\n    mediaData?: MediaData[]\n  ) {\n    try {\n      logger.log('Posting new tweet:\\n');\n\n      let result;\n\n      if (tweetTextForPosting.length > 280 - 1) {\n        result = await this.handleNoteTweet(client, tweetTextForPosting, undefined, mediaData);\n      } else {\n        result = await this.sendStandardTweet(client, tweetTextForPosting, undefined, mediaData);\n      }\n      const tweet = this.createTweetObject(result, client, twitterUsername);\n\n      await this.processAndCacheTweet(runtime, client, tweet, roomId, rawTweetContent);\n    } catch (error) {\n      logger.error('Error sending tweet:');\n      throw error;\n    }\n  }\n\n  /**\n   * Handles the creation and posting of a tweet by emitting standardized events.\n   * This approach aligns with our platform-independent architecture.\n   */\n  async generateNewTweet() {\n    try {\n      // Create the timeline room ID for storing the post\n      const userId = this.client.profile?.id;\n      if (!userId) {\n        logger.error('Cannot generate tweet: Twitter profile not available');\n        return;\n      }\n\n      // Create standardized world and room IDs\n      const worldId = createUniqueUuid(this.runtime, userId) as UUID;\n      const roomId = createUniqueUuid(this.runtime, `${userId}-home`) as UUID;\n      // Create a callback for handling the actual posting\n      const callback: HandlerCallback = async (content: Content) => {\n        try {\n          if (this.isDryRun) {\n            logger.info(`[DRY RUN] Would post tweet: ${content.text}`);\n            return [];\n          }\n\n          if (content.text.includes('Error: Missing')) {\n            logger.error('Error: Missing some context', content);\n            return [];\n          }\n\n          // Post the tweet\n          const result = await this.postToTwitter(content.text, content.mediaData as MediaData[]);\n\n          // If result is null, it means we detected a duplicate tweet and skipped posting\n          if (result === null) {\n            logger.info('Skipped posting duplicate tweet');\n            return [];\n          }\n\n          const tweetId =\n            (result as any).rest_id || (result as any).id_str || (result as any).legacy?.id_str;\n\n          if (result) {\n            const postedTweetId = createUniqueUuid(this.runtime, tweetId);\n\n            // Create memory for the posted tweet\n            const postedMemory: Memory = {\n              id: postedTweetId,\n              entityId: this.runtime.agentId,\n              agentId: this.runtime.agentId,\n              roomId,\n              content: {\n                ...content,\n                source: 'twitter',\n                channelType: ChannelType.FEED,\n                type: 'post',\n                metadata: {\n                  tweetId,\n                  postedAt: Date.now(),\n                },\n              },\n              createdAt: Date.now(),\n            };\n\n            await this.runtime.createMemory(postedMemory, 'messages');\n\n            return [postedMemory];\n          }\n\n          return [];\n        } catch (error) {\n          logger.error('Error posting tweet:', error, content);\n          return [];\n        }\n      };\n\n      // Emit event to handle the post generation using standard handlers\n      this.runtime.emitEvent([EventType.POST_GENERATED, TwitterEventTypes.POST_GENERATED], {\n        runtime: this.runtime,\n        callback,\n        worldId,\n        userId,\n        roomId,\n        source: 'twitter',\n      });\n    } catch (error) {\n      logger.error('Error generating tweet:', error);\n    }\n  }\n\n  /**\n   * Posts content to Twitter\n   * @param {string} text The tweet text to post\n   * @param {MediaData[]} mediaData Optional media to attach to the tweet\n   * @returns {Promise<any>} The result from the Twitter API\n   */\n  private async postToTwitter(text: string, mediaData: MediaData[] = []): Promise<any> {\n    try {\n      // Check if this tweet is a duplicate of the last one\n      const lastPost = await this.runtime.getCache<any>(\n        `twitter/${this.client.profile?.username}/lastPost`\n      );\n      if (lastPost) {\n        // Fetch the last tweet to compare content\n        const lastTweet = await this.client.getTweet(lastPost.id);\n        if (lastTweet && lastTweet.text === text) {\n          logger.warn('Tweet is a duplicate of the last post. Skipping to avoid duplicate.');\n          return null;\n        }\n      }\n\n      // Handle media uploads if needed\n      const mediaIds: string[] = [];\n\n      if (mediaData && mediaData.length > 0) {\n        for (const media of mediaData) {\n          try {\n            // TODO: Media upload will need to be updated to use the new API\n            // For now, just log a warning that media upload is not supported\n            logger.warn('Media upload not currently supported with the modern Twitter API');\n          } catch (error) {\n            logger.error('Error uploading media:', error);\n          }\n        }\n      }\n\n      // Use the modern sendTweet method instead of the old post method\n      const result = await this.client.requestQueue.add(() =>\n        this.client.twitterClient.sendTweet(text.substring(0, 280))\n      );\n\n      // Handle response based on the new API format\n      const body = await result.json();\n      if (!body?.data?.create_tweet?.tweet_results?.result) {\n        logger.error('Error sending tweet; Bad response:', body);\n        return null;\n      }\n\n      return body.data.create_tweet.tweet_results.result;\n    } catch (error) {\n      logger.error('Error posting to Twitter:', error);\n      throw error;\n    }\n  }\n\n  async stop() {\n    // Implement stop functionality if needed\n  }\n}\n","// packages/plugin-twitter/src/tests/ClientBaseTestSuite.ts\n\nimport type { IAgentRuntime, TestSuite } from '@elizaos/core';\nimport { ClientBase } from './base';\nimport type { TwitterConfig } from './environment';\nimport { logger } from '@elizaos/core';\n\nexport class ClientBaseTestSuite implements TestSuite {\n  name = 'twitter-client-base';\n\n  private mockRuntime: IAgentRuntime;\n  private mockConfig: TwitterConfig;\n\n  constructor() {\n    this.mockRuntime = {\n      env: {\n        TWITTER_USERNAME: 'testuser',\n        TWITTER_DRY_RUN: 'true',\n        TWITTER_POST_INTERVAL_MIN: '90',\n        TWITTER_POST_INTERVAL_MAX: '180',\n        TWITTER_ENABLE_ACTION_PROCESSING: 'true',\n        TWITTER_POST_IMMEDIATELY: 'false',\n      },\n      getEnv: (key: string) => this.mockRuntime.env[key] || null,\n      getSetting: (key: string) => this.mockRuntime.env[key] || null,\n      character: {\n        style: {\n          all: ['Test style 1', 'Test style 2'],\n          post: ['Post style 1', 'Post style 2'],\n        },\n      },\n    } as unknown as IAgentRuntime;\n\n    this.mockConfig = {\n      TWITTER_USERNAME: 'testuser',\n      TWITTER_DRY_RUN: true,\n      TWITTER_SPACES_ENABLE: false,\n      TWITTER_TARGET_USERS: [],\n      TWITTER_PASSWORD: 'hashedpassword',\n      TWITTER_EMAIL: 'test@example.com',\n      TWITTER_2FA_SECRET: '',\n      TWITTER_RETRY_LIMIT: 5,\n      TWITTER_POLL_INTERVAL: 120,\n      TWITTER_ENABLE_POST_GENERATION: true,\n      TWITTER_POST_INTERVAL_MIN: 90,\n      TWITTER_POST_INTERVAL_MAX: 180,\n      TWITTER_POST_IMMEDIATELY: false,\n    };\n  }\n\n  tests = [\n    {\n      name: 'Create instance with correct configuration',\n      fn: this.testInstanceCreation.bind(this),\n    },\n    { name: 'Initialize with correct post intervals', fn: this.testPostIntervals.bind(this) },\n  ];\n\n  async testInstanceCreation() {\n    const client = new ClientBase(this.mockRuntime, this.mockConfig);\n    if (!client) throw new Error('ClientBase instance creation failed.');\n\n    if (this.mockRuntime.getSetting('TWITTER_USERNAME') !== 'testuser') {\n      throw new Error('TWITTER_USERNAME setting mismatch.');\n    }\n\n    if (client.state.TWITTER_USERNAME !== 'testuser') {\n      throw new Error('Client state TWITTER_USERNAME mismatch.');\n    }\n\n    if (this.mockRuntime.getSetting('TWITTER_DRY_RUN') !== 'true') {\n      throw new Error('TWITTER_DRY_RUN setting mismatch.');\n    }\n\n    if (client.state.TWITTER_DRY_RUN !== true) {\n      throw new Error('Client state TWITTER_DRY_RUN mismatch.');\n    }\n\n    logger.success('ClientBase instance created with correct configuration.');\n  }\n\n  async testPostIntervals() {\n    const client = new ClientBase(this.mockRuntime, this.mockConfig);\n\n    if (this.mockRuntime.getSetting('TWITTER_POST_INTERVAL_MIN') !== '90') {\n      throw new Error('TWITTER_POST_INTERVAL_MIN setting mismatch.');\n    }\n\n    if (client.state.TWITTER_POST_INTERVAL_MIN !== 90) {\n      throw new Error('Client state TWITTER_POST_INTERVAL_MIN mismatch.');\n    }\n\n    if (this.mockRuntime.getSetting('TWITTER_POST_INTERVAL_MAX') !== '180') {\n      throw new Error('TWITTER_POST_INTERVAL_MAX setting mismatch.');\n    }\n\n    if (client.state.TWITTER_POST_INTERVAL_MAX !== 180) {\n      throw new Error('Client state TWITTER_POST_INTERVAL_MAX mismatch.');\n    }\n\n    logger.success('ClientBase initialized with correct post intervals.');\n  }\n}\n"],"mappings":"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","names":["ChannelType","EventType","createUniqueUuid","logger","logger","ChannelType","ModelType","createUniqueUuid","logger","Headers","Headers","Headers","bearerToken","Headers","Headers","CookieJar","CookieJar","Headers","Headers","stringify","features","stringify","Headers","stringify","features","stringify","features","features","features","stringify","features","endpoints","user","place","data","mediaData","mediaType","features","features","EventEmitter","Headers","Headers","logger","EventEmitter","wrtc","EventEmitter","wrtc","EventEmitter","EventEmitter","EventEmitter","EventEmitter","logger","SttTtsPlugin","ChannelType","ModelType","createUniqueUuid","logger","ModelType","logger","SttTtsPlugin","logger","createUniqueUuid","ChannelType","ModelType","logger","tweet","spaceJoined","ChannelType","createUniqueUuid","logger","authToken","ct0","guestId","logger","existingMemories","createUniqueUuid","existingMemoryIds","tweetsToSave","ChannelType","profile","ChannelType","EventType","ModelType","createUniqueUuid","logger","logger","createUniqueUuid","ChannelType","EventType","tweet","ModelType","ChannelType","EventType","createUniqueUuid","logger","logger","ChannelType","createUniqueUuid","EventType","logger","logger","createUniqueUuid","ChannelType","EventType"]}