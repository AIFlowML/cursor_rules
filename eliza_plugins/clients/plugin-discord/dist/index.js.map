{"version":3,"sources":["../src/index.ts","../src/actions/chatWithAttachments.ts","../src/actions/downloadMedia.ts","../src/actions/summarizeConversation.ts","../src/actions/transcribeMedia.ts","../src/actions/voiceJoin.ts","../src/types.ts","../src/actions/voiceLeave.ts","../src/providers/channelState.ts","../src/providers/voiceState.ts","../src/service.ts","../src/constants.ts","../src/messages.ts","../src/attachments.ts","../src/utils.ts","../src/voice.ts","../src/tests.ts"],"sourcesContent":["import { type IAgentRuntime, type Plugin, logger } from '@elizaos/core';\nimport chatWithAttachments from './actions/chatWithAttachments';\nimport { downloadMedia } from './actions/downloadMedia';\nimport { summarize } from './actions/summarizeConversation';\nimport { transcribeMedia } from './actions/transcribeMedia';\nimport { joinVoice } from './actions/voiceJoin';\nimport { leaveVoice } from './actions/voiceLeave';\nimport { channelStateProvider } from './providers/channelState';\nimport { voiceStateProvider } from './providers/voiceState';\nimport { DiscordService } from './service';\nimport { DiscordTestSuite } from './tests';\n\nconst discordPlugin: Plugin = {\n  name: 'discord',\n  description: 'Discord service plugin for integration with Discord servers and channels',\n  services: [DiscordService],\n  actions: [chatWithAttachments, downloadMedia, joinVoice, leaveVoice, summarize, transcribeMedia],\n  providers: [channelStateProvider, voiceStateProvider],\n  tests: [new DiscordTestSuite()],\n  init: async (config: Record<string, string>, runtime: IAgentRuntime) => {\n    const token = runtime.getSetting('DISCORD_API_TOKEN') as string;\n\n    if (!token || token.trim() === '') {\n      logger.warn(\n        'Discord API Token not provided - Discord plugin is loaded but will not be functional'\n      );\n      logger.warn(\n        'To enable Discord functionality, please provide DISCORD_API_TOKEN in your .eliza/.env file'\n      );\n    }\n  },\n};\n\nexport default discordPlugin;\n","import fs from 'node:fs';\nimport {\n  type Action,\n  type ActionExample,\n  ChannelType,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  ModelType,\n  type State,\n  composePromptFromState,\n  parseJSONObjectFromText,\n  trimTokens,\n} from '@elizaos/core';\n\nexport const summarizationTemplate = `# Summarized so far (we are adding to this)\n{{currentSummary}}\n\n# Current attachments we are summarizing\n{{attachmentsWithText}}\n\nSummarization objective: {{objective}}\n\n# Instructions: Summarize the attachments. Return the summary. Do not acknowledge this request, just summarize and continue the existing summary if there is one. Capture any important details based on the objective. Only respond with the new summary text.`;\n\n/**\n * Template for generating a summary of specific attachments based on recent messages.\n * This template includes placeholders for recentMessages, senderName, objective, and attachmentIds.\n * To generate a response, the user's objective and a list of attachment IDs must be determined.\n *\n * @type {string}\n */\nexport const attachmentIdsTemplate = `# Messages we are summarizing\n{{recentMessages}}\n\n# Instructions: {{senderName}} is requesting a summary of specific attachments. Your goal is to determine their objective, along with the list of attachment IDs to summarize.\nThe \"objective\" is a detailed description of what the user wants to summarize based on the conversation.\nThe \"attachmentIds\" is an array of attachment IDs that the user wants to summarize. If not specified, default to including all attachments from the conversation.\n\nYour response must be formatted as a JSON block with this structure:\n\\`\\`\\`json\n{\n  \"objective\": \"<What the user wants to summarize>\",\n  \"attachmentIds\": [\"<Attachment ID 1>\", \"<Attachment ID 2>\", ...]\n}\n\\`\\`\\`\n`;\n\n/**\n * Retrieves attachment IDs from a model using a prompt generated from the current state and a template.\n * @param {IAgentRuntime} runtime - The agent runtime to use for interaction with models\n * @param {Memory} _message - The memory object\n * @param {State} state - The current state of the conversation\n * @returns {Promise<{ objective: string; attachmentIds: string[] } | null>} An object containing the objective and attachment IDs, or null if the data could not be retrieved after multiple attempts\n */\nconst getAttachmentIds = async (\n  runtime: IAgentRuntime,\n  _message: Memory,\n  state: State\n): Promise<{ objective: string; attachmentIds: string[] } | null> => {\n  const prompt = composePromptFromState({\n    state,\n    template: attachmentIdsTemplate,\n  });\n\n  for (let i = 0; i < 5; i++) {\n    const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n      prompt,\n    });\n    // try parsing to a json object\n    const parsedResponse = parseJSONObjectFromText(response) as {\n      objective: string;\n      attachmentIds: string[];\n    } | null;\n    // see if it contains objective and attachmentIds\n    if (parsedResponse?.objective && parsedResponse?.attachmentIds) {\n      return parsedResponse;\n    }\n  }\n  return null;\n};\n\n/**\n * Represents an action to summarize user request informed by specific attachments based on their IDs.\n * If a user asks to chat with a PDF, or wants more specific information about a link or video or anything else they've attached, this is the action to use.\n * @typedef {Object} summarizeAction\n * @property {string} name - The name of the action\n * @property {string[]} similes - Similar actions related to summarization with attachments\n * @property {string} description - Description of the action\n * @property {Function} validate - Validation function to check if the action should be triggered based on keywords in the message\n * @property {Function} handler - Handler function to process the user request, summarize attachments, and provide a summary\n * @property {Object[]} examples - Examples demonstrating how to use the action with message content and expected responses\n */\n\nexport const chatWithAttachments: Action = {\n  name: 'CHAT_WITH_ATTACHMENTS',\n  similes: [\n    'CHAT_WITH_ATTACHMENT',\n    'SUMMARIZE_FILES',\n    'SUMMARIZE_FILE',\n    'SUMMARIZE_ATACHMENT',\n    'CHAT_WITH_PDF',\n    'ATTACHMENT_SUMMARY',\n    'RECAP_ATTACHMENTS',\n    'SUMMARIZE_FILE',\n    'SUMMARIZE_VIDEO',\n    'SUMMARIZE_AUDIO',\n    'SUMMARIZE_IMAGE',\n    'SUMMARIZE_DOCUMENT',\n    'SUMMARIZE_LINK',\n    'ATTACHMENT_SUMMARY',\n    'FILE_SUMMARY',\n  ],\n  description:\n    \"Answer a user request informed by specific attachments based on their IDs. If a user asks to chat with a PDF, or wants more specific information about a link or video or anything else they've attached, this is the action to use.\",\n  validate: async (_runtime: IAgentRuntime, message: Memory, _state: State) => {\n    const room = await _runtime.getRoom(message.roomId);\n    if (room?.type !== ChannelType.GROUP) {\n      return false;\n    }\n    // only show if one of the keywords are in the message\n    const keywords: string[] = [\n      'attachment',\n      'summary',\n      'summarize',\n      'research',\n      'pdf',\n      'video',\n      'audio',\n      'image',\n      'document',\n      'link',\n      'file',\n      'attachment',\n      'summarize',\n      'code',\n      'report',\n      'write',\n      'details',\n      'information',\n      'talk',\n      'chat',\n      'read',\n      'listen',\n      'watch',\n    ];\n    return keywords.some((keyword) =>\n      message.content.text?.toLowerCase().includes(keyword.toLowerCase())\n    );\n  },\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n    _options: any,\n    callback: HandlerCallback\n  ) => {\n    const callbackData: Content = {\n      text: '', // fill in later\n      actions: ['CHAT_WITH_ATTACHMENTS_RESPONSE'],\n      source: message.content.source,\n      attachments: [],\n    };\n\n    // 1. extract attachment IDs from the message\n    const attachmentData = await getAttachmentIds(runtime, message, state);\n    if (!attachmentData) {\n      console.error(\"Couldn't get attachment IDs from message\");\n      await runtime.createMemory(\n        {\n          entityId: message.entityId,\n          agentId: message.agentId,\n          roomId: message.roomId,\n          content: {\n            source: message.content.source,\n            thought: \"I tried to chat with attachments but I couldn't get attachment IDs\",\n            actions: ['CHAT_WITH_ATTACHMENTS_FAILED'],\n          },\n          metadata: {\n            type: 'CHAT_WITH_ATTACHMENTS',\n          },\n        },\n        'messages'\n      );\n      return;\n    }\n\n    const { objective, attachmentIds } = attachmentData;\n\n    const conversationLength = runtime.getConversationLength();\n\n    const recentMessages = await runtime.getMemories({\n      tableName: 'messages',\n      roomId: message.roomId,\n      count: conversationLength,\n      unique: false,\n    });\n\n    // This is pretty gross but it can catch cases where the returned generated UUID is stupidly wrong for some reason\n    const attachments = recentMessages\n      .filter((msg) => msg.content.attachments && msg.content.attachments.length > 0)\n      .flatMap((msg) => msg.content.attachments)\n      // check by first 5 characters of uuid\n      .filter(\n        (attachment) =>\n          attachmentIds\n            .map((attch) => attch.toLowerCase().slice(0, 5))\n            .includes(attachment.id.toLowerCase().slice(0, 5)) ||\n          // or check the other way\n          attachmentIds.some((id) => {\n            const attachmentId = id.toLowerCase().slice(0, 5);\n            return attachment.id.toLowerCase().includes(attachmentId);\n          })\n      );\n\n    const attachmentsWithText = attachments\n      .map((attachment) => `# ${attachment.title}\\n${attachment.text}`)\n      .join('\\n\\n');\n\n    let currentSummary = '';\n\n    const chunkSize = 8192;\n\n    state.values.attachmentsWithText = attachmentsWithText;\n    state.values.objective = objective;\n    const template = await trimTokens(summarizationTemplate, chunkSize, runtime);\n    const prompt = composePromptFromState({\n      state,\n      // make sure it fits, we can pad the tokens a bit\n      // Get the model's tokenizer based on the current model being used\n      template,\n    });\n\n    const summary = await runtime.useModel(ModelType.TEXT_SMALL, {\n      prompt,\n    });\n\n    currentSummary = `${currentSummary}\\n${summary}`;\n\n    if (!currentSummary) {\n      console.error(\"No summary found, that's not good!\");\n      await runtime.createMemory(\n        {\n          entityId: message.entityId,\n          agentId: message.agentId,\n          roomId: message.roomId,\n          content: {\n            source: message.content.source,\n            thought: \"I tried to chat with attachments but I couldn't get a summary\",\n            actions: ['CHAT_WITH_ATTACHMENTS_FAILED'],\n          },\n          metadata: {\n            type: 'CHAT_WITH_ATTACHMENTS',\n          },\n        },\n        'messages'\n      );\n      return;\n    }\n\n    callbackData.text = currentSummary.trim();\n    if (\n      callbackData.text &&\n      (currentSummary.trim()?.split('\\n').length < 4 ||\n        currentSummary.trim()?.split(' ').length < 100)\n    ) {\n      callbackData.text = `Here is the summary:\n\\`\\`\\`md\n${currentSummary.trim()}\n\\`\\`\\`\n`;\n      await callback(callbackData);\n    } else if (currentSummary.trim()) {\n      const summaryDir = 'cache';\n      const summaryFilename = `${summaryDir}/summary_${Date.now()}.md`;\n      try {\n        await fs.promises.mkdir(summaryDir, { recursive: true });\n\n        // Write file directly first\n        await fs.promises.writeFile(summaryFilename, currentSummary, 'utf8');\n\n        // Then cache it\n        await runtime.setCache<string>(summaryFilename, currentSummary);\n\n        await callback(\n          {\n            ...callbackData,\n            text: `I've attached the summary of the requested attachments as a text file.`,\n          },\n          [summaryFilename]\n        );\n      } catch (error) {\n        console.error('Error in file/cache process:', error);\n        throw error;\n      }\n    } else {\n      console.warn('Empty response from chat with attachments action, skipping');\n    }\n\n    return callbackData;\n  },\n  examples: [\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'Can you summarize the attachments b3e23, c4f67, and d5a89?',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: \"Sure thing! I'll pull up those specific attachments and provide a summary of their content.\",\n          actions: ['CHAT_WITH_ATTACHMENTS'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'I need a technical summary of the PDFs I sent earlier - a1b2c3.pdf, d4e5f6.pdf, and g7h8i9.pdf',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: \"I'll take a look at those specific PDF attachments and put together a technical summary for you. Give me a few minutes to review them.\",\n          actions: ['CHAT_WITH_ATTACHMENTS'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: \"Can you watch this video for me and tell me which parts you think are most relevant to the report I'm writing? (the one I attached in my last message)\",\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'sure, no problem.',\n          actions: ['CHAT_WITH_ATTACHMENTS'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'can you read my blog post and give me a detailed breakdown of the key points I made, and then suggest a handful of tweets to promote it?',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'great idea, give me a minute',\n          actions: ['CHAT_WITH_ATTACHMENTS'],\n        },\n      },\n    ],\n  ] as ActionExample[][],\n} as Action;\n\nexport default chatWithAttachments;\n","import {\n  type Action,\n  type ActionExample,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type IVideoService,\n  type Memory,\n  ModelType,\n  ServiceType,\n  type State,\n  composePromptFromState,\n  parseJSONObjectFromText,\n} from '@elizaos/core';\n\n/**\n * Template for generating a media URL for a requested media file.\n *\n * @type {string}\n * @description This template is used for messages where a user is requesting to download a specific media file (video or audio). The goal is to determine the URL of the media they want to download.\n *\n * @param {string} recentMessages - Placeholder for recent messages related to the request.\n * @param {string} senderName - Name of the sender requesting the media file.\n *\n * @returns {string} - Formatted template with instructions and JSON structure for response.\n *\n * @example\n * `mediaUrlTemplate` contains the template for generating a media URL based on user request.\n */\n\nexport const mediaUrlTemplate = `# Messages we are searching for a media URL\n{{recentMessages}}\n\n# Instructions: {{senderName}} is requesting to download a specific media file (video or audio). Your goal is to determine the URL of the media they want to download.\nThe \"mediaUrl\" is the URL of the media file that the user wants downloaded. If not specified, return null.\n\nYour response must be formatted as a JSON block with this structure:\n\\`\\`\\`json\n{\n  \"mediaUrl\": \"<Media URL>\"\n}\n\\`\\`\\`\n`;\n\n/**\n * Get a media URL from the user through text input using the provided runtime and state.\n * @param {IAgentRuntime} runtime - The runtime object to interact with the agent.\n * @param {Memory} _message - The memory object containing the input message.\n * @param {State} state - The state of the conversation.\n * @returns {Promise<string | null>} The media URL provided by the user or null if no valid URL is provided.\n */\nconst getMediaUrl = async (\n  runtime: IAgentRuntime,\n  _message: Memory,\n  state: State\n): Promise<string | null> => {\n  const prompt = composePromptFromState({\n    state,\n    template: mediaUrlTemplate,\n  });\n\n  for (let i = 0; i < 5; i++) {\n    const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n      prompt,\n    });\n\n    const parsedResponse = parseJSONObjectFromText(response) as {\n      mediaUrl: string;\n    } | null;\n\n    if (parsedResponse?.mediaUrl) {\n      return parsedResponse.mediaUrl;\n    }\n  }\n  return null;\n};\n\nexport const downloadMedia: Action = {\n  name: 'DOWNLOAD_MEDIA',\n  similes: [\n    'DOWNLOAD_VIDEO',\n    'DOWNLOAD_AUDIO',\n    'GET_MEDIA',\n    'DOWNLOAD_PODCAST',\n    'DOWNLOAD_YOUTUBE',\n  ],\n  description:\n    'Downloads a video or audio file from a URL and attaches it to the response message.',\n  validate: async (_runtime: IAgentRuntime, message: Memory, _state: State) => {\n    if (message.content.source !== 'discord') {\n      return false;\n    }\n  },\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n    _options: any,\n    callback: HandlerCallback\n  ) => {\n    const videoService = runtime.getService<IVideoService>(ServiceType.VIDEO);\n\n    const mediaUrl = await getMediaUrl(runtime, message, state);\n    if (!mediaUrl) {\n      console.error(\"Couldn't get media URL from messages\");\n      await runtime.createMemory(\n        {\n          entityId: message.entityId,\n          agentId: message.agentId,\n          roomId: message.roomId,\n          content: {\n            source: 'discord',\n            thought: `I couldn't find the media URL in the message`,\n            actions: ['DOWNLOAD_MEDIA_FAILED'],\n          },\n          metadata: {\n            type: 'DOWNLOAD_MEDIA',\n          },\n        },\n        'messages'\n      );\n      return;\n    }\n\n    const videoInfo = await videoService.fetchVideoInfo(mediaUrl);\n    const mediaPath = await videoService.downloadVideo(videoInfo);\n\n    const response: Content = {\n      text: `I downloaded the video \"${videoInfo.title}\" and attached it below.`,\n      actions: ['DOWNLOAD_MEDIA_RESPONSE'],\n      source: message.content.source,\n      attachments: [],\n    };\n\n    const maxRetries = 3;\n    let retries = 0;\n\n    while (retries < maxRetries) {\n      try {\n        await callback(\n          {\n            ...response,\n          },\n          [mediaPath]\n        );\n        break;\n      } catch (error) {\n        retries++;\n        console.error(`Error sending message (attempt ${retries}):`, error);\n\n        if (retries === maxRetries) {\n          console.error('Max retries reached. Failed to send message with attachment.');\n          break;\n        }\n\n        // Wait for a short delay before retrying\n        await new Promise((resolve) => setTimeout(resolve, 2000));\n      }\n    }\n\n    return response;\n  },\n  examples: [\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'Downloading the YouTube video now, one sec',\n          actions: ['DOWNLOAD_MEDIA'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'Can you grab this video for me? https://vimeo.com/123456789',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: \"Sure thing, I'll download that Vimeo video for you\",\n          actions: ['DOWNLOAD_MEDIA'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'I need this video downloaded: https://www.youtube.com/watch?v=abcdefg',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: \"No problem, I'm on it. I'll have that YouTube video downloaded in a jiffy\",\n          actions: ['DOWNLOAD_MEDIA'],\n        },\n      },\n    ],\n  ] as ActionExample[][],\n} as Action;\n\nexport default downloadMedia;\n","import fs from 'node:fs';\nimport {\n  type Action,\n  type ActionExample,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Media,\n  type Memory,\n  ModelType,\n  type State,\n  composePromptFromState,\n  getEntityDetails,\n  parseJSONObjectFromText,\n  splitChunks,\n  trimTokens,\n} from '@elizaos/core';\nexport const summarizationTemplate = `# Summarized so far (we are adding to this)\n{{currentSummary}}\n\n# Current conversation chunk we are summarizing (includes attachments)\n{{memoriesWithAttachments}}\n\nSummarization objective: {{objective}}\n\n# Instructions: Summarize the conversation so far. Return the summary. Do not acknowledge this request, just summarize and continue the existing summary if there is one. Capture any important details to the objective. Only respond with the new summary text.\nYour response should be extremely detailed and include any and all relevant information.`;\n\n/**\n * Template for providing instructions and details on how to summarize conversation messages and determine the range of dates requested.\n * The template includes placeholders for recent messages, sender name, objective, start and end date range.\n * The response is expected to be formatted as a JSON block with specific structure.\n * @type {string}\n */\nexport const dateRangeTemplate = `# Messages we are summarizing (the conversation is continued after this)\n{{recentMessages}}\n\n# Instructions: {{senderName}} is requesting a summary of the conversation. Your goal is to determine their objective, along with the range of dates that their request covers.\nThe \"objective\" is a detailed description of what the user wants to summarize based on the conversation. If they just ask for a general summary, you can either base it off the conversation if the summary range is very recent, or set the object to be general, like \"a detailed summary of the conversation between all users\".\nThe \"start\" and \"end\" are the range of dates that the user wants to summarize, relative to the current time. The start and end should be relative to the current time, and measured in seconds, minutes, hours and days. The format is \"2 days ago\" or \"3 hours ago\" or \"4 minutes ago\" or \"5 seconds ago\", i.e. \"<integer> <unit> ago\".\nIf you aren't sure, you can use a default range of \"0 minutes ago\" to \"2 hours ago\" or more. Better to err on the side of including too much than too little.\n\nYour response must be formatted as a JSON block with this structure:\n\\`\\`\\`json\n{\n  \"objective\": \"<What the user wants to summarize>\",\n  \"start\": \"0 minutes ago\",\n  \"end\": \"2 hours ago\"\n}\n\\`\\`\\`\n`;\n\n/**\n * Function to get a date range from user input.\n *\n * @param {IAgentRuntime} runtime - The Agent Runtime object.\n * @param {Memory} _message - The Memory object.\n * @param {State} state - The State object.\n * @return {Promise<{ objective: string; start: string | number; end: string | number; } | null>} Parsed user input containing objective, start, and end timestamps, or null.\n */\nconst getDateRange = async (runtime: IAgentRuntime, _message: Memory, state: State) => {\n  const prompt = composePromptFromState({\n    state,\n    template: dateRangeTemplate,\n  });\n\n  for (let i = 0; i < 5; i++) {\n    const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n      prompt,\n    });\n\n    // try parsing to a json object\n    const parsedResponse = parseJSONObjectFromText(response) as {\n      objective: string;\n      start: string | number;\n      end: string | number;\n    } | null;\n    // see if it contains objective, start and end\n    if (parsedResponse) {\n      if (parsedResponse.objective && parsedResponse.start && parsedResponse.end) {\n        // TODO: parse start and end into timestamps\n        const startIntegerString = (parsedResponse.start as string).match(/\\d+/)?.[0];\n        const endIntegerString = (parsedResponse.end as string).match(/\\d+/)?.[0];\n\n        // parse multiplier\n        const multipliers = {\n          second: 1 * 1000,\n          minute: 60 * 1000,\n          hour: 3600 * 1000,\n          day: 86400 * 1000,\n        };\n\n        const startMultiplier = (parsedResponse.start as string).match(\n          /second|minute|hour|day/\n        )?.[0];\n        const endMultiplier = (parsedResponse.end as string).match(/second|minute|hour|day/)?.[0];\n\n        const startInteger = startIntegerString ? Number.parseInt(startIntegerString) : 0;\n        const endInteger = endIntegerString ? Number.parseInt(endIntegerString) : 0;\n\n        // multiply by multiplier\n        const startTime = startInteger * multipliers[startMultiplier as keyof typeof multipliers];\n\n        const endTime = endInteger * multipliers[endMultiplier as keyof typeof multipliers];\n\n        // get the current time and subtract the start and end times\n        parsedResponse.start = Date.now() - startTime;\n        parsedResponse.end = Date.now() - endTime;\n\n        return parsedResponse;\n      }\n    }\n  }\n};\n\n/**\n * Action to summarize a conversation and attachments.\n *\n * @typedef {Action} summarizeAction\n * @property {string} name - The name of the action.\n * @property {string[]} similes - Array of related terms.\n * @property {string} description - Description of the action.\n * @property {Function} validate - Asynchronous function to validate the action.\n * @property {Function} handler - Asynchronous function to handle the action.\n * @property {ActionExample[][]} examples - Array of examples demonstrating the action.\n */\nexport const summarize: Action = {\n  name: 'SUMMARIZE_CONVERSATION',\n  similes: [\n    'RECAP',\n    'RECAP_CONVERSATION',\n    'SUMMARIZE_CHAT',\n    'SUMMARIZATION',\n    'CHAT_SUMMARY',\n    'CONVERSATION_SUMMARY',\n  ],\n  description: 'Summarizes the conversation and attachments.',\n  validate: async (_runtime: IAgentRuntime, message: Memory, _state: State) => {\n    if (message.content.source !== 'discord') {\n      return false;\n    }\n    // only show if one of the keywords are in the message\n    const keywords: string[] = [\n      'summarize',\n      'summarization',\n      'summary',\n      'recap',\n      'report',\n      'overview',\n      'review',\n      'rundown',\n      'wrap-up',\n      'brief',\n      'debrief',\n      'abstract',\n      'synopsis',\n      'outline',\n      'digest',\n      'abridgment',\n      'condensation',\n      'encapsulation',\n      'essence',\n      'gist',\n      'main points',\n      'key points',\n      'key takeaways',\n      'bulletpoint',\n      'highlights',\n      'tldr',\n      'tl;dr',\n      'in a nutshell',\n      'bottom line',\n      'long story short',\n      'sum up',\n      'sum it up',\n      'short version',\n      'bring me up to speed',\n      'catch me up',\n    ];\n    return keywords.some((keyword) =>\n      message.content.text?.toLowerCase().includes(keyword.toLowerCase())\n    );\n  },\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n    _options: any,\n    callback: HandlerCallback\n  ) => {\n    const callbackData: Content = {\n      text: '', // fill in later\n      actions: ['SUMMARIZATION_RESPONSE'],\n      source: message.content.source,\n      attachments: [],\n    };\n    const { roomId } = message;\n\n    // 1. extract date range from the message\n    const dateRange = await getDateRange(runtime, message, state);\n    if (!dateRange) {\n      console.error(\"Couldn't get date range from message\");\n      await runtime.createMemory(\n        {\n          entityId: message.entityId,\n          agentId: message.agentId,\n          roomId: message.roomId,\n          content: {\n            source: 'discord',\n            thought: `I couldn't get the date range from the message`,\n            actions: ['SUMMARIZE_CONVERSATION_FAILED'],\n          },\n          metadata: {\n            type: 'SUMMARIZE_CONVERSATION',\n          },\n        },\n        'messages'\n      );\n      return;\n    }\n\n    const { objective, start, end } = dateRange;\n\n    // 2. get these memories from the database\n    const memories = await runtime.getMemories({\n      tableName: 'messages',\n      roomId,\n      // subtract start from current time\n      start: Number.parseInt(start as string),\n      end: Number.parseInt(end as string),\n      count: 10000,\n      unique: false,\n    });\n\n    const entities = await getEntityDetails({\n      runtime: runtime as IAgentRuntime,\n      roomId,\n    });\n\n    const actorMap = new Map(entities.map((entity) => [entity.id, entity]));\n\n    const formattedMemories = memories\n      .map((memory) => {\n        const attachments = memory.content.attachments\n          ?.map((attachment: Media) => {\n            return `---\\nAttachment: ${attachment.id}\\n${attachment.description}\\n${attachment.text}\\n---`;\n          })\n          .join('\\n');\n        return `${actorMap.get(memory.entityId)?.name ?? 'Unknown User'} (${actorMap.get(memory.entityId)?.username ?? ''}): ${memory.content.text}\\n${attachments}`;\n      })\n      .join('\\n');\n\n    let currentSummary = '';\n\n    const chunkSize = 8000;\n\n    const chunks = await splitChunks(formattedMemories, chunkSize, 0);\n\n    const _datestr = new Date().toUTCString().replace(/:/g, '-');\n\n    state.values.memoriesWithAttachments = formattedMemories;\n    state.values.objective = objective;\n\n    for (let i = 0; i < chunks.length; i++) {\n      const chunk = chunks[i];\n      state.values.currentSummary = currentSummary;\n      state.values.currentChunk = chunk;\n      const template = await trimTokens(summarizationTemplate, chunkSize + 500, runtime);\n      const prompt = composePromptFromState({\n        state,\n        // make sure it fits, we can pad the tokens a bit\n        template,\n      });\n\n      const summary = await runtime.useModel(ModelType.TEXT_SMALL, {\n        prompt,\n      });\n\n      currentSummary = `${currentSummary}\\n${summary}`;\n    }\n\n    if (!currentSummary) {\n      console.error(\"No summary found, that's not good!\");\n      await runtime.createMemory(\n        {\n          entityId: message.entityId,\n          agentId: message.agentId,\n          roomId: message.roomId,\n          content: {\n            source: 'discord',\n            thought: `I couldn't summarize the conversation`,\n            actions: ['SUMMARIZE_CONVERSATION_FAILED'],\n          },\n          metadata: {\n            type: 'SUMMARIZE_CONVERSATION',\n          },\n        },\n        'messages'\n      );\n      return;\n    }\n\n    callbackData.text = currentSummary.trim();\n    if (\n      callbackData.text &&\n      (currentSummary.trim()?.split('\\n').length < 4 ||\n        currentSummary.trim()?.split(' ').length < 100)\n    ) {\n      callbackData.text = `Here is the summary:\n\\`\\`\\`md\n${currentSummary.trim()}\n\\`\\`\\`\n`;\n      await callback(callbackData);\n    } else if (currentSummary.trim()) {\n      const summaryDir = 'cache';\n      const summaryFilename = `${summaryDir}/conversation_summary_${Date.now()}`;\n      await runtime.setCache<string>(summaryFilename, currentSummary);\n      await fs.promises.mkdir(summaryDir, { recursive: true });\n\n      await fs.promises.writeFile(summaryFilename, currentSummary, 'utf8');\n      // save the summary to a file\n      await callback(\n        {\n          ...callbackData,\n          text: `I've attached the summary of the conversation from \\`${new Date(Number.parseInt(start as string)).toString()}\\` to \\`${new Date(Number.parseInt(end as string)).toString()}\\` as a text file.`,\n        },\n        [summaryFilename]\n      );\n    } else {\n      console.warn('Empty response from summarize conversation action, skipping');\n    }\n\n    return callbackData;\n  },\n  examples: [\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: '```js\\nconst x = 10\\n```',\n        },\n      },\n      {\n        name: '{{name1}}',\n        content: {\n          text: \"can you give me a detailed report on what we're talking about?\",\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'sure, no problem, give me a minute to get that together for you',\n          actions: ['SUMMARIZE'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: \"please summarize the conversation we just had and include this blogpost i'm linking (Attachment: b3e12)\",\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'sure, give me a sec',\n          actions: ['SUMMARIZE'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'Can you summarize what moon and avf are talking about?',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'Yeah, just hold on a second while I get that together for you...',\n          actions: ['SUMMARIZE'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'i need to write a blog post about farming, can you summarize the discussion from a few hours ago?',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'no problem, give me a few minutes to read through everything',\n          actions: ['SUMMARIZE'],\n        },\n      },\n    ],\n  ] as ActionExample[][],\n} as Action;\n\nexport default summarize;\n","import {\n  type Action,\n  type ActionExample,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  ModelType,\n  type State,\n  composePromptFromState,\n  createUniqueUuid,\n  parseJSONObjectFromText,\n} from '@elizaos/core';\n\nexport const transcriptionTemplate = `# Transcription of media file\n{{mediaTranscript}}\n\n# Instructions: Return only the full transcript of the media file without any additional prompt or commentary.`;\n\n/**\n * Template for generating media attachment ID request for transcription\n *\n * @type {string}\n */\nexport const mediaAttachmentIdTemplate = `# Messages we are transcribing\n{{recentMessages}}\n\n# Instructions: {{senderName}} is requesting a transcription of a specific media file (audio or video). Your goal is to determine the ID of the attachment they want transcribed.\nThe \"attachmentId\" is the ID of the media file attachment that the user wants transcribed. If not specified, return null.\n\nYour response must be formatted as a JSON block with this structure:\n\\`\\`\\`json\n{\n  \"attachmentId\": \"<Attachment ID>\"\n}\n\\`\\`\\`\n`;\n\n/**\n * Asynchronous function to get the media attachment ID from the user input.\n *\n * @param {IAgentRuntime} runtime - The agent runtime object.\n * @param {Memory} _message - The memory object.\n * @param {State} state - The current state of the conversation.\n * @returns {Promise<string | null>} A promise that resolves with the media attachment ID or null.\n */\nconst getMediaAttachmentId = async (\n  runtime: IAgentRuntime,\n  _message: Memory,\n  state: State\n): Promise<string | null> => {\n  const prompt = composePromptFromState({\n    state,\n    template: mediaAttachmentIdTemplate,\n  });\n\n  for (let i = 0; i < 5; i++) {\n    const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n      prompt,\n    });\n\n    const parsedResponse = parseJSONObjectFromText(response) as {\n      attachmentId: string;\n    } | null;\n\n    if (parsedResponse?.attachmentId) {\n      return parsedResponse.attachmentId;\n    }\n  }\n  return null;\n};\n\n/**\n * Action for transcribing the full text of an audio or video file that the user has attached.\n *\n * @typedef {Object} Action\n * @property {string} name - The name of the action.\n * @property {string[]} similes - Similes associated with the action.\n * @property {string} description - Description of the action.\n * @property {Function} validate - Validation function for the action.\n * @property {Function} handler - Handler function for the action.\n * @property {ActionExample[][]} examples - Examples demonstrating the action.\n */\nexport const transcribeMedia: Action = {\n  name: 'TRANSCRIBE_MEDIA',\n  similes: [\n    'TRANSCRIBE_AUDIO',\n    'TRANSCRIBE_VIDEO',\n    'MEDIA_TRANSCRIPT',\n    'VIDEO_TRANSCRIPT',\n    'AUDIO_TRANSCRIPT',\n  ],\n  description: 'Transcribe the full text of an audio or video file that the user has attached.',\n  validate: async (_runtime: IAgentRuntime, message: Memory, _state: State) => {\n    if (message.content.source !== 'discord') {\n      return false;\n    }\n\n    const keywords: string[] = [\n      'transcribe',\n      'transcript',\n      'audio',\n      'video',\n      'media',\n      'youtube',\n      'meeting',\n      'recording',\n      'podcast',\n      'call',\n      'conference',\n      'interview',\n      'speech',\n      'lecture',\n      'presentation',\n    ];\n    return keywords.some((keyword) =>\n      message.content.text?.toLowerCase().includes(keyword.toLowerCase())\n    );\n  },\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n    _options: any,\n    callback: HandlerCallback\n  ) => {\n    const callbackData: Content = {\n      text: '', // fill in later\n      actions: ['TRANSCRIBE_MEDIA_RESPONSE'],\n      source: message.content.source,\n      attachments: [],\n    };\n\n    const attachmentId = await getMediaAttachmentId(runtime, message, state);\n    if (!attachmentId) {\n      console.error(\"Couldn't get media attachment ID from message\");\n      await runtime.createMemory(\n        {\n          entityId: message.entityId,\n          agentId: message.agentId,\n          roomId: message.roomId,\n          content: {\n            source: 'discord',\n            thought: `I couldn't find the media attachment ID in the message`,\n            actions: ['TRANSCRIBE_MEDIA_FAILED'],\n          },\n          metadata: {\n            type: 'TRANSCRIBE_MEDIA',\n          },\n        },\n        'messages'\n      );\n      return;\n    }\n\n    const conversationLength = runtime.getConversationLength();\n\n    const recentMessages = await runtime.getMemories({\n      tableName: 'messages',\n      roomId: message.roomId,\n      count: conversationLength,\n      unique: false,\n    });\n\n    const attachment = recentMessages\n      .filter((msg) => msg.content.attachments && msg.content.attachments.length > 0)\n      .flatMap((msg) => msg.content.attachments)\n      .find((attachment) => attachment.id.toLowerCase() === attachmentId.toLowerCase());\n\n    if (!attachment) {\n      console.error(`Couldn't find attachment with ID ${attachmentId}`);\n      await runtime.createMemory(\n        {\n          entityId: message.entityId,\n          agentId: message.agentId,\n          roomId: message.roomId,\n          content: {\n            source: 'discord',\n            thought: `I couldn't find the media attachment with ID ${attachmentId}`,\n            actions: ['TRANSCRIBE_MEDIA_FAILED'],\n          },\n          metadata: {\n            type: 'TRANSCRIBE_MEDIA',\n          },\n        },\n        'messages'\n      );\n      return;\n    }\n\n    const mediaTranscript = attachment.text;\n\n    callbackData.text = mediaTranscript.trim();\n\n    // if callbackData.text is < 4 lines or < 100 words, then we we callback with normal message wrapped in markdown block\n    if (\n      callbackData.text &&\n      (callbackData.text?.split('\\n').length < 4 || callbackData.text?.split(' ').length < 100)\n    ) {\n      callbackData.text = `Here is the transcript:\n\\`\\`\\`md\n${mediaTranscript.trim()}\n\\`\\`\\`\n`;\n      await callback(callbackData);\n    }\n    // if text is big, let's send as an attachment\n    else if (callbackData.text) {\n      const transcriptFilename = `content/transcript_${Date.now()}`;\n\n      // save the transcript to a file\n      await runtime.setCache<string>(transcriptFilename, callbackData.text);\n\n      await callback(\n        {\n          ...callbackData,\n          text: `I've attached the transcript as a text file.`,\n        },\n        [transcriptFilename]\n      );\n    } else {\n      console.warn('Empty response from transcribe media action, skipping');\n    }\n\n    return callbackData;\n  },\n  examples: [\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'Please transcribe the audio file I just sent.',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: \"Sure, I'll transcribe the full audio for you.\",\n          actions: ['TRANSCRIBE_MEDIA'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'Can I get a transcript of that video recording?',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'Absolutely, give me a moment to generate the full transcript of the video.',\n          actions: ['TRANSCRIBE_MEDIA'],\n        },\n      },\n    ],\n  ] as ActionExample[][],\n} as Action;\n\nexport default transcribeMedia;\n","// src/actions/joinVoice\nimport {\n  type Action,\n  type ActionExample,\n  ChannelType,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  ModelType,\n  type State,\n  composePromptFromState,\n  createUniqueUuid,\n  logger,\n} from '@elizaos/core';\nimport {\n  type BaseGuildVoiceChannel,\n  type Channel,\n  ChannelType as DiscordChannelType,\n  type Guild,\n} from 'discord.js';\nimport type { DiscordService } from '../service';\nimport { ServiceType } from '../types';\nimport type { VoiceManager } from '../voice';\n\nexport const joinVoice: Action = {\n  name: 'JOIN_VOICE',\n  similes: [\n    'JOIN_VOICE',\n    'JOIN_VC',\n    'JOIN_VOICE_CHAT',\n    'JOIN_VOICE_CHANNEL',\n    'JOIN_MEETING',\n    'JOIN_CALL',\n  ],\n  validate: async (runtime: IAgentRuntime, message: Memory, state: State) => {\n    if (message.content.source !== 'discord') {\n      // not a discord message\n      return false;\n    }\n\n    const room = state.data.room ?? (await runtime.getRoom(message.roomId));\n\n    if (room?.type !== ChannelType.GROUP && room?.type !== ChannelType.VOICE_GROUP) {\n      return false;\n    }\n\n    const client = runtime.getService(ServiceType.DISCORD);\n\n    if (!client) {\n      logger.error('Discord client not found');\n      return false;\n    }\n\n    return true;\n  },\n  description: 'Join a voice channel to participate in voice chat.',\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n    _options: any,\n    callback: HandlerCallback\n  ): Promise<boolean> => {\n    const room = state.data.room ?? (await runtime.getRoom(message.roomId));\n\n    if (!room) {\n      throw new Error('No room found');\n    }\n\n    if (room?.type !== ChannelType.GROUP && room?.type !== ChannelType.VOICE_GROUP) {\n      return false;\n    }\n\n    const serverId = room.serverId;\n\n    if (!serverId) {\n      throw new Error('No server ID found');\n    }\n\n    const discordClient = runtime.getService(ServiceType.DISCORD) as DiscordService;\n    const client = discordClient.client;\n    const voiceManager = discordClient.voiceManager as VoiceManager;\n\n    if (!client) {\n      logger.error('Discord client not found');\n      return false;\n    }\n\n    const voiceChannels = (client.guilds.cache.get(serverId) as Guild).channels.cache.filter(\n      (channel: Channel) => channel.type === DiscordChannelType.GuildVoice\n    );\n\n    const targetChannel = voiceChannels.find((channel) => {\n      const name = (channel as { name: string }).name.toLowerCase();\n      const messageContent = message?.content?.text;\n      // remove all non-alphanumeric characters (keep spaces between words)\n      const replacedName = name.replace(/[^a-z0-9 ]/g, '');\n\n      return (\n        name.includes(messageContent) ||\n        messageContent.includes(name) ||\n        replacedName.includes(messageContent) ||\n        messageContent.includes(replacedName)\n      );\n    });\n\n    if (targetChannel) {\n      voiceManager.joinChannel(targetChannel as BaseGuildVoiceChannel);\n      return true;\n    }\n    const guild = client.guilds.cache.get(serverId);\n    const members = guild?.members.cache;\n\n    // get the member who's stringTouuid(id) === message userId\n    const member = members?.find(\n      (member) => createUniqueUuid(runtime, member.id) === message.entityId\n    );\n\n    if (member?.voice?.channel) {\n      voiceManager.joinChannel(member?.voice?.channel as BaseGuildVoiceChannel);\n      await runtime.createMemory(\n        {\n          entityId: message.entityId,\n          agentId: message.agentId,\n          roomId: message.roomId,\n          content: {\n            source: 'discord',\n            thought: `I joined the voice channel ${member?.voice?.channel?.name}`,\n            actions: ['JOIN_VOICE_STARTED'],\n          },\n          metadata: {\n            type: 'JOIN_VOICE',\n          },\n        },\n        'messages'\n      );\n\n      // save a memory for the new channel as well\n      await runtime.createMemory(\n        {\n          entityId: message.entityId,\n          agentId: message.agentId,\n          roomId: createUniqueUuid(runtime, targetChannel.id),\n          content: {\n            source: 'discord',\n            thought: `I joined the voice channel ${targetChannel.name}`,\n            actions: ['JOIN_VOICE_STARTED'],\n          },\n          metadata: {\n            type: 'JOIN_VOICE',\n          },\n        },\n        'messages'\n      );\n      return true;\n    }\n\n    const messageTemplate = `\nThe user has requested to join a voice channel.\nHere is the list of channels available in the server:\n{{voiceChannels}}\n\nHere is the user's request:\n{{userMessage}}\n\nPlease respond with the name of the voice channel which the bot should join. Try to infer what channel the user is talking about. If the user didn't specify a voice channel, respond with \"none\".\nYou should only respond with the name of the voice channel or none, no commentary or additional information should be included.\n`;\n\n    const guessState = {\n      userMessage: message.content.text,\n      voiceChannels: voiceChannels.map((channel) => (channel as { name: string }).name).join('\\n'),\n    };\n\n    const prompt = composePromptFromState({\n      template: messageTemplate,\n      state: guessState as unknown as State,\n    });\n\n    const responseContent = await runtime.useModel(ModelType.TEXT_SMALL, {\n      prompt,\n    });\n\n    if (responseContent && responseContent.trim().length > 0) {\n      // join the voice channel\n      const channelName = responseContent.toLowerCase();\n\n      const targetChannel = voiceChannels.find((channel) => {\n        const name = (channel as { name: string }).name.toLowerCase();\n\n        // remove all non-alphanumeric characters (keep spaces between words)\n        const replacedName = name.replace(/[^a-z0-9 ]/g, '');\n\n        return (\n          name.includes(channelName) ||\n          channelName.includes(name) ||\n          replacedName.includes(channelName) ||\n          channelName.includes(replacedName)\n        );\n      });\n\n      if (targetChannel) {\n        voiceManager.joinChannel(targetChannel as BaseGuildVoiceChannel);\n        await runtime.createMemory(\n          {\n            entityId: message.entityId,\n            agentId: message.agentId,\n            roomId: message.roomId,\n            content: {\n              source: 'discord',\n              thought: `I joined the voice channel ${member?.voice?.channel?.name}`,\n              actions: ['JOIN_VOICE_STARTED'],\n            },\n            metadata: {\n              type: 'JOIN_VOICE',\n            },\n          },\n          'messages'\n        );\n\n        // save a memory for the new channel as well\n        await runtime.createMemory(\n          {\n            entityId: message.entityId,\n            agentId: message.agentId,\n            roomId: createUniqueUuid(runtime, targetChannel.id),\n            content: {\n              source: 'discord',\n              thought: `I joined the voice channel ${targetChannel.name}`,\n              actions: ['JOIN_VOICE_STARTED'],\n            },\n            metadata: {\n              type: 'JOIN_VOICE',\n            },\n          },\n          'messages'\n        );\n        return true;\n      }\n    }\n\n    await callback({\n      text: \"I couldn't figure out which channel you wanted me to join.\",\n      source: 'discord',\n    });\n    return false;\n  },\n  examples: [\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: \"Hey, let's jump into the 'General' voice and chat\",\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'Sounds good',\n          actions: ['JOIN_VOICE'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: '{{name2}}, can you join the vc, I want to discuss our strat',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: \"Sure I'll join right now\",\n          actions: ['JOIN_VOICE'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: \"hey {{name2}}, we're having a team meeting in the 'conference' voice channel, plz join us\",\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'OK see you there',\n          actions: ['JOIN_VOICE'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: \"{{name2}}, let's have a quick voice chat in the 'Lounge' channel.\",\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'kk be there in a sec',\n          actions: ['JOIN_VOICE'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: \"Hey {{name2}}, can you join me in the 'Music' voice channel\",\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'Sure',\n          actions: ['JOIN_VOICE'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'join voice chat with us {{name2}}',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'coming',\n          actions: ['JOIN_VOICE'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'hop in vc {{name2}}',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'joining now',\n          actions: ['JOIN_VOICE'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'get in vc with us {{name2}}',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'im in',\n          actions: ['JOIN_VOICE'],\n        },\n      },\n    ],\n  ] as ActionExample[][],\n} as Action;\n\nexport default joinVoice;\n","import type { Character, EntityPayload, MessagePayload, WorldPayload } from '@elizaos/core';\nimport type {\n  Client as DiscordJsClient,\n  Guild,\n  GuildMember,\n  Message,\n  MessageReaction,\n  User,\n  VoiceState,\n} from 'discord.js';\n\n/**\n * Discord-specific event types\n */\nexport enum DiscordEventTypes {\n  // Message events (prefixed versions of core events)\n  MESSAGE_RECEIVED = 'DISCORD_MESSAGE_RECEIVED',\n  MESSAGE_SENT = 'DISCORD_MESSAGE_SENT',\n\n  // Reaction events\n  REACTION_RECEIVED = 'DISCORD_REACTION_RECEIVED',\n  REACTION_REMOVED = 'DISCORD_REACTION_REMOVED',\n\n  // Server events\n  WORLD_JOINED = 'DISCORD_WORLD_JOINED',\n  WORLD_CONNECTED = 'DISCORD_SERVER_CONNECTED',\n\n  // User events\n  ENTITY_JOINED = 'DISCORD_USER_JOINED',\n  ENTITY_LEFT = 'DISCORD_USER_LEFT',\n\n  // Voice events\n  VOICE_STATE_CHANGED = 'DISCORD_VOICE_STATE_CHANGED',\n}\n\n/**\n * Discord-specific message received payload\n */\nexport interface DiscordMessageReceivedPayload extends MessagePayload {\n  /** The original Discord message */\n  originalMessage: Message;\n}\n\n/**\n * Discord-specific message sent payload\n */\nexport interface DiscordMessageSentPayload extends MessagePayload {\n  /** The original Discord messages sent */\n  originalMessages: Message[];\n}\n\n/**\n * Discord-specific reaction received payload\n */\nexport interface DiscordReactionPayload extends MessagePayload {\n  /** The original Discord reaction */\n  originalReaction: MessageReaction;\n  /** The user who reacted */\n  user: User;\n}\n/**\n * Discord-specific server payload\n */\nexport interface DiscordServerPayload extends WorldPayload {\n  /** The original Discord guild */\n  server: Guild;\n}\n\n/**\n * Discord-specific user joined payload\n */\nexport interface DiscordUserJoinedPayload extends EntityPayload {\n  /** The original Discord guild member */\n  member: GuildMember;\n}\n\n/**\n * Discord-specific user left payload\n */\nexport interface DiscordUserLeftPayload extends EntityPayload {\n  /** The original Discord guild member */\n  member: GuildMember;\n}\n\n/**\n * Discord-specific voice state changed payload\n */\nexport interface DiscordVoiceStateChangedPayload {\n  /** The original Discord voice state */\n  voiceState: VoiceState;\n}\n\n/**\n * Maps Discord event types to their payload interfaces\n */\nexport interface DiscordEventPayloadMap {\n  [DiscordEventTypes.MESSAGE_RECEIVED]: DiscordMessageReceivedPayload;\n  [DiscordEventTypes.MESSAGE_SENT]: DiscordMessageSentPayload;\n  [DiscordEventTypes.REACTION_RECEIVED]: DiscordReactionPayload;\n  [DiscordEventTypes.REACTION_REMOVED]: DiscordReactionPayload;\n  [DiscordEventTypes.WORLD_JOINED]: DiscordServerPayload;\n  [DiscordEventTypes.WORLD_CONNECTED]: DiscordServerPayload;\n  [DiscordEventTypes.ENTITY_JOINED]: DiscordUserJoinedPayload;\n  [DiscordEventTypes.ENTITY_LEFT]: DiscordUserLeftPayload;\n  [DiscordEventTypes.VOICE_STATE_CHANGED]: DiscordVoiceStateChangedPayload;\n}\n\n/**\n * Interface representing a Discord service.\n *\n * @typedef {Object} IDiscordService\n * @property {DiscordJsClient} client - The Discord client object.\n * @property {Character} character - The character object.\n */\nexport interface IDiscordService {\n  client: DiscordJsClient;\n  character: Character;\n}\n\nexport const DISCORD_SERVICE_NAME = 'discord';\n\nexport const ServiceType = {\n  DISCORD: 'discord',\n} as const;\n","// src/actions/leaveVoice\nimport {\n  type Action,\n  type ActionExample,\n  ChannelType,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  createUniqueUuid,\n  logger,\n} from '@elizaos/core';\nimport { BaseGuildVoiceChannel } from 'discord.js';\n\nimport type { DiscordService } from '../service';\nimport { ServiceType } from '../types';\nimport type { VoiceManager } from '../voice';\n\nexport const leaveVoice: Action = {\n  name: 'LEAVE_VOICE',\n  similes: [\n    'LEAVE_VOICE',\n    'LEAVE_VC',\n    'LEAVE_VOICE_CHAT',\n    'LEAVE_VOICE_CHANNEL',\n    'LEAVE_MEETING',\n    'LEAVE_CALL',\n  ],\n  validate: async (runtime: IAgentRuntime, message: Memory, state: State) => {\n    if (message.content.source !== 'discord') {\n      // not a discord message\n      return false;\n    }\n\n    const service = runtime.getService(ServiceType.DISCORD) as DiscordService;\n\n    if (!service) {\n      logger.error('Discord client not found');\n      return false;\n    }\n\n    const room = state.data.room ?? (await runtime.getRoom(message.roomId));\n\n    if (room?.type !== ChannelType.GROUP && room?.type !== ChannelType.VOICE_GROUP) {\n      return false;\n    }\n\n    // Check if the client is connected to any voice channel\n    const isConnectedToVoice = service.client.voice.adapters.size > 0;\n\n    return isConnectedToVoice;\n  },\n  description: 'Leave the current voice channel.',\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    _state: State,\n    _options: any\n  ): Promise<boolean> => {\n    const room = await runtime.getRoom(message.roomId);\n    if (!room) {\n      throw new Error('No room found');\n    }\n\n    if (room?.type !== ChannelType.GROUP && room?.type !== ChannelType.VOICE_GROUP) {\n      throw new Error('Not a group');\n    }\n\n    const serverId = room.serverId;\n\n    if (!serverId) {\n      throw new Error('No server ID found 9');\n    }\n    const discordClient = runtime.getService(ServiceType.DISCORD) as DiscordService;\n    const voiceManager = discordClient.voiceManager as VoiceManager;\n    const client = discordClient.client;\n\n    if (!client) {\n      logger.error('Discord client not found');\n      throw new Error('Discord client not found');\n    }\n\n    if (!voiceManager) {\n      logger.error('voiceManager is not available.');\n      throw new Error('voiceManager is not available.');\n    }\n\n    const guild = client.guilds.cache.get(serverId);\n\n    if (!guild) {\n      console.warn('Bot is not in any voice channel.');\n      // create a memory with thought to self to self\n      await runtime.createMemory(\n        {\n          entityId: message.entityId,\n          agentId: message.agentId,\n          roomId: message.roomId,\n          content: {\n            source: 'discord',\n            thought: \"I tried to leave the voice channel but I'm not in any voice channel.\",\n            actions: ['LEAVE_VOICE'],\n          },\n          metadata: {\n            type: 'LEAVE_VOICE',\n          },\n        },\n        'messages'\n      );\n      return false;\n    }\n\n    const voiceChannel = guild.members.me?.voice.channel;\n\n    if (!voiceChannel || !(voiceChannel instanceof BaseGuildVoiceChannel)) {\n      console.warn('Could not retrieve the voice channel.');\n      await runtime.createMemory(\n        {\n          entityId: message.entityId,\n          agentId: message.agentId,\n          roomId: message.roomId,\n          content: {\n            source: 'discord',\n            thought: \"I tried to leave the voice channel but I couldn't find it.\",\n            actions: ['LEAVE_VOICE'],\n          },\n          metadata: {\n            type: 'LEAVE_VOICE',\n          },\n        },\n        'messages'\n      );\n      return false;\n    }\n\n    const connection = voiceManager.getVoiceConnection(guild.id);\n    if (!connection) {\n      console.warn('No active voice connection found for the bot.');\n      await runtime.createMemory(\n        {\n          entityId: message.entityId,\n          agentId: message.agentId,\n          roomId: message.roomId,\n          content: {\n            source: 'discord',\n            thought: \"I tried to leave the voice channel but I couldn't find the connection.\",\n            actions: ['LEAVE_VOICE'],\n          },\n          metadata: {\n            type: 'LEAVE_VOICE',\n          },\n        },\n        'messages'\n      );\n      return false;\n    }\n\n    voiceManager.leaveChannel(voiceChannel);\n    // save a memory for the new channel as well\n    await runtime.createMemory(\n      {\n        entityId: message.entityId,\n        agentId: message.agentId,\n        roomId: createUniqueUuid(runtime, voiceChannel.id),\n        content: {\n          source: 'discord',\n          thought: `I left the voice channel ${voiceChannel.name}`,\n          actions: ['LEAVE_VOICE_STARTED'],\n        },\n        metadata: {\n          type: 'LEAVE_VOICE',\n        },\n      },\n      'messages'\n    );\n\n    return true;\n  },\n  examples: [\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'Hey {{name2}} please leave the voice channel',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'Sure',\n          actions: ['LEAVE_VOICE'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'I have to go now but thanks for the chat',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'You too, talk to you later',\n          actions: ['LEAVE_VOICE'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'Great call everyone, hopping off now',\n          actions: ['LEAVE_VOICE'],\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: \"Agreed, I'll hop off too\",\n          actions: ['LEAVE_VOICE'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'Hey {{name2}} I need you to step away from the voice chat for a bit',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: \"No worries, I'll leave the voice channel\",\n          actions: ['LEAVE_VOICE'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: '{{name2}}, I think we covered everything, you can leave the voice chat now',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'Sounds good, see you both later',\n          actions: ['LEAVE_VOICE'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'leave voice {{name2}}',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'ok leaving',\n          actions: ['LEAVE_VOICE'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'plz leave the voice chat {{name2}}',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'aight im out',\n          actions: ['LEAVE_VOICE'],\n        },\n      },\n    ],\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'yo {{name2}} gtfo the vc',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'sorry, talk to you later',\n          actions: ['LEAVE_VOICE'],\n        },\n      },\n    ],\n  ] as ActionExample[][],\n} as Action;\n\nexport default leaveVoice;\n","import type { IAgentRuntime, Memory, Provider, State } from '@elizaos/core';\nimport { ChannelType } from '@elizaos/core';\nimport type { DiscordService } from '../service';\nimport { ServiceType } from '../types';\n\n/**\n * Represents a provider for retrieving channel state information.\n * @type {Provider}\n * @property {string} name - The name of the channel state provider.\n * @property {Function} get - Asynchronous function that retrieves channel state information based on the provided runtime, message, and optional state parameters.\n * @param {IAgentRuntime} runtime - The agent runtime.\n * @param {Memory} message - The message object.\n * @param {State} [state] - Optional state object.\n * @returns {Promise<Object>} A promise that resolves to an object containing channel state data, values, and text.\n */\nexport const channelStateProvider: Provider = {\n  name: 'channelState',\n  get: async (runtime: IAgentRuntime, message: Memory, state?: State) => {\n    const room = state.data?.room ?? (await runtime.getRoom(message.roomId));\n    if (!room) {\n      throw new Error('No room found');\n    }\n\n    // if message source is not discord, return\n    if (message.content.source !== 'discord') {\n      return {\n        data: null,\n        values: {},\n        text: '',\n      };\n    }\n\n    const agentName = state?.agentName || 'The agent';\n    const senderName = state?.senderName || 'someone';\n\n    let responseText = '';\n    let channelType = '';\n    let serverName = '';\n    let channelId = '';\n    const serverId = room.serverId;\n\n    if (room.type === ChannelType.DM) {\n      channelType = 'DM';\n      responseText = `${agentName} is currently in a direct message conversation with ${senderName}. ${agentName} should engage in conversation, should respond to messages that are addressed to them and only ignore messages that seem to not require a response.`;\n    } else {\n      channelType = 'GROUP';\n\n      if (!serverId) {\n        console.error('No server ID found');\n        return {\n          data: {\n            room,\n            channelType,\n          },\n          values: {\n            channelType,\n          },\n          text: '',\n        };\n      }\n\n      channelId = room.channelId;\n\n      const discordService = runtime.getService(ServiceType.DISCORD) as DiscordService;\n      if (!discordService) {\n        console.warn('No discord client found');\n        return {\n          data: {\n            room,\n            channelType,\n            serverId,\n          },\n          values: {\n            channelType,\n            serverId,\n          },\n          text: '',\n        };\n      }\n\n      const guild = discordService.client.guilds.cache.get(serverId);\n      serverName = guild.name;\n\n      responseText = `${agentName} is currently having a conversation in the channel \\`@${channelId} in the server \\`${serverName}\\` (@${serverId})`;\n      responseText += `\\n${agentName} is in a room with other users and should be self-conscious and only participate when directly addressed or when the conversation is relevant to them.`;\n    }\n\n    return {\n      data: {\n        room,\n        channelType,\n        serverId,\n        serverName,\n        channelId,\n      },\n      values: {\n        channelType,\n        serverName,\n        channelId,\n      },\n      text: responseText,\n    };\n  },\n};\n\nexport default channelStateProvider;\n","import { getVoiceConnection } from '@discordjs/voice';\nimport type { IAgentRuntime, Memory, Provider, State } from '@elizaos/core';\nimport { ChannelType } from '@elizaos/core';\n\n/**\n * Provides information about the voice state of the user, including whether they are currently in a voice channel.\n *\n * @param {IAgentRuntime} runtime - The runtime object for the agent\n * @param {Memory} message - The message object containing room ID\n * @param {State} [state] - Optional state object for the user\n * @returns {Object} An object containing information about the voice state of the user\n */\nexport const voiceStateProvider: Provider = {\n  name: 'voiceState',\n  get: async (runtime: IAgentRuntime, message: Memory, state?: State) => {\n    // Voice doesn't get a discord message, so we need to use the channel for guild data\n    const room = await runtime.getRoom(message.roomId);\n    if (!room) {\n      throw new Error('No room found');\n    }\n\n    if (room.type !== ChannelType.GROUP) {\n      // only handle in a group scenario for now\n      return {\n        data: {\n          isInVoiceChannel: false,\n          room,\n        },\n        values: {\n          isInVoiceChannel: 'false',\n          roomType: room.type,\n        },\n        text: '',\n      };\n    }\n\n    const serverId = room.serverId;\n\n    if (!serverId) {\n      throw new Error('No server ID found 10');\n    }\n\n    const connection = getVoiceConnection(serverId);\n    const agentName = state?.agentName || 'The agent';\n\n    if (!connection) {\n      return {\n        data: {\n          isInVoiceChannel: false,\n          room,\n          serverId,\n        },\n        values: {\n          isInVoiceChannel: 'false',\n          serverId,\n        },\n        text: `${agentName} is not currently in a voice channel`,\n      };\n    }\n\n    const worldId = room.worldId;\n\n    // get the world from the runtime.getWorld\n    const world = await runtime.getWorld(worldId);\n\n    if (!world) {\n      throw new Error('No world found');\n    }\n\n    const worldName = world.name;\n    const roomType = room.type;\n    const channelId = room.channelId;\n    const channelName = room.name;\n\n    if (!channelId) {\n      return {\n        data: {\n          isInVoiceChannel: true,\n          room,\n          serverId,\n          world,\n          connection,\n        },\n        values: {\n          isInVoiceChannel: 'true',\n          serverId,\n          worldName,\n          roomType,\n        },\n        text: `${agentName} is in an invalid voice channel`,\n      };\n    }\n\n    return {\n      data: {\n        isInVoiceChannel: true,\n        room,\n        serverId,\n        world,\n        connection,\n        channelId,\n        channelName,\n      },\n      values: {\n        isInVoiceChannel: 'true',\n        serverId,\n        worldName,\n        roomType,\n        channelId,\n        channelName,\n      },\n      text: `${agentName} is currently in the voice channel: ${channelName} (ID: ${channelId})`,\n    };\n  },\n};\n\nexport default voiceStateProvider;\n","import {\n  ChannelType,\n  type Character,\n  type Entity,\n  EventType,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  Role,\n  Service,\n  type UUID,\n  type World,\n  createUniqueUuid,\n  logger,\n} from '@elizaos/core';\nimport {\n  type Channel,\n  ChannelType as DiscordChannelType,\n  Client as DiscordJsClient,\n  Events,\n  GatewayIntentBits,\n  type Guild,\n  type GuildMember,\n  type MessageReaction,\n  type OAuth2Guild,\n  type PartialMessageReaction,\n  type PartialUser,\n  Partials,\n  PermissionsBitField,\n  type TextChannel,\n  type User,\n} from 'discord.js';\nimport { DISCORD_SERVICE_NAME } from './constants';\nimport { MessageManager } from './messages';\nimport { DiscordEventTypes, type IDiscordService } from './types';\nimport { VoiceManager } from './voice';\n\n/**\n * DiscordService class representing a service for interacting with Discord.\n * @extends Service\n * @implements IDiscordService\n * @property {string} serviceType - The type of service, set to DISCORD_SERVICE_NAME.\n * @property {string} capabilityDescription - A description of the service's capabilities.\n * @property {DiscordJsClient} client - The DiscordJsClient used for communication.\n * @property {Character} character - The character associated with the service.\n * @property {MessageManager} messageManager - The manager for handling messages.\n * @property {VoiceManager} voiceManager - The manager for handling voice communication.\n */\n\nexport class DiscordService extends Service implements IDiscordService {\n  static serviceType: string = DISCORD_SERVICE_NAME;\n  capabilityDescription = 'The agent is able to send and receive messages on discord';\n  client: DiscordJsClient;\n  character: Character;\n  messageManager: MessageManager;\n  voiceManager: VoiceManager;\n\n  /**\n   * Constructor for Discord client.\n   * Initializes the Discord client with specified intents and partials,\n   * sets up event listeners, and ensures all servers exist.\n   *\n   * @param {IAgentRuntime} runtime - The AgentRuntime instance\n   */\n  constructor(runtime: IAgentRuntime) {\n    super(runtime);\n\n    // Check if Discord API token is available and valid\n    const token = runtime.getSetting('DISCORD_API_TOKEN') as string;\n    if (!token || token.trim() === '') {\n      logger.warn('Discord API Token not provided - Discord functionality will be unavailable');\n      this.client = null;\n      return;\n    }\n\n    try {\n      this.client = new DiscordJsClient({\n        intents: [\n          GatewayIntentBits.Guilds,\n          GatewayIntentBits.GuildMembers,\n          GatewayIntentBits.GuildPresences,\n          GatewayIntentBits.DirectMessages,\n          GatewayIntentBits.GuildVoiceStates,\n          GatewayIntentBits.MessageContent,\n          GatewayIntentBits.GuildMessages,\n          GatewayIntentBits.DirectMessageTyping,\n          GatewayIntentBits.GuildMessageTyping,\n          GatewayIntentBits.GuildMessageReactions,\n        ],\n        partials: [Partials.Channel, Partials.Message, Partials.User, Partials.Reaction],\n      });\n\n      this.runtime = runtime;\n      this.voiceManager = new VoiceManager(this, runtime);\n      this.messageManager = new MessageManager(this);\n\n      this.client.once(Events.ClientReady, this.onClientReady.bind(this));\n      this.client.login(token).catch((error) => {\n        logger.error(`Failed to login to Discord: ${error.message}`);\n        this.client = null;\n      });\n\n      this.setupEventListeners();\n    } catch (error) {\n      logger.error(`Error initializing Discord client: ${error.message}`);\n      this.client = null;\n    }\n  }\n\n  /**\n   * Set up event listeners for the client\n   */\n  private setupEventListeners() {\n    if (!this.client) {\n      return; // Skip if client is not available\n    }\n\n    // Setup handling for direct messages\n    this.client.on('messageCreate', (message) => {\n      // Skip if we're sending the message or in deleted state\n      if (message.author.id === this.client?.user?.id || message.author.bot) {\n        return;\n      }\n\n      try {\n        this.messageManager.handleMessage(message);\n      } catch (error) {\n        logger.error(`Error handling message: ${error}`);\n      }\n    });\n\n    // Setup handling for reactions\n    this.client.on('messageReactionAdd', async (reaction, user) => {\n      if (user.id === this.client?.user?.id) {\n        return;\n      }\n      try {\n        await this.handleReactionAdd(reaction, user);\n      } catch (error) {\n        logger.error(`Error handling reaction add: ${error}`);\n      }\n    });\n\n    // Handle reaction removal\n    this.client.on('messageReactionRemove', async (reaction, user) => {\n      if (user.id === this.client?.user?.id) {\n        return;\n      }\n      try {\n        await this.handleReactionRemove(reaction, user);\n      } catch (error) {\n        logger.error(`Error handling reaction remove: ${error}`);\n      }\n    });\n\n    // Setup guild (server) event handlers\n    this.client.on('guildCreate', async (guild) => {\n      try {\n        await this.handleGuildCreate(guild);\n      } catch (error) {\n        logger.error(`Error handling guild create: ${error}`);\n      }\n    });\n\n    // Setup member (user) joining handlers\n    this.client.on('guildMemberAdd', async (member) => {\n      try {\n        await this.handleGuildMemberAdd(member);\n      } catch (error) {\n        logger.error(`Error handling guild member add: ${error}`);\n      }\n    });\n\n    // Interaction handlers\n    this.client.on('interactionCreate', async (interaction) => {\n      try {\n        await this.handleInteractionCreate(interaction);\n      } catch (error) {\n        logger.error(`Error handling interaction: ${error}`);\n      }\n    });\n\n    this.client.on('userStream', (entityId, name, userName, channel, opusDecoder) => {\n      if (entityId !== this.client?.user?.id) {\n        this.voiceManager.handleUserStream(entityId, name, userName, channel, opusDecoder);\n      }\n    });\n  }\n\n  /**\n   * Handles the event when a new member joins a guild.\n   *\n   * @param {GuildMember} member - The GuildMember object representing the new member that joined the guild.\n   * @returns {Promise<void>} - A Promise that resolves once the event handling is complete.\n   */\n  private async handleGuildMemberAdd(member: GuildMember) {\n    logger.log(`New member joined: ${member.user.username}`);\n\n    const guild = member.guild;\n\n    const tag = member.user.bot\n      ? `${member.user.username}#${member.user.discriminator}`\n      : member.user.username;\n\n    const worldId = createUniqueUuid(this.runtime, guild.id);\n    const entityId = createUniqueUuid(this.runtime, member.id);\n\n    // Emit standardized ENTITY_JOINED event\n    this.runtime.emitEvent([EventType.ENTITY_JOINED], {\n      runtime: this.runtime,\n      entityId,\n      worldId,\n      source: 'discord',\n      metadata: {\n        originalId: member.id,\n        username: tag,\n        displayName: member.displayName || member.user.username,\n        roles: member.roles.cache.map((r) => r.name),\n        joinedAt: member.joinedAt?.getTime(),\n      },\n    });\n\n    // Emit Discord-specific event\n    this.runtime.emitEvent([DiscordEventTypes.ENTITY_JOINED], {\n      runtime: this.runtime,\n      entityId,\n      worldId,\n      member,\n      guild,\n    });\n  }\n\n  /**\n   *\n   * Start the Discord service\n   * @param {IAgentRuntime} runtime - The runtime for the agent\n   * @returns {Promise<DiscordService>} A promise that resolves to a DiscordService instance\n   *\n   */\n  static async start(runtime: IAgentRuntime): Promise<DiscordService> {\n    const token = runtime.getSetting('DISCORD_API_TOKEN') as string;\n    if (!token || token.trim() === '') {\n      throw new Error('Discord API Token not provided');\n    }\n\n    const maxRetries = 5;\n    let retryCount = 0;\n    let lastError: Error | null = null;\n\n    while (retryCount < maxRetries) {\n      try {\n        const service = new DiscordService(runtime);\n        if (!service.client) {\n          throw new Error('Failed to initialize Discord client');\n        }\n\n        // Wait for client to be ready\n        await new Promise<void>((resolve, reject) => {\n          const timeout = setTimeout(() => {\n            reject(new Error('Discord client ready timeout'));\n          }, 30000); // 30 second timeout\n\n          service.client?.once('ready', () => {\n            clearTimeout(timeout);\n            resolve();\n          });\n        });\n\n        return service;\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n        logger.error(\n          `Discord initialization attempt ${retryCount + 1} failed: ${lastError.message}`\n        );\n        retryCount++;\n\n        if (retryCount < maxRetries) {\n          const delay = 2 ** retryCount * 1000; // Exponential backoff\n          logger.info(`Retrying Discord initialization in ${delay / 1000} seconds...`);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n      }\n    }\n\n    throw new Error(\n      `Discord initialization failed after ${maxRetries} attempts. Last error: ${lastError?.message}`\n    );\n  }\n\n  /**\n   * Stops the Discord client associated with the given runtime.\n   *\n   * @param {IAgentRuntime} runtime - The runtime associated with the Discord client.\n   * @returns {void}\n   */\n  static async stop(runtime: IAgentRuntime) {\n    const client = runtime.getService(DISCORD_SERVICE_NAME);\n    if (!client) {\n      logger.error('DiscordService not found');\n      return;\n    }\n    try {\n      // disconnect websocket\n      // this unbinds all the listeners\n      await client.stop();\n    } catch (e) {\n      logger.error('client-discord instance stop err', e);\n    }\n  }\n\n  /**\n   * Asynchronously stops the client by destroying it.\n   *\n   * @returns {Promise<void>}\n   */\n  async stop() {\n    await this.client?.destroy();\n  }\n\n  /**\n   * Handle the event when the client is ready.\n   * @param {Object} readyClient - The ready client object containing user information.\n   * @param {string} readyClient.user.tag - The username and discriminator of the client user.\n   * @param {string} readyClient.user.id - The user ID of the client.\n   * @returns {Promise<void>}\n   */\n  private async onClientReady(readyClient: { user: { tag: any; id: any } }) {\n    logger.success(`DISCORD: Logged in as ${readyClient.user?.tag}`);\n\n    // Register slash commands\n    const commands = [\n      {\n        name: 'joinchannel',\n        description: 'Join a voice channel',\n        options: [\n          {\n            name: 'channel',\n            type: 7, // CHANNEL type\n            description: 'The voice channel to join',\n            required: true,\n            channel_types: [2], // GuildVoice type\n          },\n        ],\n      },\n      {\n        name: 'leavechannel',\n        description: 'Leave the current voice channel',\n      },\n    ];\n\n    try {\n      await this.client?.application?.commands.set(commands);\n      logger.success('DISCORD: Slash commands registered');\n    } catch (error) {\n      console.error('Error registering slash commands:', error);\n    }\n\n    // Required permissions for the bot\n    const requiredPermissions = [\n      // Text Permissions\n      PermissionsBitField.Flags.ViewChannel,\n      PermissionsBitField.Flags.SendMessages,\n      PermissionsBitField.Flags.SendMessagesInThreads,\n      PermissionsBitField.Flags.CreatePrivateThreads,\n      PermissionsBitField.Flags.CreatePublicThreads,\n      PermissionsBitField.Flags.EmbedLinks,\n      PermissionsBitField.Flags.AttachFiles,\n      PermissionsBitField.Flags.AddReactions,\n      PermissionsBitField.Flags.UseExternalEmojis,\n      PermissionsBitField.Flags.UseExternalStickers,\n      PermissionsBitField.Flags.MentionEveryone,\n      PermissionsBitField.Flags.ManageMessages,\n      PermissionsBitField.Flags.ReadMessageHistory,\n      // Voice Permissions\n      PermissionsBitField.Flags.Connect,\n      PermissionsBitField.Flags.Speak,\n      PermissionsBitField.Flags.UseVAD,\n      PermissionsBitField.Flags.PrioritySpeaker,\n    ].reduce((a, b) => a | b, 0n);\n\n    logger.success('Use this URL to add the bot to your server:');\n    logger.success(\n      `https://discord.com/api/oauth2/authorize?client_id=${readyClient.user?.id}&permissions=${requiredPermissions}&scope=bot%20applications.commands`\n    );\n    await this.onReady();\n  }\n\n  /**\n   * Asynchronously retrieves the type of a given channel.\n   *\n   * @param {Channel} channel - The channel for which to determine the type.\n   * @returns {Promise<ChannelType>} A Promise that resolves with the type of the channel.\n   */\n  async getChannelType(channel: Channel): Promise<ChannelType> {\n    switch (channel.type) {\n      case DiscordChannelType.DM:\n        return ChannelType.DM;\n      case DiscordChannelType.GuildText:\n        return ChannelType.GROUP;\n      case DiscordChannelType.GuildVoice:\n        return ChannelType.VOICE_GROUP;\n    }\n  }\n\n  /**\n   * Handles the addition of a reaction on a message.\n   *\n   * @param {MessageReaction | PartialMessageReaction} reaction The reaction that was added.\n   * @param {User | PartialUser} user The user who added the reaction.\n   * @returns {void}\n   */\n  async handleReactionAdd(\n    reaction: MessageReaction | PartialMessageReaction,\n    user: User | PartialUser\n  ) {\n    try {\n      logger.log('Reaction added');\n\n      // Early returns\n      if (!reaction || !user) {\n        logger.warn('Invalid reaction or user');\n        return;\n      }\n\n      // Get emoji info\n      let emoji = reaction.emoji.name;\n      if (!emoji && reaction.emoji.id) {\n        emoji = `<:${reaction.emoji.name}:${reaction.emoji.id}>`;\n      }\n\n      // Fetch full message if partial\n      if (reaction.partial) {\n        try {\n          await reaction.fetch();\n        } catch (error) {\n          logger.error('Failed to fetch partial reaction:', error);\n          return;\n        }\n      }\n\n      // Generate IDs with timestamp to ensure uniqueness\n      const timestamp = Date.now();\n      const roomId = createUniqueUuid(this.runtime, reaction.message.channel.id);\n      const entityId = createUniqueUuid(this.runtime, user.id);\n      const reactionUUID = createUniqueUuid(\n        this.runtime,\n        `${reaction.message.id}-${user.id}-${emoji}-${timestamp}`\n      );\n\n      // Validate IDs\n      if (!entityId || !roomId) {\n        logger.error('Invalid user ID or room ID', {\n          entityId,\n          roomId,\n        });\n        return;\n      }\n\n      // Process message content\n      const messageContent = reaction.message.content || '';\n      const truncatedContent =\n        messageContent.length > 50 ? `${messageContent.substring(0, 50)}...` : messageContent;\n      const reactionMessage = `*Added <${emoji}> to: \"${truncatedContent}\"*`;\n\n      // Get user info\n      const userName = reaction.message.author?.username || 'unknown';\n      const name = reaction.message.author?.displayName || userName;\n\n      // TODO: Get the type of the channel\n      await this.runtime.ensureConnection({\n        entityId,\n        roomId,\n        userName,\n        name: name,\n        source: 'discord',\n        channelId: reaction.message.channel.id,\n        serverId: reaction.message.guild?.id,\n        type: await this.getChannelType(reaction.message.channel as Channel),\n      });\n\n      const inReplyTo = createUniqueUuid(this.runtime, reaction.message.id);\n\n      const memory: Memory = {\n        id: reactionUUID,\n        entityId,\n        agentId: this.runtime.agentId,\n        content: {\n          // name,\n          // userName,\n          text: reactionMessage,\n          source: 'discord',\n          inReplyTo,\n          channelType: await this.getChannelType(reaction.message.channel as Channel),\n        },\n        roomId,\n        createdAt: timestamp,\n      };\n\n      const callback: HandlerCallback = async (content) => {\n        if (!reaction.message.channel) {\n          logger.error('No channel found for reaction message');\n          return;\n        }\n        await (reaction.message.channel as TextChannel).send(content.text);\n        return [];\n      };\n\n      this.runtime.emitEvent(['DISCORD_REACTION_RECEIVED', 'REACTION_RECEIVED'], {\n        runtime: this.runtime,\n        message: memory,\n        callback,\n      });\n    } catch (error) {\n      logger.error('Error handling reaction:', error);\n    }\n  }\n\n  /**\n   * Handles the removal of a reaction on a message.\n   *\n   * @param {MessageReaction | PartialMessageReaction} reaction - The reaction that was removed.\n   * @param {User | PartialUser} user - The user who removed the reaction.\n   * @returns {Promise<void>} - A Promise that resolves after handling the reaction removal.\n   */\n  async handleReactionRemove(\n    reaction: MessageReaction | PartialMessageReaction,\n    user: User | PartialUser\n  ) {\n    try {\n      logger.log('Reaction removed');\n\n      let emoji = reaction.emoji.name;\n      if (!emoji && reaction.emoji.id) {\n        emoji = `<:${reaction.emoji.name}:${reaction.emoji.id}>`;\n      }\n\n      // Fetch the full message if it's a partial\n      if (reaction.partial) {\n        try {\n          await reaction.fetch();\n        } catch (error) {\n          logger.error('Something went wrong when fetching the message:', error);\n          return;\n        }\n      }\n\n      const messageContent = reaction.message.content || '';\n      const truncatedContent =\n        messageContent.length > 50 ? `${messageContent.substring(0, 50)}...` : messageContent;\n\n      const reactionMessage = `*Removed <${emoji}> from: \"${truncatedContent}\"*`;\n\n      const roomId = createUniqueUuid(this.runtime, reaction.message.channel.id);\n\n      const entityId = createUniqueUuid(this.runtime, user.id);\n      const timestamp = Date.now();\n      const reactionUUID = createUniqueUuid(\n        this.runtime,\n        `${reaction.message.id}-${user.id}-${emoji}-${timestamp}`\n      );\n\n      const userName = reaction.message.author?.username || 'unknown';\n      const name = reaction.message.author?.displayName || userName;\n\n      await this.runtime.ensureConnection({\n        entityId,\n        roomId,\n        userName,\n        name: name,\n        source: 'discord',\n        channelId: reaction.message.channel.id,\n        serverId: reaction.message.guild?.id,\n        type: await this.getChannelType(reaction.message.channel as Channel),\n      });\n\n      const memory: Memory = {\n        id: reactionUUID,\n        entityId,\n        agentId: this.runtime.agentId,\n        content: {\n          // name,\n          // userName,\n          text: reactionMessage,\n          source: 'discord',\n          inReplyTo: createUniqueUuid(this.runtime, reaction.message.id),\n          channelType: await this.getChannelType(reaction.message.channel as Channel),\n        },\n        roomId,\n        createdAt: Date.now(),\n      };\n\n      const callback: HandlerCallback = async (content) => {\n        if (!reaction.message.channel) {\n          logger.error('No channel found for reaction message');\n          return;\n        }\n        await (reaction.message.channel as TextChannel).send(content.text);\n        return [];\n      };\n\n      this.runtime.emitEvent([DiscordEventTypes.REACTION_RECEIVED], {\n        runtime: this.runtime,\n        message: memory,\n        callback,\n      });\n    } catch (error) {\n      logger.error('Error handling reaction removal:', error);\n    }\n  }\n\n  /**\n   * Handles the event when the bot joins a guild. It logs the guild name, fetches additional information about the guild, scans the guild for voice data, creates standardized world data structure, generates unique IDs, and emits events to the runtime.\n   * @param {Guild} guild - The guild that the bot has joined.\n   * @returns {Promise<void>}\n   */\n  private async handleGuildCreate(guild: Guild) {\n    logger.log(`Joined guild ${guild.name}`);\n    const fullGuild = await guild.fetch();\n    this.voiceManager.scanGuild(guild);\n\n    const ownerId = createUniqueUuid(this.runtime, fullGuild.ownerId);\n\n    // Create standardized world data structure\n    const worldId = createUniqueUuid(this.runtime, fullGuild.id);\n    const standardizedData = {\n      runtime: this.runtime,\n      rooms: await this.buildStandardizedRooms(fullGuild, worldId),\n      users: await this.buildStandardizedUsers(fullGuild),\n      world: {\n        id: worldId,\n        name: fullGuild.name,\n        agentId: this.runtime.agentId,\n        serverId: fullGuild.id,\n        metadata: {\n          ownership: fullGuild.ownerId ? { ownerId: ownerId } : undefined,\n          roles: {\n            [ownerId]: Role.OWNER,\n          },\n        },\n      } as World,\n      source: 'discord',\n    };\n\n    // Emit both Discord-specific and standardized events with the same data structure\n    this.runtime.emitEvent([DiscordEventTypes.WORLD_JOINED], {\n      runtime: this.runtime,\n      server: fullGuild,\n      source: 'discord',\n    });\n\n    // Emit standardized event with the same structure as WORLD_CONNECTED\n    this.runtime.emitEvent([EventType.WORLD_JOINED], standardizedData);\n  }\n\n  /**\n   * Handles interactions created by the user, specifically commands.\n   * @param {any} interaction - The interaction object received\n   * @returns {void}\n   */\n  private async handleInteractionCreate(interaction: any) {\n    if (!interaction.isCommand()) return;\n\n    switch (interaction.commandName) {\n      case 'joinchannel':\n        await this.voiceManager.handleJoinChannelCommand(interaction);\n        break;\n      case 'leavechannel':\n        await this.voiceManager.handleLeaveChannelCommand(interaction);\n        break;\n    }\n  }\n\n  /**\n   * Builds a standardized list of rooms from Discord guild channels\n   */\n  /**\n   * Build standardized rooms for a guild based on text and voice channels.\n   *\n   * @param {Guild} guild The guild to build rooms for.\n   * @param {UUID} _worldId The ID of the world to associate with the rooms.\n   * @returns {Promise<any[]>} An array of standardized room objects.\n   */\n  private async buildStandardizedRooms(guild: Guild, _worldId: UUID): Promise<any[]> {\n    const rooms = [];\n\n    for (const [channelId, channel] of guild.channels.cache) {\n      // Only process text and voice channels\n      if (\n        channel.type === DiscordChannelType.GuildText ||\n        channel.type === DiscordChannelType.GuildVoice\n      ) {\n        const roomId = createUniqueUuid(this.runtime, channelId);\n        let channelType;\n\n        switch (channel.type) {\n          case DiscordChannelType.GuildText:\n            channelType = ChannelType.GROUP;\n            break;\n          case DiscordChannelType.GuildVoice:\n            channelType = ChannelType.VOICE_GROUP;\n            break;\n          default:\n            channelType = ChannelType.GROUP;\n        }\n\n        // For text channels, we could potentially get member permissions\n        // But for performance reasons, keep this light for large guilds\n        let participants: UUID[] = [];\n\n        if (guild.memberCount < 1000 && channel.type === DiscordChannelType.GuildText) {\n          try {\n            // Only attempt this for smaller guilds\n            // Get members with read permissions for this channel\n            participants = Array.from(guild.members.cache.values())\n              .filter((member) =>\n                channel.permissionsFor(member)?.has(PermissionsBitField.Flags.ViewChannel)\n              )\n              .map((member) => createUniqueUuid(this.runtime, member.id));\n          } catch (error) {\n            logger.warn(`Failed to get participants for channel ${channel.name}:`, error);\n          }\n        }\n\n        rooms.push({\n          id: roomId,\n          name: channel.name,\n          type: channelType,\n          channelId: channel.id,\n          participants,\n        });\n      }\n    }\n\n    return rooms;\n  }\n\n  /**\n   * Builds a standardized list of users from Discord guild members\n   */\n  private async buildStandardizedUsers(guild: Guild): Promise<Entity[]> {\n    const entities: Entity[] = [];\n    const botId = this.client?.user?.id;\n\n    // Strategy based on guild size\n    if (guild.memberCount > 1000) {\n      logger.info(\n        `Using optimized user sync for large guild ${guild.name} (${guild.memberCount} members)`\n      );\n\n      // For large guilds, prioritize members already in cache + online members\n      try {\n        // Use cache first\n        for (const [, member] of guild.members.cache) {\n          const tag = member.user.bot\n            ? `${member.user.username}#${member.user.discriminator}`\n            : member.user.username;\n\n          if (member.id !== botId) {\n            entities.push({\n              id: createUniqueUuid(this.runtime, member.id),\n              names: Array.from(\n                new Set([member.user.username, member.displayName, member.user.globalName])\n              ),\n              agentId: this.runtime.agentId,\n              metadata: {\n                default: {\n                  username: tag,\n                  name: member.displayName || member.user.username,\n                },\n                discord: member.user.globalName\n                  ? {\n                      username: tag,\n                      name: member.displayName || member.user.username,\n                      globalName: member.user.globalName,\n                      userId: member.id,\n                    }\n                  : {\n                      username: tag,\n                      name: member.displayName || member.user.username,\n                      userId: member.id,\n                    },\n              },\n            });\n          }\n        }\n\n        // If cache has very few members, try to get online members\n        if (entities.length < 100) {\n          logger.info(`Adding online members for ${guild.name}`);\n          // This is a more targeted fetch that is less likely to hit rate limits\n          const onlineMembers = await guild.members.fetch({ limit: 100 });\n\n          for (const [, member] of onlineMembers) {\n            if (member.id !== botId) {\n              const entityId = createUniqueUuid(this.runtime, member.id);\n              // Avoid duplicates\n              if (!entities.some((u) => u.id === entityId)) {\n                const tag = member.user.bot\n                  ? `${member.user.username}#${member.user.discriminator}`\n                  : member.user.username;\n\n                entities.push({\n                  id: entityId,\n                  names: Array.from(\n                    new Set([member.user.username, member.displayName, member.user.globalName])\n                  ),\n                  agentId: this.runtime.agentId,\n                  metadata: {\n                    default: {\n                      username: tag,\n                      name: member.displayName || member.user.username,\n                    },\n                    discord: member.user.globalName\n                      ? {\n                          username: tag,\n                          name: member.displayName || member.user.username,\n                          globalName: member.user.globalName,\n                          userId: member.id,\n                        }\n                      : {\n                          username: tag,\n                          name: member.displayName || member.user.username,\n                          userId: member.id,\n                        },\n                  },\n                });\n              }\n            }\n          }\n        }\n      } catch (error) {\n        logger.error(`Error fetching members for ${guild.name}:`, error);\n      }\n    } else {\n      // For smaller guilds, we can fetch all members\n      try {\n        let members = guild.members.cache;\n        if (members.size === 0) {\n          members = await guild.members.fetch();\n        }\n\n        for (const [, member] of members) {\n          if (member.id !== botId) {\n            const tag = member.user.bot\n              ? `${member.user.username}#${member.user.discriminator}`\n              : member.user.username;\n\n            entities.push({\n              id: createUniqueUuid(this.runtime, member.id),\n              names: Array.from(\n                new Set([member.user.username, member.displayName, member.user.globalName])\n              ),\n              agentId: this.runtime.agentId,\n              metadata: {\n                default: {\n                  username: tag,\n                  name: member.displayName || member.user.username,\n                },\n                discord: member.user.globalName\n                  ? {\n                      username: tag,\n                      name: member.displayName || member.user.username,\n                      globalName: member.user.globalName,\n                      userId: member.id,\n                    }\n                  : {\n                      username: tag,\n                      name: member.displayName || member.user.username,\n                      userId: member.id,\n                    },\n              },\n            });\n          }\n        }\n      } catch (error) {\n        logger.error(`Error fetching members for ${guild.name}:`, error);\n      }\n    }\n\n    return entities;\n  }\n\n  private async onReady() {\n    logger.log('DISCORD ON READY');\n    const guilds = await this.client?.guilds.fetch();\n    for (const [, guild] of guilds) {\n      const fullGuild = await guild.fetch();\n      await this.voiceManager.scanGuild(fullGuild);\n\n      // Send after a brief delay\n      setTimeout(async () => {\n        // For each server the client is in, fire a connected event\n        const fullGuild = await guild.fetch();\n        logger.log('DISCORD SERVER CONNECTED', fullGuild.name);\n\n        // Emit Discord-specific event with full guild object\n        this.runtime.emitEvent([DiscordEventTypes.WORLD_CONNECTED], {\n          runtime: this.runtime,\n          server: fullGuild,\n          source: 'discord',\n        });\n\n        // Create platform-agnostic world data structure with simplified structure\n        const worldId = createUniqueUuid(this.runtime, fullGuild.id);\n        const ownerId = createUniqueUuid(this.runtime, fullGuild.ownerId);\n\n        const standardizedData = {\n          name: fullGuild.name,\n          runtime: this.runtime,\n          rooms: await this.buildStandardizedRooms(fullGuild, worldId),\n          entities: await this.buildStandardizedUsers(fullGuild),\n          world: {\n            id: worldId,\n            name: fullGuild.name,\n            agentId: this.runtime.agentId,\n            serverId: fullGuild.id,\n            metadata: {\n              ownership: fullGuild.ownerId ? { ownerId } : undefined,\n              roles: {\n                [ownerId]: Role.OWNER,\n              },\n            },\n          } as World,\n          source: 'discord',\n        };\n\n        // Emit standardized event\n        this.runtime.emitEvent([EventType.WORLD_CONNECTED], standardizedData);\n      }, 1000);\n    }\n\n    this.client?.emit('voiceManagerReady');\n  }\n}\n\nexport default DiscordService;\n","export const MESSAGE_CONSTANTS = {\n  MAX_MESSAGES: 10,\n  RECENT_MESSAGE_COUNT: 3,\n  CHAT_HISTORY_COUNT: 5,\n  INTEREST_DECAY_TIME: 5 * 60 * 1000, // 5 minutes\n  PARTIAL_INTEREST_DECAY: 3 * 60 * 1000, // 3 minutes\n  DEFAULT_SIMILARITY_THRESHOLD: 0.3,\n  DEFAULT_SIMILARITY_THRESHOLD_FOLLOW_UPS: 0.2,\n} as const;\n\nexport const MESSAGE_LENGTH_THRESHOLDS = {\n  LOSE_INTEREST: 100,\n  SHORT_MESSAGE: 10,\n  VERY_SHORT_MESSAGE: 2,\n  IGNORE_RESPONSE: 4,\n} as const;\n\n/**\n * An array of words or phrases that indicate losing interest or annoyance.\n * @type {readonly [\"shut up\", \"stop\", \"please shut up\", \"shut up please\", \"dont talk\", \"silence\", \"stop talking\", \"be quiet\", \"hush\", \"wtf\", \"chill\", \"stfu\", \"stupid bot\", \"dumb bot\", \"stop responding\", \"god damn it\", \"god damn\", \"goddamnit\", \"can you not\", \"can you stop\", \"be quiet\", \"hate you\", \"hate this\", \"fuck up\"]}\n */\nexport const LOSE_INTEREST_WORDS = [\n  'shut up',\n  'stop',\n  'please shut up',\n  'shut up please',\n  'dont talk',\n  'silence',\n  'stop talking',\n  'be quiet',\n  'hush',\n  'wtf',\n  'chill',\n  'stfu',\n  'stupid bot',\n  'dumb bot',\n  'stop responding',\n  'god damn it',\n  'god damn',\n  'goddamnit',\n  'can you not',\n  'can you stop',\n  'be quiet',\n  'hate you',\n  'hate this',\n  'fuck up',\n] as const;\n\nexport const IGNORE_RESPONSE_WORDS = [\n  'lol',\n  'nm',\n  'uh',\n  'wtf',\n  'stfu',\n  'dumb',\n  'jfc',\n  'omg',\n] as const;\n\nexport const DISCORD_SERVICE_NAME = 'discord';\n","import {\n  ChannelType,\n  type Content,\n  EventType,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type IBrowserService,\n  type IVideoService,\n  type Media,\n  type Memory,\n  ServiceType,\n  createUniqueUuid,\n  logger,\n} from '@elizaos/core';\nimport {\n  type Channel,\n  type Client,\n  ChannelType as DiscordChannelType,\n  type Message as DiscordMessage,\n  type TextChannel,\n} from 'discord.js';\nimport { AttachmentManager } from './attachments';\nimport { DiscordEventTypes } from './types';\nimport { canSendMessage, sendMessageInChunks } from './utils';\n\n/**\n * Class representing a Message Manager for handling Discord messages.\n */\n\nexport class MessageManager {\n  private client: Client;\n  private runtime: IAgentRuntime;\n  private attachmentManager: AttachmentManager;\n  private getChannelType: (channel: Channel) => Promise<ChannelType>;\n  /**\n   * Constructor for a new instance of MyClass.\n   * @param {any} discordClient - The Discord client object.\n   */\n  constructor(discordClient: any) {\n    this.client = discordClient.client;\n    this.runtime = discordClient.runtime;\n    this.attachmentManager = new AttachmentManager(this.runtime);\n    this.getChannelType = discordClient.getChannelType;\n  }\n\n  /**\n   * Handles incoming Discord messages and processes them accordingly.\n   *\n   * @param {DiscordMessage} message - The Discord message to be handled\n   */\n  async handleMessage(message: DiscordMessage) {\n    if (\n      this.runtime.character.settings?.discord?.allowedChannelIds &&\n      !this.runtime.character.settings.discord.allowedChannelIds.some(\n        (id: string) => id === message.channel.id\n      )\n    ) {\n      return;\n    }\n\n    if (message.interaction || message.author.id === this.client.user?.id) {\n      return;\n    }\n\n    if (this.runtime.character.settings?.discord?.shouldIgnoreBotMessages && message.author?.bot) {\n      return;\n    }\n\n    if (\n      this.runtime.character.settings?.discord?.shouldIgnoreDirectMessages &&\n      message.channel.type === DiscordChannelType.DM\n    ) {\n      return;\n    }\n\n    if (\n      this.runtime.character.settings?.discord?.shouldRespondOnlyToMentions &&\n      !message.mentions.users?.has(this.client.user?.id)\n    ) {\n      return;\n    }\n\n    const entityId = createUniqueUuid(this.runtime, message.author.id);\n\n    const userName = message.author.bot\n      ? `${message.author.username}#${message.author.discriminator}`\n      : message.author.username;\n    const name = message.author.displayName;\n    const channelId = message.channel.id;\n    const roomId = createUniqueUuid(this.runtime, channelId);\n\n    let type: ChannelType;\n    let serverId: string | undefined;\n\n    if (message.guild) {\n      const guild = await message.guild.fetch();\n      type = await this.getChannelType(message.channel as Channel);\n      serverId = guild.id;\n    } else {\n      type = ChannelType.DM;\n      serverId = undefined;\n    }\n\n    await this.runtime.ensureConnection({\n      entityId: entityId,\n      roomId,\n      userName,\n      name: name,\n      source: 'discord',\n      channelId: message.channel.id,\n      serverId,\n      type,\n    });\n\n    try {\n      const canSendResult = canSendMessage(message.channel);\n      if (!canSendResult.canSend) {\n        return logger.warn(`Cannot send message to channel ${message.channel}`, canSendResult);\n      }\n\n      const { processedContent, attachments } = await this.processMessage(message);\n\n      const audioAttachments = message.attachments.filter((attachment) =>\n        attachment.contentType?.startsWith('audio/')\n      );\n\n      if (audioAttachments.size > 0) {\n        const processedAudioAttachments =\n          await this.attachmentManager.processAttachments(audioAttachments);\n        attachments.push(...processedAudioAttachments);\n      }\n\n      if (!processedContent && !attachments?.length) {\n        // Only process messages that are not empty\n        return;\n      }\n\n      const entityId = createUniqueUuid(this.runtime, message.author.id);\n\n      const messageId = createUniqueUuid(this.runtime, message.id);\n\n      const newMessage: Memory = {\n        id: messageId,\n        entityId: entityId,\n        agentId: this.runtime.agentId,\n        roomId: roomId,\n        content: {\n          // name: name,\n          // userName: userName,\n          text: processedContent || ' ',\n          attachments: attachments,\n          source: 'discord',\n          url: message.url,\n          inReplyTo: message.reference?.messageId\n            ? createUniqueUuid(this.runtime, message.reference?.messageId)\n            : undefined,\n        },\n        createdAt: message.createdTimestamp,\n      };\n\n      const callback: HandlerCallback = async (content: Content, files: any[]) => {\n        try {\n          if (message.id && !content.inReplyTo) {\n            content.inReplyTo = createUniqueUuid(this.runtime, message.id);\n          }\n          const messages = await sendMessageInChunks(\n            message.channel as TextChannel,\n            content.text,\n            message.id,\n            files\n          );\n\n          const memories: Memory[] = [];\n          for (const m of messages) {\n            const actions = content.actions;\n\n            const memory: Memory = {\n              id: createUniqueUuid(this.runtime, m.id),\n              entityId: this.runtime.agentId,\n              agentId: this.runtime.agentId,\n              content: {\n                ...content,\n                actions,\n                inReplyTo: messageId,\n                url: m.url,\n                channelType: type,\n              },\n              roomId,\n              createdAt: m.createdTimestamp,\n            };\n            memories.push(memory);\n          }\n\n          for (const m of memories) {\n            await this.runtime.createMemory(m, 'messages');\n          }\n          return memories;\n        } catch (error) {\n          console.error('Error sending message:', error);\n          return [];\n        }\n      };\n\n      this.runtime.emitEvent([DiscordEventTypes.MESSAGE_RECEIVED, EventType.MESSAGE_RECEIVED], {\n        runtime: this.runtime,\n        message: newMessage,\n        callback,\n      });\n    } catch (error) {\n      console.error('Error handling message:', error);\n    }\n  }\n\n  /**\n   * Processes the message content, mentions, code blocks, attachments, and URLs to generate\n   * processed content and media attachments.\n   *\n   * @param {DiscordMessage} message The message to process\n   * @returns {Promise<{ processedContent: string; attachments: Media[] }>} Processed content and media attachments\n   */\n  async processMessage(\n    message: DiscordMessage\n  ): Promise<{ processedContent: string; attachments: Media[] }> {\n    let processedContent = message.content;\n    let attachments: Media[] = [];\n\n    const mentionRegex = /<@!?(\\d+)>/g;\n    processedContent = processedContent.replace(mentionRegex, (match, entityId) => {\n      const user = message.mentions.users.get(entityId);\n      if (user) {\n        return `${user.username} (@${entityId})`;\n      }\n      return match;\n    });\n\n    const codeBlockRegex = /```([\\s\\S]*?)```/g;\n    let match;\n    while ((match = codeBlockRegex.exec(processedContent))) {\n      const codeBlock = match[1];\n      const lines = codeBlock.split('\\n');\n      const title = lines[0];\n      const description = lines.slice(0, 3).join('\\n');\n      const attachmentId = `code-${Date.now()}-${Math.floor(Math.random() * 1000)}`.slice(-5);\n      attachments.push({\n        id: attachmentId,\n        url: '',\n        title: title || 'Code Block',\n        source: 'Code',\n        description: description,\n        text: codeBlock,\n      });\n      processedContent = processedContent.replace(match[0], `Code Block (${attachmentId})`);\n    }\n\n    if (message.attachments.size > 0) {\n      attachments = await this.attachmentManager.processAttachments(message.attachments);\n    }\n\n    const urlRegex = /(https?:\\/\\/[^\\s]+)/g;\n    const urls = processedContent.match(urlRegex) || [];\n\n    for (const url of urls) {\n      if (this.runtime.getService<IVideoService>(ServiceType.VIDEO)?.isVideoUrl(url)) {\n        const videoService = this.runtime.getService<IVideoService>(ServiceType.VIDEO);\n        if (!videoService) {\n          throw new Error('Video service not found');\n        }\n        const videoInfo = await videoService.processVideo(url, this.runtime);\n\n        attachments.push({\n          id: `youtube-${Date.now()}`,\n          url: url,\n          title: videoInfo.title,\n          source: 'YouTube',\n          description: videoInfo.description,\n          text: videoInfo.text,\n        });\n      } else {\n        const browserService = this.runtime.getService<IBrowserService>(ServiceType.BROWSER);\n        if (!browserService) {\n          throw new Error('Browser service not found');\n        }\n\n        const { title, description: summary } = await browserService.getPageContent(\n          url,\n          this.runtime\n        );\n\n        attachments.push({\n          id: `webpage-${Date.now()}`,\n          url: url,\n          title: title || 'Web Page',\n          source: 'Web',\n          description: summary,\n          text: summary,\n        });\n      }\n    }\n\n    return { processedContent, attachments };\n  }\n\n  /**\n   * Asynchronously fetches the bot's username and discriminator from Discord API.\n   *\n   * @param {string} botToken The token of the bot to authenticate the request\n   * @returns {Promise<string>} A promise that resolves with the bot's username and discriminator\n   * @throws {Error} If there is an error while fetching the bot details\n   */\n\n  async fetchBotName(botToken: string) {\n    const url = 'https://discord.com/api/v10/users/@me';\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: {\n        Authorization: `Bot ${botToken}`,\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error(`Error fetching bot details: ${response.statusText}`);\n    }\n\n    const data = await response.json();\n    const discriminator = data.discriminator;\n    return (data as { username: string }).username + (discriminator ? `#${discriminator}` : '');\n  }\n}\n","import fs from 'node:fs';\nimport { trimTokens } from '@elizaos/core';\nimport { parseJSONObjectFromText } from '@elizaos/core';\nimport {\n  type IAgentRuntime,\n  type IPdfService,\n  type IVideoService,\n  type Media,\n  ModelType,\n  ServiceType,\n} from '@elizaos/core';\nimport { type Attachment, Collection } from 'discord.js';\nimport ffmpeg from 'fluent-ffmpeg';\n\n/**\n * Generates a summary for the provided text using a specified model.\n *\n * @param {IAgentRuntime} runtime - The runtime environment for the agent.\n * @param {string} text - The text to generate a summary for.\n * @returns {Promise<{ title: string; description: string }>} An object containing the generated title and description.\n */\n\nasync function generateSummary(\n  runtime: IAgentRuntime,\n  text: string\n): Promise<{ title: string; description: string }> {\n  // make sure text is under 128k characters\n  text = await trimTokens(text, 100000, runtime);\n\n  const prompt = `Please generate a concise summary for the following text:\n\n  Text: \"\"\"\n  ${text}\n  \"\"\"\n\n  Respond with a JSON object in the following format:\n  \\`\\`\\`json\n  {\n    \"title\": \"Generated Title\",\n    \"summary\": \"Generated summary and/or description of the text\"\n  }\n  \\`\\`\\``;\n\n  const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n    prompt,\n  });\n\n  const parsedResponse = parseJSONObjectFromText(response);\n\n  if (parsedResponse?.title && parsedResponse?.summary) {\n    return {\n      title: parsedResponse.title,\n      description: parsedResponse.summary,\n    };\n  }\n\n  return {\n    title: '',\n    description: '',\n  };\n}\n\n/**\n * Class representing an Attachment Manager.\n */\nexport class AttachmentManager {\n  private attachmentCache: Map<string, Media> = new Map();\n  private runtime: IAgentRuntime;\n\n  /**\n   * Constructor for creating a new instance of the class.\n   *\n   * @param {IAgentRuntime} runtime The runtime object to be injected into the instance.\n   */\n  constructor(runtime: IAgentRuntime) {\n    this.runtime = runtime;\n  }\n\n  /**\n   * Processes attachments and returns an array of Media objects.\n   * @param {Collection<string, Attachment> | Attachment[]} attachments - The attachments to be processed\n   * @returns {Promise<Media[]>} - An array of processed Media objects\n   */\n  async processAttachments(\n    attachments: Collection<string, Attachment> | Attachment[]\n  ): Promise<Media[]> {\n    const processedAttachments: Media[] = [];\n    const attachmentCollection =\n      attachments instanceof Collection\n        ? attachments\n        : new Collection(attachments.map((att) => [att.id, att]));\n\n    for (const [, attachment] of attachmentCollection) {\n      const media = await this.processAttachment(attachment);\n      if (media) {\n        processedAttachments.push(media);\n      }\n    }\n\n    return processedAttachments;\n  }\n\n  /**\n   * Processes the provided attachment to generate a media object.\n   * If the media for the attachment URL is already cached, it will return the cached media.\n   * Otherwise, it will determine the type of attachment (PDF, text, audio, video, image, generic)\n   * and call the corresponding processing method to generate the media object.\n   *\n   * @param attachment The attachment to process\n   * @returns A promise that resolves to a Media object representing the attachment, or null if the attachment could not be processed\n   */\n  async processAttachment(attachment: Attachment): Promise<Media | null> {\n    if (this.attachmentCache.has(attachment.url)) {\n      return this.attachmentCache.get(attachment.url)!;\n    }\n\n    let media: Media | null = null;\n    if (attachment.contentType?.startsWith('application/pdf')) {\n      media = await this.processPdfAttachment(attachment);\n    } else if (attachment.contentType?.startsWith('text/plain')) {\n      media = await this.processPlaintextAttachment(attachment);\n    } else if (\n      attachment.contentType?.startsWith('audio/') ||\n      attachment.contentType?.startsWith('video/mp4')\n    ) {\n      media = await this.processAudioVideoAttachment(attachment);\n    } else if (attachment.contentType?.startsWith('image/')) {\n      media = await this.processImageAttachment(attachment);\n    } else if (\n      attachment.contentType?.startsWith('video/') ||\n      this.runtime.getService<IVideoService>(ServiceType.VIDEO).isVideoUrl(attachment.url)\n    ) {\n      media = await this.processVideoAttachment(attachment);\n    } else {\n      media = await this.processGenericAttachment(attachment);\n    }\n\n    if (media) {\n      this.attachmentCache.set(attachment.url, media);\n    }\n    return media;\n  }\n\n  /**\n   * Asynchronously processes an audio or video attachment provided as input and returns a Media object.\n   * @param {Attachment} attachment - The attachment object containing information about the audio/video file.\n   * @returns {Promise<Media>} A Promise that resolves to a Media object representing the processed audio/video attachment.\n   */\n  private async processAudioVideoAttachment(attachment: Attachment): Promise<Media> {\n    try {\n      const response = await fetch(attachment.url);\n      const audioVideoArrayBuffer = await response.arrayBuffer();\n\n      let audioBuffer: Buffer;\n      if (attachment.contentType?.startsWith('audio/')) {\n        audioBuffer = Buffer.from(audioVideoArrayBuffer);\n      } else if (attachment.contentType?.startsWith('video/mp4')) {\n        audioBuffer = await this.extractAudioFromMP4(audioVideoArrayBuffer);\n      } else {\n        throw new Error('Unsupported audio/video format');\n      }\n\n      const transcription = await this.runtime.useModel(ModelType.TRANSCRIPTION, audioBuffer);\n      const { title, description } = await generateSummary(this.runtime, transcription);\n\n      return {\n        id: attachment.id,\n        url: attachment.url,\n        title: title || 'Audio/Video Attachment',\n        source: attachment.contentType?.startsWith('audio/') ? 'Audio' : 'Video',\n        description:\n          description || 'User-uploaded audio/video attachment which has been transcribed',\n        text: transcription || 'Audio/video content not available',\n      };\n    } catch (error) {\n      console.error(`Error processing audio/video attachment: ${error.message}`);\n      return {\n        id: attachment.id,\n        url: attachment.url,\n        title: 'Audio/Video Attachment',\n        source: attachment.contentType?.startsWith('audio/') ? 'Audio' : 'Video',\n        description: 'An audio/video attachment (transcription failed)',\n        text: `This is an audio/video attachment. File name: ${attachment.name}, Size: ${attachment.size} bytes, Content type: ${attachment.contentType}`,\n      };\n    }\n  }\n\n  /**\n   * Extracts the audio stream from the provided MP4 data and converts it to MP3 format.\n   *\n   * @param {ArrayBuffer} mp4Data - The MP4 data to extract audio from\n   * @returns {Promise<Buffer>} - A Promise that resolves with the converted audio data as a Buffer\n   */\n  private async extractAudioFromMP4(mp4Data: ArrayBuffer): Promise<Buffer> {\n    // Use a library like 'fluent-ffmpeg' or 'ffmpeg-static' to extract the audio stream from the MP4 data\n    // and convert it to MP3 or WAV format\n    // Example using fluent-ffmpeg:\n    const tempMP4File = `temp_${Date.now()}.mp4`;\n    const tempAudioFile = `temp_${Date.now()}.mp3`;\n\n    try {\n      // Write the MP4 data to a temporary file\n      fs.writeFileSync(tempMP4File, Buffer.from(mp4Data));\n\n      // Extract the audio stream and convert it to MP3\n      await new Promise<void>((resolve, reject) => {\n        ffmpeg(tempMP4File)\n          .outputOptions('-vn') // Disable video output\n          .audioCodec('libmp3lame') // Set audio codec to MP3\n          .save(tempAudioFile) // Save the output to the specified file\n          .on('end', () => {\n            resolve();\n          })\n          .on('error', (err) => {\n            reject(err);\n          })\n          .run();\n      });\n\n      // Read the converted audio file and return it as a Buffer\n      const audioData = fs.readFileSync(tempAudioFile);\n      return audioData;\n    } finally {\n      // Clean up the temporary files\n      if (fs.existsSync(tempMP4File)) {\n        fs.unlinkSync(tempMP4File);\n      }\n      if (fs.existsSync(tempAudioFile)) {\n        fs.unlinkSync(tempAudioFile);\n      }\n    }\n  }\n\n  /**\n   * Processes a PDF attachment by fetching the PDF file from the specified URL,\n   * converting it to text, generating a summary, and returning a Media object\n   * with the extracted information.\n   * If an error occurs during processing, a placeholder Media object is returned\n   * with an error message.\n   *\n   * @param {Attachment} attachment - The PDF attachment to process.\n   * @returns {Promise<Media>} A promise that resolves to a Media object representing\n   * the processed PDF attachment.\n   */\n  private async processPdfAttachment(attachment: Attachment): Promise<Media> {\n    try {\n      const response = await fetch(attachment.url);\n      const pdfBuffer = await response.arrayBuffer();\n      const text = await this.runtime\n        .getService<IPdfService>(ServiceType.PDF)\n        .convertPdfToText(Buffer.from(pdfBuffer));\n      const { title, description } = await generateSummary(this.runtime, text);\n\n      return {\n        id: attachment.id,\n        url: attachment.url,\n        title: title || 'PDF Attachment',\n        source: 'PDF',\n        description: description || 'A PDF document',\n        text: text,\n      };\n    } catch (error) {\n      console.error(`Error processing PDF attachment: ${error.message}`);\n      return {\n        id: attachment.id,\n        url: attachment.url,\n        title: 'PDF Attachment (conversion failed)',\n        source: 'PDF',\n        description: 'A PDF document that could not be converted to text',\n        text: `This is a PDF attachment. File name: ${attachment.name}, Size: ${attachment.size} bytes`,\n      };\n    }\n  }\n\n  /**\n   * Processes a plaintext attachment by fetching its content, generating a summary, and returning a Media object.\n   * @param {Attachment} attachment - The attachment object to process.\n   * @returns {Promise<Media>} A promise that resolves to a Media object representing the processed plaintext attachment.\n   */\n  private async processPlaintextAttachment(attachment: Attachment): Promise<Media> {\n    try {\n      const response = await fetch(attachment.url);\n      const text = await response.text();\n      const { title, description } = await generateSummary(this.runtime, text);\n\n      return {\n        id: attachment.id,\n        url: attachment.url,\n        title: title || 'Plaintext Attachment',\n        source: 'Plaintext',\n        description: description || 'A plaintext document',\n        text: text,\n      };\n    } catch (error) {\n      console.error(`Error processing plaintext attachment: ${error.message}`);\n      return {\n        id: attachment.id,\n        url: attachment.url,\n        title: 'Plaintext Attachment (retrieval failed)',\n        source: 'Plaintext',\n        description: 'A plaintext document that could not be retrieved',\n        text: `This is a plaintext attachment. File name: ${attachment.name}, Size: ${attachment.size} bytes`,\n      };\n    }\n  }\n\n  /**\n   * Process the image attachment by fetching description and title using the IMAGE_DESCRIPTION model.\n   * If successful, returns a Media object populated with the details. If unsuccessful, creates a fallback\n   * Media object and logs the error.\n   *\n   * @param {Attachment} attachment - The attachment object containing the image details.\n   * @returns {Promise<Media>} A promise that resolves to a Media object.\n   */\n  private async processImageAttachment(attachment: Attachment): Promise<Media> {\n    try {\n      const { description, title } = await this.runtime.useModel(\n        ModelType.IMAGE_DESCRIPTION,\n        attachment.url\n      );\n      return {\n        id: attachment.id,\n        url: attachment.url,\n        title: title || 'Image Attachment',\n        source: 'Image',\n        description: description || 'An image attachment',\n        text: description || 'Image content not available',\n      };\n    } catch (error) {\n      console.error(`Error processing image attachment: ${error.message}`);\n      return this.createFallbackImageMedia(attachment);\n    }\n  }\n\n  /**\n   * Creates a fallback Media object for image attachments that could not be recognized.\n   *\n   * @param {Attachment} attachment - The attachment object containing image details.\n   * @returns {Media} - The fallback Media object with basic information about the image attachment.\n   */\n\n  private createFallbackImageMedia(attachment: Attachment): Media {\n    return {\n      id: attachment.id,\n      url: attachment.url,\n      title: 'Image Attachment',\n      source: 'Image',\n      description: 'An image attachment (recognition failed)',\n      text: `This is an image attachment. File name: ${attachment.name}, Size: ${attachment.size} bytes, Content type: ${attachment.contentType}`,\n    };\n  }\n\n  /**\n   * Process a video attachment to extract video information.\n   * @param {Attachment} attachment - The attachment object containing video information.\n   * @returns {Promise<Media>} A promise that resolves to a Media object with video details.\n   * @throws {Error} If video service is not available.\n   */\n  private async processVideoAttachment(attachment: Attachment): Promise<Media> {\n    const videoService = this.runtime.getService<IVideoService>(ServiceType.VIDEO);\n\n    if (!videoService) {\n      throw new Error('Video service not found');\n    }\n\n    if (videoService.isVideoUrl(attachment.url)) {\n      const videoInfo = await videoService.processVideo(attachment.url, this.runtime);\n      return {\n        id: attachment.id,\n        url: attachment.url,\n        title: videoInfo.title,\n        source: 'YouTube',\n        description: videoInfo.description,\n        text: videoInfo.text,\n      };\n    }\n    return {\n      id: attachment.id,\n      url: attachment.url,\n      title: 'Video Attachment',\n      source: 'Video',\n      description: 'A video attachment',\n      text: 'Video content not available',\n    };\n  }\n\n  /**\n   * Process a generic attachment and return a Media object with specified properties.\n   * @param {Attachment} attachment - The attachment object to process.\n   * @returns {Promise<Media>} A Promise that resolves to a Media object with specified properties.\n   */\n  private async processGenericAttachment(attachment: Attachment): Promise<Media> {\n    return {\n      id: attachment.id,\n      url: attachment.url,\n      title: 'Generic Attachment',\n      source: 'Generic',\n      description: 'A generic attachment',\n      text: 'Attachment content not available',\n    };\n  }\n}\n","import {\n  type IAgentRuntime,\n  ModelType,\n  logger,\n  parseJSONObjectFromText,\n  trimTokens,\n} from '@elizaos/core';\nimport {\n  ChannelType,\n  type Message as DiscordMessage,\n  PermissionsBitField,\n  type TextChannel,\n  ThreadChannel,\n} from 'discord.js';\n\nconst MAX_MESSAGE_LENGTH = 1900;\n\n/**\n * Generates a summary for a given text using a specified model.\n *\n * @param {IAgentRuntime} runtime - The IAgentRuntime instance.\n * @param {string} text - The text for which to generate a summary.\n * @returns {Promise<{ title: string; description: string }>} An object containing the generated title and summary.\n */\nexport async function generateSummary(\n  runtime: IAgentRuntime,\n  text: string\n): Promise<{ title: string; description: string }> {\n  // make sure text is under 128k characters\n  text = await trimTokens(text, 100000, runtime);\n\n  const prompt = `Please generate a concise summary for the following text:\n\n  Text: \"\"\"\n  ${text}\n  \"\"\"\n\n  Respond with a JSON object in the following format:\n  \\`\\`\\`json\n  {\n    \"title\": \"Generated Title\",\n    \"summary\": \"Generated summary and/or description of the text\"\n  }\n  \\`\\`\\``;\n\n  const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n    prompt,\n  });\n\n  const parsedResponse = parseJSONObjectFromText(response);\n\n  if (parsedResponse?.title && parsedResponse?.summary) {\n    return {\n      title: parsedResponse.title,\n      description: parsedResponse.summary,\n    };\n  }\n\n  return {\n    title: '',\n    description: '',\n  };\n}\n\n/**\n * Sends a message in chunks to a specified Discord TextChannel.\n * @param {TextChannel} channel - The Discord TextChannel to send the message to.\n * @param {string} content - The content of the message to be sent.\n * @param {string} _inReplyTo - The message ID to reply to (if applicable).\n * @param {any[]} files - Array of files to attach to the message.\n * @returns {Promise<DiscordMessage[]>} - Array of sent Discord messages.\n */\nexport async function sendMessageInChunks(\n  channel: TextChannel,\n  content: string,\n  _inReplyTo: string,\n  files: any[]\n): Promise<DiscordMessage[]> {\n  const sentMessages: DiscordMessage[] = [];\n  const messages = splitMessage(content);\n  try {\n    for (let i = 0; i < messages.length; i++) {\n      const message = messages[i];\n      if (message.trim().length > 0 || (i === messages.length - 1 && files && files.length > 0)) {\n        const options: any = {\n          content: message.trim(),\n        };\n\n        // if (i === 0 && inReplyTo) {\n        //   // Reply to the specified message for the first chunk\n        //   options.reply = {\n        //     messageReference: inReplyTo,\n        //   };\n        // }\n\n        if (i === messages.length - 1 && files && files.length > 0) {\n          // Attach files to the last message chunk\n          options.files = files;\n        }\n\n        const m = await channel.send(options);\n        sentMessages.push(m);\n      }\n    }\n  } catch (error) {\n    logger.error('Error sending message:', error);\n  }\n\n  return sentMessages;\n}\n\n/**\n * Splits the content into an array of strings based on the maximum message length.\n * @param {string} content - The content to split into messages\n * @returns {string[]} An array of strings that represent the split messages\n */\nfunction splitMessage(content: string): string[] {\n  const messages: string[] = [];\n  let currentMessage = '';\n\n  const rawLines = content?.split('\\n') || [];\n  // split all lines into MAX_MESSAGE_LENGTH chunks so any long lines are split\n  const lines = rawLines.flatMap((line) => {\n    const chunks = [];\n    while (line.length > MAX_MESSAGE_LENGTH) {\n      chunks.push(line.slice(0, MAX_MESSAGE_LENGTH));\n      line = line.slice(MAX_MESSAGE_LENGTH);\n    }\n    chunks.push(line);\n    return chunks;\n  });\n\n  for (const line of lines) {\n    if (currentMessage.length + line.length + 1 > MAX_MESSAGE_LENGTH) {\n      messages.push(currentMessage.trim());\n      currentMessage = '';\n    }\n    currentMessage += `${line}\\n`;\n  }\n\n  if (currentMessage.trim().length > 0) {\n    messages.push(currentMessage.trim());\n  }\n\n  return messages;\n}\n\n/**\n * Checks if the bot can send messages in a given channel by checking permissions.\n * @param {TextChannel | NewsChannel | ThreadChannel} channel - The channel to check permissions for.\n * @returns {Object} Object containing information about whether the bot can send messages or not.\n * @returns {boolean} canSend - Whether the bot can send messages in the channel.\n * @returns {string} reason - The reason why the bot cannot send messages, if applicable.\n * @returns {string[]} missingPermissions - Array of missing permissions, if any.\n */\nexport function canSendMessage(channel) {\n  // validate input\n  if (!channel) {\n    return {\n      canSend: false,\n      reason: 'No channel given',\n    };\n  }\n  // if it is a DM channel, we can always send messages\n  if (channel.type === ChannelType.DM) {\n    return {\n      canSend: true,\n      reason: null,\n    };\n  }\n  const botMember = channel.guild?.members.cache.get(channel.client.user.id);\n\n  if (!botMember) {\n    return {\n      canSend: false,\n      reason: 'Not a guild channel or bot member not found',\n    };\n  }\n\n  // Required permissions for sending messages\n  const requiredPermissions = [\n    PermissionsBitField.Flags.ViewChannel,\n    PermissionsBitField.Flags.SendMessages,\n    PermissionsBitField.Flags.ReadMessageHistory,\n  ];\n\n  // Add thread-specific permission if it's a thread\n  if (channel instanceof ThreadChannel) {\n    requiredPermissions.push(PermissionsBitField.Flags.SendMessagesInThreads);\n  }\n\n  // Check permissions\n  const permissions = channel.permissionsFor(botMember);\n\n  if (!permissions) {\n    return {\n      canSend: false,\n      reason: 'Could not retrieve permissions',\n    };\n  }\n\n  // Check each required permission\n  const missingPermissions = requiredPermissions.filter((perm) => !permissions.has(perm));\n\n  return {\n    canSend: missingPermissions.length === 0,\n    missingPermissions: missingPermissions,\n    reason:\n      missingPermissions.length > 0\n        ? `Missing permissions: ${missingPermissions.map((p) => String(p)).join(', ')}`\n        : null,\n  };\n}\n","import { EventEmitter } from 'node:events';\nimport { type Readable, pipeline } from 'node:stream';\nimport {\n  type AudioPlayer,\n  type AudioReceiveStream,\n  NoSubscriberBehavior,\n  StreamType,\n  type VoiceConnection,\n  VoiceConnectionStatus,\n  createAudioPlayer,\n  createAudioResource,\n  entersState,\n  getVoiceConnections,\n  joinVoiceChannel,\n} from '@discordjs/voice';\nimport {\n  ChannelType,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  ModelType,\n  type UUID,\n  createUniqueUuid,\n  getWavHeader,\n  logger,\n} from '@elizaos/core';\nimport {\n  type BaseGuildVoiceChannel,\n  type Channel,\n  type Client,\n  ChannelType as DiscordChannelType,\n  type Guild,\n  type GuildMember,\n  type VoiceChannel,\n  type VoiceState,\n} from 'discord.js';\nimport prism from 'prism-media';\nimport type { DiscordService } from './service';\n\n// These values are chosen for compatibility with picovoice components\nconst DECODE_FRAME_SIZE = 1024;\nconst DECODE_SAMPLE_RATE = 16000;\n\n/**\n * Class representing an AudioMonitor that listens for audio data from a Readable stream.\n */\nexport class AudioMonitor {\n  private readable: Readable;\n  private buffers: Buffer[] = [];\n  private maxSize: number;\n  private lastFlagged = -1;\n  private ended = false;\n\n  /**\n   * Constructs an AudioMonitor instance.\n   * @param {Readable} readable - The readable stream to monitor for audio data.\n   * @param {number} maxSize - The maximum size of the audio buffer.\n   * @param {function} onStart - The callback function to be called when audio starts.\n   * @param {function} callback - The callback function to process audio data.\n   */\n  constructor(\n    readable: Readable,\n    maxSize: number,\n    onStart: () => void,\n    callback: (buffer: Buffer) => void\n  ) {\n    this.readable = readable;\n    this.maxSize = maxSize;\n    this.readable.on('data', (chunk: Buffer) => {\n      if (this.lastFlagged < 0) {\n        this.lastFlagged = this.buffers.length;\n      }\n      this.buffers.push(chunk);\n      const currentSize = this.buffers.reduce((acc, cur) => acc + cur.length, 0);\n      while (currentSize > this.maxSize) {\n        this.buffers.shift();\n        this.lastFlagged--;\n      }\n    });\n    this.readable.on('end', () => {\n      logger.log('AudioMonitor ended');\n      this.ended = true;\n      if (this.lastFlagged < 0) return;\n      callback(this.getBufferFromStart());\n      this.lastFlagged = -1;\n    });\n    this.readable.on('speakingStopped', () => {\n      if (this.ended) return;\n      logger.log('Speaking stopped');\n      if (this.lastFlagged < 0) return;\n      callback(this.getBufferFromStart());\n    });\n    this.readable.on('speakingStarted', () => {\n      if (this.ended) return;\n      onStart();\n      logger.log('Speaking started');\n      this.reset();\n    });\n  }\n\n  /**\n   * Stops listening to \"data\", \"end\", \"speakingStopped\", and \"speakingStarted\" events on the readable stream.\n   */\n  stop() {\n    this.readable.removeAllListeners('data');\n    this.readable.removeAllListeners('end');\n    this.readable.removeAllListeners('speakingStopped');\n    this.readable.removeAllListeners('speakingStarted');\n  }\n\n  /**\n   * Check if the item is flagged.\n   * @returns {boolean} True if the item was flagged, false otherwise.\n   */\n  isFlagged() {\n    return this.lastFlagged >= 0;\n  }\n\n  /**\n   * Returns a Buffer containing all buffers starting from the last flagged index.\n   * If the last flagged index is less than 0, returns null.\n   *\n   * @returns {Buffer | null} The concatenated Buffer or null\n   */\n  getBufferFromFlag() {\n    if (this.lastFlagged < 0) {\n      return null;\n    }\n    const buffer = Buffer.concat(this.buffers.slice(this.lastFlagged));\n    return buffer;\n  }\n\n  /**\n   * Concatenates all buffers in the array and returns a single buffer.\n   *\n   * @returns {Buffer} The concatenated buffer from the start.\n   */\n  getBufferFromStart() {\n    const buffer = Buffer.concat(this.buffers);\n    return buffer;\n  }\n\n  /**\n   * Resets the buffers array and sets lastFlagged to -1.\n   */\n  reset() {\n    this.buffers = [];\n    this.lastFlagged = -1;\n  }\n\n  /**\n   * Check if the object has ended.\n   * @returns {boolean} Returns true if the object has ended; false otherwise.\n   */\n  isEnded() {\n    return this.ended;\n  }\n}\n\n/**\n * Class representing a VoiceManager that extends EventEmitter.\n * @extends EventEmitter\n */\nexport class VoiceManager extends EventEmitter {\n  private processingVoice = false;\n  private transcriptionTimeout: NodeJS.Timeout | null = null;\n  private userStates: Map<\n    string,\n    {\n      buffers: Buffer[];\n      totalLength: number;\n      lastActive: number;\n      transcriptionText: string;\n    }\n  > = new Map();\n  private activeAudioPlayer: AudioPlayer | null = null;\n  private client: Client;\n  private runtime: IAgentRuntime;\n  private streams: Map<string, Readable> = new Map();\n  private connections: Map<string, VoiceConnection> = new Map();\n  private activeMonitors: Map<string, { channel: BaseGuildVoiceChannel; monitor: AudioMonitor }> =\n    new Map();\n  private ready: boolean;\n\n  /**\n   * Constructor for initializing a new instance of the class.\n   *\n   * @param {DiscordService} service - The Discord service to use.\n   * @param {IAgentRuntime} runtime - The runtime for the agent.\n   */\n  constructor(service: DiscordService, runtime: IAgentRuntime) {\n    super();\n    this.client = service.client;\n    this.runtime = runtime;\n\n    this.client.on('voiceManagerReady', () => {\n      this.setReady(true);\n    });\n  }\n\n  /**\n   * Asynchronously retrieves the type of the channel.\n   * @param {Channel} channel - The channel to get the type for.\n   * @returns {Promise<ChannelType>} The type of the channel.\n   */\n  async getChannelType(channel: Channel): Promise<ChannelType> {\n    switch (channel.type) {\n      case DiscordChannelType.GuildVoice:\n      case DiscordChannelType.GuildStageVoice:\n        return ChannelType.VOICE_GROUP;\n    }\n  }\n\n  /**\n   * Set the ready status of the VoiceManager.\n   * @param {boolean} status - The status to set.\n   */\n  private setReady(status: boolean) {\n    this.ready = status;\n    this.emit('ready');\n    logger.debug(`VoiceManager is now ready: ${this.ready}`);\n  }\n\n  /**\n   * Check if the object is ready.\n   *\n   * @returns {boolean} True if the object is ready, false otherwise.\n   */\n  isReady() {\n    return this.ready;\n  }\n\n  /**\n   * Handle voice state update event.\n   * @param {VoiceState} oldState - The old voice state of the member.\n   * @param {VoiceState} newState - The new voice state of the member.\n   * @returns {void}\n   */\n  async handleVoiceStateUpdate(oldState: VoiceState, newState: VoiceState) {\n    const oldChannelId = oldState.channelId;\n    const newChannelId = newState.channelId;\n    const member = newState.member;\n    if (!member) return;\n    if (member.id === this.client.user?.id) {\n      return;\n    }\n\n    // Ignore mute/unmute events\n    if (oldChannelId === newChannelId) {\n      return;\n    }\n\n    // User leaving a channel where the bot is present\n    if (oldChannelId && this.connections.has(oldChannelId)) {\n      this.stopMonitoringMember(member.id);\n    }\n\n    // User joining a channel where the bot is present\n    if (newChannelId && this.connections.has(newChannelId)) {\n      await this.monitorMember(member, newState.channel as BaseGuildVoiceChannel);\n    }\n  }\n\n  /**\n   * Joins a voice channel and sets up the necessary connection and event listeners.\n   * @param {BaseGuildVoiceChannel} channel - The voice channel to join\n   */\n  async joinChannel(channel: BaseGuildVoiceChannel) {\n    const oldConnection = this.getVoiceConnection(channel.guildId as string);\n    if (oldConnection) {\n      try {\n        oldConnection.destroy();\n        // Remove all associated streams and monitors\n        this.streams.clear();\n        this.activeMonitors.clear();\n      } catch (error) {\n        console.error('Error leaving voice channel:', error);\n      }\n    }\n\n    const connection = joinVoiceChannel({\n      channelId: channel.id,\n      guildId: channel.guild.id,\n      adapterCreator: channel.guild.voiceAdapterCreator as any,\n      selfDeaf: false,\n      selfMute: false,\n      group: this.client.user.id,\n    });\n\n    try {\n      // Wait for either Ready or Signalling state\n      await Promise.race([\n        entersState(connection, VoiceConnectionStatus.Ready, 20_000),\n        entersState(connection, VoiceConnectionStatus.Signalling, 20_000),\n      ]);\n\n      // Log connection success\n      logger.log(`Voice connection established in state: ${connection.state.status}`);\n\n      // Set up ongoing state change monitoring\n      connection.on('stateChange', async (oldState, newState) => {\n        logger.log(`Voice connection state changed from ${oldState.status} to ${newState.status}`);\n\n        if (newState.status === VoiceConnectionStatus.Disconnected) {\n          logger.log('Handling disconnection...');\n\n          try {\n            // Try to reconnect if disconnected\n            await Promise.race([\n              entersState(connection, VoiceConnectionStatus.Signalling, 5_000),\n              entersState(connection, VoiceConnectionStatus.Connecting, 5_000),\n            ]);\n            // Seems to be reconnecting to a new channel\n            logger.log('Reconnecting to channel...');\n          } catch (e) {\n            // Seems to be a real disconnect, destroy and cleanup\n            logger.log(`Disconnection confirmed - cleaning up...${e}`);\n            connection.destroy();\n            this.connections.delete(channel.id);\n          }\n        } else if (newState.status === VoiceConnectionStatus.Destroyed) {\n          this.connections.delete(channel.id);\n        } else if (\n          !this.connections.has(channel.id) &&\n          (newState.status === VoiceConnectionStatus.Ready ||\n            newState.status === VoiceConnectionStatus.Signalling)\n        ) {\n          this.connections.set(channel.id, connection);\n        }\n      });\n\n      connection.on('error', (error) => {\n        logger.log('Voice connection error:', error);\n        // Don't immediately destroy - let the state change handler deal with it\n        logger.log('Connection error - will attempt to recover...');\n      });\n\n      // Store the connection\n      this.connections.set(channel.id, connection);\n\n      // Continue with voice state modifications\n      const me = channel.guild.members.me;\n      if (me?.voice && me.permissions.has('DeafenMembers')) {\n        try {\n          await me.voice.setDeaf(false);\n          await me.voice.setMute(false);\n        } catch (error) {\n          logger.log('Failed to modify voice state:', error);\n          // Continue even if this fails\n        }\n      }\n\n      connection.receiver.speaking.on('start', async (entityId: string) => {\n        let user = channel.members.get(entityId);\n        if (!user) {\n          try {\n            user = await channel.guild.members.fetch(entityId);\n          } catch (error) {\n            console.error('Failed to fetch user:', error);\n          }\n        }\n        if (user && !user?.user.bot) {\n          this.monitorMember(user as GuildMember, channel);\n          this.streams.get(entityId)?.emit('speakingStarted');\n        }\n      });\n\n      connection.receiver.speaking.on('end', async (entityId: string) => {\n        const user = channel.members.get(entityId);\n        if (!user?.user.bot) {\n          this.streams.get(entityId)?.emit('speakingStopped');\n        }\n      });\n    } catch (error) {\n      logger.log('Failed to establish voice connection:', error);\n      connection.destroy();\n      this.connections.delete(channel.id);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieves the voice connection for a given guild ID.\n   * @param {string} guildId - The ID of the guild to get the voice connection for.\n   * @returns {VoiceConnection | undefined} The voice connection for the specified guild ID, or undefined if not found.\n   */\n  getVoiceConnection(guildId: string) {\n    const connections = getVoiceConnections(this.client.user.id);\n    if (!connections) {\n      return;\n    }\n    const connection = [...connections.values()].find(\n      (connection) => connection.joinConfig.guildId === guildId\n    );\n    return connection;\n  }\n\n  /**\n   * Monitor a member's audio stream for volume activity and speaking thresholds.\n   *\n   * @param {GuildMember} member - The member whose audio stream is being monitored.\n   * @param {BaseGuildVoiceChannel} channel - The voice channel in which the member is connected.\n   */\n  private async monitorMember(member: GuildMember, channel: BaseGuildVoiceChannel) {\n    const entityId = member?.id;\n    const userName = member?.user?.username;\n    const name = member?.user?.displayName;\n    const connection = this.getVoiceConnection(member?.guild?.id);\n    const receiveStream = connection?.receiver.subscribe(entityId, {\n      autoDestroy: true,\n      emitClose: true,\n    });\n    if (!receiveStream || receiveStream.readableLength === 0) {\n      return;\n    }\n    const opusDecoder = new prism.opus.Decoder({\n      channels: 1,\n      rate: DECODE_SAMPLE_RATE,\n      frameSize: DECODE_FRAME_SIZE,\n    });\n    const volumeBuffer: number[] = [];\n    const VOLUME_WINDOW_SIZE = 30;\n    const SPEAKING_THRESHOLD = 0.05;\n    opusDecoder.on('data', (pcmData: Buffer) => {\n      // Monitor the audio volume while the agent is speaking.\n      // If the average volume of the user's audio exceeds the defined threshold, it indicates active speaking.\n      // When active speaking is detected, stop the agent's current audio playback to avoid overlap.\n\n      if (this.activeAudioPlayer) {\n        const samples = new Int16Array(pcmData.buffer, pcmData.byteOffset, pcmData.length / 2);\n        const maxAmplitude = Math.max(...samples.map(Math.abs)) / 32768;\n        volumeBuffer.push(maxAmplitude);\n\n        if (volumeBuffer.length > VOLUME_WINDOW_SIZE) {\n          volumeBuffer.shift();\n        }\n        const avgVolume = volumeBuffer.reduce((sum, v) => sum + v, 0) / VOLUME_WINDOW_SIZE;\n\n        if (avgVolume > SPEAKING_THRESHOLD) {\n          volumeBuffer.length = 0;\n          this.cleanupAudioPlayer(this.activeAudioPlayer);\n          this.processingVoice = false;\n        }\n      }\n    });\n    pipeline(receiveStream as AudioReceiveStream, opusDecoder as any, (err: Error | null) => {\n      if (err) {\n        logger.debug(`Opus decoding pipeline error: ${err}`);\n      }\n    });\n    this.streams.set(entityId, opusDecoder);\n    this.connections.set(entityId, connection as VoiceConnection);\n    opusDecoder.on('error', (err: any) => {\n      logger.debug(`Opus decoding error: ${err}`);\n    });\n    const errorHandler = (err: any) => {\n      logger.debug(`Opus decoding error: ${err}`);\n    };\n    const streamCloseHandler = () => {\n      logger.debug(`voice stream from ${member?.displayName} closed`);\n      this.streams.delete(entityId);\n      this.connections.delete(entityId);\n    };\n    const closeHandler = () => {\n      logger.debug(`Opus decoder for ${member?.displayName} closed`);\n      opusDecoder.removeListener('error', errorHandler);\n      opusDecoder.removeListener('close', closeHandler);\n      receiveStream?.removeListener('close', streamCloseHandler);\n    };\n    opusDecoder.on('error', errorHandler);\n    opusDecoder.on('close', closeHandler);\n    receiveStream?.on('close', streamCloseHandler);\n\n    this.client.emit('userStream', entityId, name, userName, channel, opusDecoder);\n  }\n\n  /**\n   * Leaves the specified voice channel and stops monitoring all members in that channel.\n   * If there is an active connection in the channel, it will be destroyed.\n   *\n   * @param {BaseGuildVoiceChannel} channel - The voice channel to leave.\n   */\n  leaveChannel(channel: BaseGuildVoiceChannel) {\n    const connection = this.connections.get(channel.id);\n    if (connection) {\n      connection.destroy();\n      this.connections.delete(channel.id);\n    }\n\n    // Stop monitoring all members in this channel\n    for (const [memberId, monitorInfo] of this.activeMonitors) {\n      if (monitorInfo.channel.id === channel.id && memberId !== this.client.user?.id) {\n        this.stopMonitoringMember(memberId);\n      }\n    }\n\n    logger.debug(`Left voice channel: ${channel.name} (${channel.id})`);\n  }\n\n  /**\n   * Stop monitoring a specific member by their member ID.\n   * @param {string} memberId - The ID of the member to stop monitoring.\n   */\n  stopMonitoringMember(memberId: string) {\n    const monitorInfo = this.activeMonitors.get(memberId);\n    if (monitorInfo) {\n      monitorInfo.monitor.stop();\n      this.activeMonitors.delete(memberId);\n      this.streams.delete(memberId);\n      logger.debug(`Stopped monitoring user ${memberId}`);\n    }\n  }\n\n  /**\n   * Asynchronously debounces the process transcription function to prevent rapid execution.\n   *\n   * @param {UUID} entityId - The ID of the entity related to the transcription.\n   * @param {string} name - The name of the entity for transcription.\n   * @param {string} userName - The username of the user initiating the transcription.\n   * @param {BaseGuildVoiceChannel} channel - The voice channel where the transcription is happening.\n   */\n\n  async debouncedProcessTranscription(\n    entityId: UUID,\n    name: string,\n    userName: string,\n    channel: BaseGuildVoiceChannel\n  ) {\n    const DEBOUNCE_TRANSCRIPTION_THRESHOLD = 1500; // wait for 1.5 seconds of silence\n\n    if (this.activeAudioPlayer?.state?.status === 'idle') {\n      logger.log('Cleaning up idle audio player.');\n      this.cleanupAudioPlayer(this.activeAudioPlayer);\n    }\n\n    if (this.activeAudioPlayer || this.processingVoice) {\n      const state = this.userStates.get(entityId);\n      state.buffers.length = 0;\n      state.totalLength = 0;\n      return;\n    }\n\n    if (this.transcriptionTimeout) {\n      clearTimeout(this.transcriptionTimeout);\n    }\n\n    this.transcriptionTimeout = setTimeout(async () => {\n      this.processingVoice = true;\n      try {\n        await this.processTranscription(entityId, channel.id, channel, name, userName);\n\n        // Clean all users' previous buffers\n        this.userStates.forEach((state, _) => {\n          state.buffers.length = 0;\n          state.totalLength = 0;\n        });\n      } finally {\n        this.processingVoice = false;\n      }\n    }, DEBOUNCE_TRANSCRIPTION_THRESHOLD) as unknown as NodeJS.Timeout;\n  }\n\n  /**\n   * Handle user audio stream for monitoring purposes.\n   *\n   * @param {UUID} userId - The unique identifier of the user.\n   * @param {string} name - The name of the user.\n   * @param {string} userName - The username of the user.\n   * @param {BaseGuildVoiceChannel} channel - The voice channel the user is in.\n   * @param {Readable} audioStream - The audio stream to monitor.\n   */\n  async handleUserStream(\n    entityId: UUID,\n    name: string,\n    userName: string,\n    channel: BaseGuildVoiceChannel,\n    audioStream: Readable\n  ) {\n    logger.debug(`Starting audio monitor for user: ${entityId}`);\n    if (!this.userStates.has(entityId)) {\n      this.userStates.set(entityId, {\n        buffers: [],\n        totalLength: 0,\n        lastActive: Date.now(),\n        transcriptionText: '',\n      });\n    }\n\n    const state = this.userStates.get(entityId);\n\n    const processBuffer = async (buffer: Buffer) => {\n      try {\n        state?.buffers.push(buffer);\n        state!.totalLength += buffer.length;\n        state!.lastActive = Date.now();\n        this.debouncedProcessTranscription(entityId, name, userName, channel);\n      } catch (error) {\n        console.error(`Error processing buffer for user ${entityId}:`, error);\n      }\n    };\n\n    new AudioMonitor(\n      audioStream,\n      10000000,\n      () => {\n        if (this.transcriptionTimeout) {\n          clearTimeout(this.transcriptionTimeout);\n        }\n      },\n      async (buffer) => {\n        if (!buffer) {\n          console.error('Received empty buffer');\n          return;\n        }\n        await processBuffer(buffer);\n      }\n    );\n  }\n\n  /**\n   * Process the transcription of audio data for a user.\n   *\n   * @param {UUID} entityId - The unique ID of the user entity.\n   * @param {string} channelId - The ID of the channel where the transcription is taking place.\n   * @param {BaseGuildVoiceChannel} channel - The voice channel where the user is speaking.\n   * @param {string} name - The name of the user.\n   * @param {string} userName - The username of the user.\n   * @returns {Promise<void>}\n   */\n  private async processTranscription(\n    entityId: UUID,\n    channelId: string,\n    channel: BaseGuildVoiceChannel,\n    name: string,\n    userName: string\n  ) {\n    const state = this.userStates.get(entityId);\n    if (!state || state.buffers.length === 0) return;\n    try {\n      const inputBuffer = Buffer.concat(state.buffers, state.totalLength);\n\n      state.buffers.length = 0; // Clear the buffers\n      state.totalLength = 0;\n      // Convert Opus to WAV\n      const wavBuffer = await this.convertOpusToWav(inputBuffer);\n      logger.debug('Starting transcription...');\n\n      const transcriptionText = await this.runtime.useModel(ModelType.TRANSCRIPTION, wavBuffer);\n      function isValidTranscription(text: string): boolean {\n        if (!text || text.includes('[BLANK_AUDIO]')) return false;\n        return true;\n      }\n\n      if (transcriptionText && isValidTranscription(transcriptionText)) {\n        state.transcriptionText += transcriptionText;\n      }\n\n      if (state.transcriptionText.length) {\n        this.cleanupAudioPlayer(this.activeAudioPlayer);\n        const finalText = state.transcriptionText;\n        state.transcriptionText = '';\n        await this.handleMessage(finalText, entityId, channelId, channel, name, userName);\n      }\n    } catch (error) {\n      console.error(`Error transcribing audio for user ${entityId}:`, error);\n    }\n  }\n\n  /**\n   * Handles a voice message received in a Discord channel.\n   *\n   * @param {string} message - The message content.\n   * @param {UUID} entityId - The entity ID associated with the message.\n   * @param {string} channelId - The ID of the Discord channel where the message was received.\n   * @param {BaseGuildVoiceChannel} channel - The Discord channel where the message was received.\n   * @param {string} name - The name associated with the message.\n   * @param {string} userName - The user name associated with the message.\n   * @returns {Promise<{text: string, actions: string[]}>} Object containing the resulting text and actions.\n   */\n  private async handleMessage(\n    message: string,\n    entityId: UUID,\n    channelId: string,\n    channel: BaseGuildVoiceChannel,\n    name: string,\n    userName: string\n  ) {\n    try {\n      if (!message || message.trim() === '' || message.length < 3) {\n        return { text: '', actions: ['IGNORE'] };\n      }\n\n      const roomId = createUniqueUuid(this.runtime, channelId);\n      const uniqueEntityId = createUniqueUuid(this.runtime, entityId);\n      const type = await this.getChannelType(channel as Channel);\n\n      await this.runtime.ensureConnection({\n        entityId: uniqueEntityId,\n        roomId,\n        userName,\n        name: name,\n        source: 'discord',\n        channelId,\n        serverId: channel.guild.id,\n        type,\n      });\n\n      const memory: Memory = {\n        id: createUniqueUuid(this.runtime, `${channelId}-voice-message-${Date.now()}`),\n        agentId: this.runtime.agentId,\n        entityId: uniqueEntityId,\n        roomId,\n        content: {\n          text: message,\n          source: 'discord',\n          url: channel.url,\n          name: name,\n          userName: userName,\n          isVoiceMessage: true,\n          channelType: type,\n        },\n        createdAt: Date.now(),\n      };\n\n      const callback: HandlerCallback = async (content: Content, _files: any[] = []) => {\n        try {\n          const responseMemory: Memory = {\n            id: createUniqueUuid(this.runtime, `${memory.id}-voice-response-${Date.now()}`),\n            entityId: this.runtime.agentId,\n            agentId: this.runtime.agentId,\n            content: {\n              ...content,\n              name: this.runtime.character.name,\n              inReplyTo: memory.id,\n              isVoiceMessage: true,\n              channelType: type,\n            },\n            roomId,\n            createdAt: Date.now(),\n          };\n\n          if (responseMemory.content.text?.trim()) {\n            await this.runtime.createMemory(responseMemory, 'messages');\n\n            const responseStream = await this.runtime.useModel(\n              ModelType.TEXT_TO_SPEECH,\n              content.text\n            );\n            if (responseStream) {\n              await this.playAudioStream(entityId, responseStream as Readable);\n            }\n          }\n\n          return [responseMemory];\n        } catch (error) {\n          console.error('Error in voice message callback:', error);\n          return [];\n        }\n      };\n\n      // Emit voice-specific events\n      this.runtime.emitEvent(['DISCORD_VOICE_MESSAGE_RECEIVED', 'VOICE_MESSAGE_RECEIVED'], {\n        runtime: this.runtime,\n        message: memory,\n        callback,\n      });\n    } catch (error) {\n      console.error('Error processing voice message:', error);\n    }\n  }\n\n  /**\n   * Asynchronously converts an Opus audio Buffer to a WAV audio Buffer.\n   *\n   * @param {Buffer} pcmBuffer - The Opus audio Buffer to convert to WAV.\n   * @returns {Promise<Buffer>} A Promise that resolves with the converted WAV audio Buffer.\n   */\n  private async convertOpusToWav(pcmBuffer: Buffer): Promise<Buffer> {\n    try {\n      // Generate the WAV header\n      const wavHeader = getWavHeader(pcmBuffer.length, DECODE_SAMPLE_RATE);\n\n      // Concatenate the WAV header and PCM data\n      const wavBuffer = Buffer.concat([wavHeader, pcmBuffer]);\n\n      return wavBuffer;\n    } catch (error) {\n      console.error('Error converting PCM to WAV:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Scans the given Discord guild to select a suitable voice channel to join.\n   *\n   * @param {Guild} guild The Discord guild to scan for voice channels.\n   */\n  async scanGuild(guild: Guild) {\n    let chosenChannel: BaseGuildVoiceChannel | null = null;\n\n    try {\n      const channelId = this.runtime.getSetting('DISCORD_VOICE_CHANNEL_ID') as string;\n      if (channelId) {\n        const channel = await guild.channels.fetch(channelId);\n        if (channel?.isVoiceBased()) {\n          chosenChannel = channel as BaseGuildVoiceChannel;\n        }\n      }\n\n      if (!chosenChannel) {\n        const channels = (await guild.channels.fetch()).filter(\n          (channel) => channel?.type === DiscordChannelType.GuildVoice\n        );\n        for (const [, channel] of channels) {\n          const voiceChannel = channel as BaseGuildVoiceChannel;\n          if (\n            voiceChannel.members.size > 0 &&\n            (chosenChannel === null || voiceChannel.members.size > chosenChannel.members.size)\n          ) {\n            chosenChannel = voiceChannel;\n          }\n        }\n      }\n\n      if (chosenChannel) {\n        logger.debug(`Joining channel: ${chosenChannel.name}`);\n        await this.joinChannel(chosenChannel);\n      } else {\n        logger.debug('Warning: No suitable voice channel found to join.');\n      }\n    } catch (error) {\n      console.error('Error selecting or joining a voice channel:', error);\n    }\n  }\n\n  /**\n   * Play an audio stream for a given entity ID.\n   *\n   * @param {UUID} entityId - The ID of the entity to play the audio for.\n   * @param {Readable} audioStream - The audio stream to play.\n   * @returns {void}\n   */\n  async playAudioStream(entityId: UUID, audioStream: Readable) {\n    const connection = this.connections.get(entityId);\n    if (connection == null) {\n      logger.debug(`No connection for user ${entityId}`);\n      return;\n    }\n    this.cleanupAudioPlayer(this.activeAudioPlayer);\n    const audioPlayer = createAudioPlayer({\n      behaviors: {\n        noSubscriber: NoSubscriberBehavior.Pause,\n      },\n    });\n    this.activeAudioPlayer = audioPlayer;\n    connection.subscribe(audioPlayer);\n\n    const audioStartTime = Date.now();\n\n    const resource = createAudioResource(audioStream, {\n      inputType: StreamType.Arbitrary,\n    });\n    audioPlayer.play(resource);\n\n    audioPlayer.on('error', (err: any) => {\n      logger.debug(`Audio player error: ${err}`);\n    });\n\n    audioPlayer.on('stateChange', (_oldState: any, newState: { status: string }) => {\n      if (newState.status === 'idle') {\n        const idleTime = Date.now();\n        logger.debug(`Audio playback took: ${idleTime - audioStartTime}ms`);\n      }\n    });\n  }\n\n  /**\n   * Cleans up the provided audio player by stopping it, removing all listeners,\n   * and resetting the active audio player if it matches the provided player.\n   *\n   * @param {AudioPlayer} audioPlayer - The audio player to be cleaned up.\n   */\n  cleanupAudioPlayer(audioPlayer: AudioPlayer) {\n    if (!audioPlayer) return;\n\n    audioPlayer.stop();\n    audioPlayer.removeAllListeners();\n    if (audioPlayer === this.activeAudioPlayer) {\n      this.activeAudioPlayer = null;\n    }\n  }\n\n  /**\n   * Asynchronously handles the join channel command in an interaction.\n   *\n   * @param {any} interaction - The interaction object representing the user's input.\n   * @returns {Promise<void>} - A promise that resolves once the join channel command is handled.\n   */\n  async handleJoinChannelCommand(interaction: any) {\n    try {\n      // Defer the reply immediately to prevent interaction timeout\n      await interaction.deferReply();\n\n      const channelId = interaction.options.get('channel')?.value as string;\n      if (!channelId) {\n        await interaction.editReply('Please provide a voice channel to join.');\n        return;\n      }\n\n      const guild = interaction.guild;\n      if (!guild) {\n        await interaction.editReply('Could not find guild.');\n        return;\n      }\n\n      const voiceChannel = interaction.guild.channels.cache.find(\n        (channel: VoiceChannel) =>\n          channel.id === channelId && channel.type === DiscordChannelType.GuildVoice\n      );\n\n      if (!voiceChannel) {\n        await interaction.editReply('Voice channel not found!');\n        return;\n      }\n\n      await this.joinChannel(voiceChannel as BaseGuildVoiceChannel);\n      await interaction.editReply(`Joined voice channel: ${voiceChannel.name}`);\n    } catch (error) {\n      console.error('Error joining voice channel:', error);\n      // Use editReply instead of reply for the error case\n      await interaction.editReply('Failed to join the voice channel.').catch(console.error);\n    }\n  }\n\n  /**\n   * Handles the leave channel command by destroying the voice connection if it exists.\n   *\n   * @param {any} interaction The interaction object representing the command invocation.\n   * @returns {void}\n   */\n  async handleLeaveChannelCommand(interaction: any) {\n    const connection = this.getVoiceConnection(interaction.guildId as any);\n\n    if (!connection) {\n      await interaction.reply('Not currently in a voice channel.');\n      return;\n    }\n\n    try {\n      connection.destroy();\n      await interaction.reply('Left the voice channel.');\n    } catch (error) {\n      console.error('Error leaving voice channel:', error);\n      await interaction.reply('Failed to leave the voice channel.');\n    }\n  }\n}\n","import {\n  AudioPlayerStatus,\n  NoSubscriberBehavior,\n  type VoiceConnection,\n  VoiceConnectionStatus,\n  createAudioPlayer,\n  createAudioResource,\n  entersState,\n} from '@discordjs/voice';\nimport { type IAgentRuntime, ModelType, type TestSuite, logger } from '@elizaos/core';\nimport { ChannelType, Events, type TextChannel } from 'discord.js';\nimport type { DiscordService } from './service';\nimport { ServiceType } from './types';\nimport { sendMessageInChunks } from './utils';\n\nconst TEST_IMAGE_URL =\n  'https://github.com/elizaOS/awesome-eliza/blob/main/assets/eliza-logo.jpg?raw=true';\n\n/**\n * Represents a test suite for Discord functionality.\n * @class DiscordTestSuite\n * @implements TestSuite\n * @property {string} name - The name of the test suite\n * @property {DiscordService | null} discordClient - The Discord client instance\n * @property {Array<{ name: string; fn: (runtime: IAgentRuntime) => Promise<void> }>} tests - Array of test functions\n */\nexport class DiscordTestSuite implements TestSuite {\n  name = 'discord';\n  private discordClient: DiscordService | null = null;\n  tests: { name: string; fn: (runtime: IAgentRuntime) => Promise<void> }[];\n\n  /**\n   * Constructor for initializing the tests array with test cases to be executed.\n   *\n   * @constructor\n   * @this {TestSuite}\n   */\n  constructor() {\n    this.tests = [\n      {\n        name: 'Initialize Discord Client',\n        fn: this.testCreatingDiscordClient.bind(this),\n      },\n      {\n        name: 'Slash Commands - Join Voice',\n        fn: this.testJoinVoiceSlashCommand.bind(this),\n      },\n      {\n        name: 'Voice Playback & TTS',\n        fn: this.testTextToSpeechPlayback.bind(this),\n      },\n      {\n        name: 'Send Message with Attachments',\n        fn: this.testSendingTextMessage.bind(this),\n      },\n      {\n        name: 'Handle Incoming Messages',\n        fn: this.testHandlingMessage.bind(this),\n      },\n      {\n        name: 'Slash Commands - Leave Voice',\n        fn: this.testLeaveVoiceSlashCommand.bind(this),\n      },\n    ];\n  }\n\n  /**\n   * Asynchronously tests the creation of Discord client using the provided runtime.\n   *\n   * @param {IAgentRuntime} runtime - The agent runtime used to obtain the Discord service.\n   * @returns {Promise<void>} - A Promise that resolves once the Discord client is ready.\n   * @throws {Error} - If an error occurs while creating the Discord client.\n   */\n  async testCreatingDiscordClient(runtime: IAgentRuntime) {\n    try {\n      this.discordClient = runtime.getService(ServiceType.DISCORD) as DiscordService;\n\n      // Wait for the bot to be ready before proceeding\n      if (this.discordClient.client.isReady()) {\n        logger.success('DiscordService is already ready.');\n      } else {\n        logger.info('Waiting for DiscordService to be ready...');\n        await new Promise((resolve, reject) => {\n          this.discordClient.client.once(Events.ClientReady, resolve);\n          this.discordClient.client.once(Events.Error, reject);\n        });\n      }\n    } catch (error) {\n      throw new Error(`Error in test creating Discord client: ${error}`);\n    }\n  }\n\n  /**\n   * Asynchronously tests the join voice slash command functionality.\n   *\n   * @param {IAgentRuntime} runtime - The runtime environment for the agent.\n   * @returns {Promise<void>} - A promise that resolves once the test is complete.\n   * @throws {Error} - If there is an error in executing the slash command test.\n   */\n  async testJoinVoiceSlashCommand(runtime: IAgentRuntime) {\n    try {\n      await this.waitForVoiceManagerReady(this.discordClient);\n\n      const channel = await this.getTestChannel(runtime);\n      if (!channel || !channel.isTextBased()) {\n        throw new Error('Invalid test channel for slash command test.');\n      }\n\n      // Simulate a join channel slash command interaction\n      const fakeJoinInteraction = {\n        isCommand: () => true,\n        commandName: 'joinchannel',\n        options: {\n          get: (name: string) => (name === 'channel' ? { value: channel.id } : null),\n        },\n        guild: (channel as TextChannel).guild,\n        deferReply: async () => {},\n        editReply: async (message: string) => {\n          logger.info(`JoinChannel Slash Command Response: ${message}`);\n        },\n      };\n\n      await this.discordClient.voiceManager.handleJoinChannelCommand(fakeJoinInteraction as any);\n\n      logger.success('Slash command test completed successfully.');\n    } catch (error) {\n      throw new Error(`Error in slash commands test: ${error}`);\n    }\n  }\n\n  /**\n   * Asynchronously tests the leave voice channel slash command.\n   *\n   * @param {IAgentRuntime} runtime - The Agent Runtime instance.\n   * @returns {Promise<void>} A promise that resolves when the test is complete.\n   */\n  async testLeaveVoiceSlashCommand(runtime: IAgentRuntime) {\n    try {\n      await this.waitForVoiceManagerReady(this.discordClient);\n\n      const channel = await this.getTestChannel(runtime);\n      if (!channel || !channel.isTextBased()) {\n        throw new Error('Invalid test channel for slash command test.');\n      }\n\n      // Simulate a leave channel slash command interaction\n      const fakeLeaveInteraction = {\n        isCommand: () => true,\n        commandName: 'leavechannel',\n        guildId: (channel as TextChannel).guildId,\n        reply: async (message: string) => {\n          logger.info(`LeaveChannel Slash Command Response: ${message}`);\n        },\n      };\n\n      await this.discordClient.voiceManager.handleLeaveChannelCommand(fakeLeaveInteraction as any);\n\n      logger.success('Slash command test completed successfully.');\n    } catch (error) {\n      throw new Error(`Error in slash commands test: ${error}`);\n    }\n  }\n\n  /**\n   * Test Text to Speech playback.\n   * @param {IAgentRuntime} runtime - The Agent Runtime instance.\n   * @throws {Error} - If voice channel is invalid, voice connection fails to become ready, or no text to speech service found.\n   */\n  async testTextToSpeechPlayback(runtime: IAgentRuntime) {\n    try {\n      await this.waitForVoiceManagerReady(this.discordClient);\n\n      const channel = await this.getTestChannel(runtime);\n      if (!channel || channel.type !== ChannelType.GuildVoice) {\n        throw new Error('Invalid voice channel.');\n      }\n\n      await this.discordClient.voiceManager.joinChannel(channel);\n\n      const guild = await this.getActiveGuild(this.discordClient);\n      const guildId = guild.id;\n      const connection = this.discordClient.voiceManager.getVoiceConnection(guildId);\n\n      try {\n        await entersState(connection, VoiceConnectionStatus.Ready, 10_000);\n        logger.success(`Voice connection is ready in guild: ${guildId}`);\n      } catch (error) {\n        throw new Error(`Voice connection failed to become ready: ${error}`);\n      }\n\n      let responseStream = null;\n\n      try {\n        responseStream = await runtime.useModel(\n          ModelType.TEXT_TO_SPEECH,\n          `Hi! I'm ${runtime.character.name}! How are you doing today?`\n        );\n      } catch (_error) {\n        throw new Error('No text to speech service found');\n      }\n\n      if (!responseStream) {\n        throw new Error('TTS response stream is null or undefined.');\n      }\n\n      await this.playAudioStream(responseStream, connection);\n    } catch (error) {\n      throw new Error(`Error in TTS playback test: ${error}`);\n    }\n  }\n\n  /**\n   * Asynchronously tests sending a text message to a specified channel.\n   *\n   * @param {IAgentRuntime} runtime - The runtime for the agent.\n   * @returns {Promise<void>} A Promise that resolves when the message is sent successfully.\n   * @throws {Error} If there is an error in sending the text message.\n   */\n  async testSendingTextMessage(runtime: IAgentRuntime) {\n    try {\n      const channel = await this.getTestChannel(runtime);\n\n      await this.sendMessageToChannel(channel as TextChannel, 'Testing Message', [TEST_IMAGE_URL]);\n    } catch (error) {\n      throw new Error(`Error in sending text message: ${error}`);\n    }\n  }\n\n  /**\n   * Asynchronously handles sending a test message using the given runtime and mock user data.\n   *\n   * @param {IAgentRuntime} runtime - The agent runtime object.\n   * @returns {Promise<void>} A Promise that resolves once the message is handled.\n   */\n  async testHandlingMessage(runtime: IAgentRuntime) {\n    try {\n      const channel = await this.getTestChannel(runtime);\n\n      const fakeMessage = {\n        content: `Hello, ${runtime.character.name}! How are you?`,\n        author: {\n          id: 'mock-user-id',\n          username: 'MockUser',\n          bot: false,\n        },\n        channel,\n        id: 'mock-message-id',\n        createdTimestamp: Date.now(),\n        mentions: {\n          has: () => false,\n        },\n        reference: null,\n        attachments: [],\n      };\n      await this.discordClient.messageManager.handleMessage(fakeMessage as any);\n    } catch (error) {\n      throw new Error(`Error in sending text message: ${error}`);\n    }\n  }\n\n  // #############################\n  //     Utility Functions\n  // #############################\n\n  /**\n   * Asynchronously retrieves the test channel associated with the provided runtime.\n   *\n   * @param {IAgentRuntime} runtime - The runtime object containing necessary information.\n   * @returns {Promise<Channel>} The test channel retrieved from the Discord client.\n   * @throws {Error} If no test channel is found.\n   */\n  async getTestChannel(runtime: IAgentRuntime) {\n    const channelId = this.validateChannelId(runtime);\n    const channel = await this.discordClient.client.channels.fetch(channelId);\n\n    if (!channel) throw new Error('no test channel found!');\n\n    return channel;\n  }\n\n  /**\n   * Async function to send a message to a text-based channel.\n   *\n   * @param {TextChannel} channel - The text-based channel the message is being sent to.\n   * @param {string} messageContent - The content of the message being sent.\n   * @param {any[]} files - An array of files to include in the message.\n   * @throws {Error} If the channel is not a text-based channel or does not exist.\n   * @throws {Error} If there is an error sending the message.\n   */\n  async sendMessageToChannel(channel: TextChannel, messageContent: string, files: any[]) {\n    try {\n      if (!channel || !channel.isTextBased()) {\n        throw new Error('Channel is not a text-based channel or does not exist.');\n      }\n\n      await sendMessageInChunks(channel as TextChannel, messageContent, null, files);\n    } catch (error) {\n      throw new Error(`Error sending message: ${error}`);\n    }\n  }\n\n  /**\n   * Play an audio stream from a given response stream using the provided VoiceConnection.\n   *\n   * @param {any} responseStream - The response stream to play as audio.\n   * @param {VoiceConnection} connection - The VoiceConnection to use for playing the audio.\n   * @returns {Promise<void>} - A Promise that resolves when the TTS playback is finished.\n   */\n  async playAudioStream(responseStream: any, connection: VoiceConnection) {\n    const audioPlayer = createAudioPlayer({\n      behaviors: {\n        noSubscriber: NoSubscriberBehavior.Pause,\n      },\n    });\n\n    const audioResource = createAudioResource(responseStream);\n\n    audioPlayer.play(audioResource);\n    connection.subscribe(audioPlayer);\n\n    logger.success('TTS playback started successfully.');\n\n    await new Promise<void>((resolve, reject) => {\n      audioPlayer.once(AudioPlayerStatus.Idle, () => {\n        logger.info('TTS playback finished.');\n        resolve();\n      });\n\n      audioPlayer.once('error', (error) => {\n        reject(error);\n        throw new Error(`TTS playback error: ${error}`);\n      });\n    });\n  }\n\n  /**\n   * Retrieves the active guild where the bot is currently connected to a voice channel.\n   *\n   * @param {DiscordService} discordClient The DiscordService instance used to interact with the Discord API.\n   * @returns {Promise<Guild>} The active guild where the bot is currently connected to a voice channel.\n   * @throws {Error} If no active voice connection is found for the bot.\n   */\n  async getActiveGuild(discordClient: DiscordService) {\n    const guilds = await discordClient.client.guilds.fetch();\n    const fullGuilds = await Promise.all(guilds.map((guild) => guild.fetch())); // Fetch full guild data\n\n    const activeGuild = fullGuilds.find((g) => g.members.me?.voice.channelId);\n    if (!activeGuild) {\n      throw new Error('No active voice connection found for the bot.');\n    }\n    return activeGuild;\n  }\n\n  /**\n   * Waits for the VoiceManager in the Discord client to be ready.\n   *\n   * @param {DiscordService} discordClient - The Discord client to check for VoiceManager readiness.\n   * @throws {Error} If the Discord client is not initialized.\n   * @returns {Promise<void>} A promise that resolves when the VoiceManager is ready.\n   */\n  private async waitForVoiceManagerReady(discordClient: DiscordService) {\n    if (!discordClient) {\n      throw new Error('Discord client is not initialized.');\n    }\n\n    if (!discordClient.voiceManager.isReady()) {\n      await new Promise<void>((resolve, reject) => {\n        discordClient.voiceManager.once('ready', resolve);\n        discordClient.voiceManager.once('error', reject);\n      });\n    }\n  }\n\n  /**\n   * Validates the Discord test channel ID by checking if it is set in the runtime or environment variables.\n   * If the test channel ID is not set, an error is thrown.\n   *\n   * @param {IAgentRuntime} runtime The runtime object containing the settings and environment variables.\n   * @returns {string} The validated Discord test channel ID.\n   */\n  private validateChannelId(runtime: IAgentRuntime) {\n    const testChannelId =\n      runtime.getSetting('DISCORD_TEST_CHANNEL_ID') || process.env.DISCORD_TEST_CHANNEL_ID;\n    if (!testChannelId) {\n      throw new Error(\n        'DISCORD_TEST_CHANNEL_ID is not set. Please provide a valid channel ID in the environment variables.'\n      );\n    }\n    return testChannelId;\n  }\n}\n"],"mappings":"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","names":["logger","ModelType","composePromptFromState","parseJSONObjectFromText","fs","ModelType","composePromptFromState","parseJSONObjectFromText","trimTokens","summarizationTemplate","ModelType","composePromptFromState","parseJSONObjectFromText","composePromptFromState","ModelType","parseJSONObjectFromText","attachment","ChannelType","ModelType","composePromptFromState","createUniqueUuid","ServiceType","ChannelType","ServiceType","member","createUniqueUuid","composePromptFromState","ModelType","targetChannel","ChannelType","createUniqueUuid","logger","ServiceType","logger","ChannelType","createUniqueUuid","ChannelType","ChannelType","ServiceType","ChannelType","ChannelType","EventType","createUniqueUuid","logger","DiscordChannelType","PermissionsBitField","ChannelType","ServiceType","createUniqueUuid","logger","DiscordChannelType","fs","trimTokens","parseJSONObjectFromText","ModelType","ServiceType","ModelType","logger","parseJSONObjectFromText","trimTokens","ChannelType","logger","ChannelType","DiscordChannelType","createUniqueUuid","ChannelType","logger","entityId","match","ServiceType","ChannelType","ModelType","createUniqueUuid","logger","DiscordChannelType","connection","logger","createUniqueUuid","EventType","PermissionsBitField","DiscordChannelType","ChannelType","fullGuild","NoSubscriberBehavior","VoiceConnectionStatus","createAudioPlayer","createAudioResource","entersState","ModelType","logger","ChannelType","Events","ServiceType","logger","Events","ChannelType","entersState","VoiceConnectionStatus","ModelType","createAudioPlayer","NoSubscriberBehavior","createAudioResource","logger"]}