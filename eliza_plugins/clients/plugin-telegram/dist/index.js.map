{"version":3,"sources":["../src/constants.ts","../src/service.ts","../src/environment.ts","../src/messageManager.ts","../src/utils.ts","../src/tests.ts","../src/index.ts"],"sourcesContent":["export const MESSAGE_CONSTANTS = {\n  MAX_MESSAGES: 50,\n  RECENT_MESSAGE_COUNT: 5,\n  CHAT_HISTORY_COUNT: 10,\n  DEFAULT_SIMILARITY_THRESHOLD: 0.6,\n  DEFAULT_SIMILARITY_THRESHOLD_FOLLOW_UPS: 0.4,\n  INTEREST_DECAY_TIME: 5 * 60 * 1000, // 5 minutes\n  PARTIAL_INTEREST_DECAY: 3 * 60 * 1000, // 3 minutes\n} as const;\n\nexport const TELEGRAM_SERVICE_NAME = 'telegram';\n","import {\n  ChannelType,\n  type Entity,\n  EventType,\n  type IAgentRuntime,\n  Role,\n  type Room,\n  Service,\n  type UUID,\n  type World,\n  WorldPayload,\n  createUniqueUuid,\n  logger,\n} from '@elizaos/core';\nimport { type Context, Telegraf } from 'telegraf';\nimport { TELEGRAM_SERVICE_NAME } from './constants';\nimport { validateTelegramConfig } from './environment';\nimport { MessageManager } from './messageManager';\nimport { TelegramEventTypes, TelegramWorldPayload } from './types';\n\n/**\n * Class representing a Telegram service that allows the agent to send and receive messages on Telegram.\n * This service handles all Telegram-specific functionality including:\n * - Initializing and managing the Telegram bot\n * - Setting up middleware for preprocessing messages\n * - Handling message and reaction events\n * - Synchronizing Telegram chats, users, and entities with the agent runtime\n * - Managing forum topics as separate rooms\n *\n * @extends Service\n */\nexport class TelegramService extends Service {\n  static serviceType = TELEGRAM_SERVICE_NAME;\n  capabilityDescription = 'The agent is able to send and receive messages on telegram';\n  private bot: Telegraf<Context>;\n  public messageManager: MessageManager;\n  private options;\n  private knownChats: Map<string, any> = new Map();\n  private syncedEntityIds: Set<string> = new Set<string>();\n\n  /**\n   * Constructor for TelegramService class.\n   * @param {IAgentRuntime} runtime - The runtime object for the agent.\n   */\n  constructor(runtime: IAgentRuntime) {\n    super(runtime);\n    logger.log('üì± Constructing new TelegramService...');\n    this.options = {\n      telegram: {\n        apiRoot:\n          runtime.getSetting('TELEGRAM_API_ROOT') ||\n          process.env.TELEGRAM_API_ROOT ||\n          'https://api.telegram.org',\n      },\n    };\n    const botToken = runtime.getSetting('TELEGRAM_BOT_TOKEN');\n    this.bot = new Telegraf(botToken, this.options);\n    this.messageManager = new MessageManager(this.bot, this.runtime);\n    logger.log('‚úÖ TelegramService constructor completed');\n  }\n\n  /**\n   * Starts the Telegram service for the given runtime.\n   *\n   * @param {IAgentRuntime} runtime - The agent runtime to start the Telegram service for.\n   * @returns {Promise<TelegramService>} A promise that resolves with the initialized TelegramService.\n   */\n  static async start(runtime: IAgentRuntime): Promise<TelegramService> {\n    await validateTelegramConfig(runtime);\n\n    const maxRetries = 5;\n    let retryCount = 0;\n    let lastError: Error | null = null;\n\n    while (retryCount < maxRetries) {\n      try {\n        const service = new TelegramService(runtime);\n\n        logger.success(\n          `‚úÖ Telegram client successfully started for character ${runtime.character.name}`\n        );\n\n        logger.log('üöÄ Starting Telegram bot...');\n        await service.initializeBot();\n\n        // Set up middlewares before message handlers to ensure proper preprocessing\n        service.setupMiddlewares();\n\n        // Set up message handlers after middlewares\n        service.setupMessageHandlers();\n\n        // Wait for bot to be ready by testing getMe()\n        await service.bot.telegram.getMe();\n\n        return service;\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n        logger.error(\n          `Telegram initialization attempt ${retryCount + 1} failed: ${lastError.message}`\n        );\n        retryCount++;\n\n        if (retryCount < maxRetries) {\n          const delay = 2 ** retryCount * 1000; // Exponential backoff\n          logger.info(`Retrying Telegram initialization in ${delay / 1000} seconds...`);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n      }\n    }\n\n    throw new Error(\n      `Telegram initialization failed after ${maxRetries} attempts. Last error: ${lastError?.message}`\n    );\n  }\n\n  /**\n   * Stops the agent runtime.\n   * @param {IAgentRuntime} runtime - The agent runtime to stop\n   */\n  static async stop(runtime: IAgentRuntime) {\n    // Implement shutdown if necessary\n    const tgClient = runtime.getService(TELEGRAM_SERVICE_NAME);\n    if (tgClient) {\n      await tgClient.stop();\n    }\n  }\n\n  /**\n   * Asynchronously stops the bot.\n   *\n   * @returns A Promise that resolves once the bot has stopped.\n   */\n  async stop(): Promise<void> {\n    this.bot.stop();\n  }\n\n  /**\n   * Initializes the Telegram bot by launching it, getting bot info, and setting up message manager.\n   * @returns {Promise<void>} A Promise that resolves when the initialization is complete.\n   */\n  private async initializeBot(): Promise<void> {\n    this.bot.launch({\n      dropPendingUpdates: true,\n      allowedUpdates: ['message', 'message_reaction'],\n    });\n\n    // Get bot info for identification purposes\n    const botInfo = await this.bot.telegram.getMe();\n    logger.log(`Bot info: ${JSON.stringify(botInfo)}`);\n\n    // Handle sigint and sigterm signals to gracefully stop the bot\n    process.once('SIGINT', () => this.bot.stop('SIGINT'));\n    process.once('SIGTERM', () => this.bot.stop('SIGTERM'));\n  }\n\n  /**\n   * Sets up the middleware chain for preprocessing messages before they reach handlers.\n   * This critical method establishes a sequential processing pipeline that:\n   *\n   * 1. Authorization - Verifies if a chat is allowed to interact with the bot based on configured settings\n   * 2. Chat Discovery - Ensures chat entities and worlds exist in the runtime, creating them if needed\n   * 3. Forum Topics - Handles Telegram forum topics as separate rooms for better conversation management\n   * 4. Entity Synchronization - Ensures message senders are properly synchronized as entities\n   *\n   * The middleware chain runs in sequence for each message, with each step potentially\n   * enriching the context or stopping processing if conditions aren't met.\n   * This preprocessing is essential for maintaining consistent state before message handlers execute.\n   *\n   * @private\n   */\n  private setupMiddlewares(): void {\n    // Register the authorization middleware\n    this.bot.use(this.authorizationMiddleware.bind(this));\n\n    // Register the chat and entity management middleware\n    this.bot.use(this.chatAndEntityMiddleware.bind(this));\n  }\n\n  /**\n   * Authorization middleware - checks if chat is allowed to interact with the bot\n   * based on the TELEGRAM_ALLOWED_CHATS configuration.\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @param {Function} next - The function to call to proceed to the next middleware\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async authorizationMiddleware(ctx: Context, next: Function): Promise<void> {\n    if (!(await this.isGroupAuthorized(ctx))) {\n      // Skip further processing if chat is not authorized\n      logger.debug('Chat not authorized, skipping message processing');\n      return;\n    }\n    await next();\n  }\n\n  /**\n   * Chat and entity management middleware - handles new chats, forum topics, and entity synchronization.\n   * This middleware implements decision logic to determine which operations are needed based on\n   * the chat type and whether we've seen this chat before.\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @param {Function} next - The function to call to proceed to the next middleware\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async chatAndEntityMiddleware(ctx: Context, next: Function): Promise<void> {\n    if (!ctx.chat) return next();\n\n    const chatId = ctx.chat.id.toString();\n\n    // If we haven't seen this chat before, process it as a new chat\n    if (!this.knownChats.has(chatId)) {\n      // Process the new chat - creates world, room, topic room (if applicable) and entities\n      await this.handleNewChat(ctx);\n      // Skip entity synchronization for new chats and proceed to the next middleware\n      return next();\n    }\n\n    // For existing chats, determine the required operations based on chat type\n    await this.processExistingChat(ctx);\n\n    await next();\n  }\n\n  /**\n   * Process an existing chat based on chat type and message properties.\n   * Different chat types require different processing steps.\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async processExistingChat(ctx: Context): Promise<void> {\n    if (!ctx.chat) return;\n\n    const chat = ctx.chat;\n\n    // Handle forum topics for supergroups with forums\n    if (chat.type === 'supergroup' && chat.is_forum && ctx.message?.message_thread_id) {\n      try {\n        await this.handleForumTopic(ctx);\n      } catch (error) {\n        logger.error(`Error handling forum topic: ${error}`);\n      }\n    }\n\n    // For non-private chats, synchronize entity information\n    if (ctx.from && ctx.chat.type !== 'private') {\n      await this.syncEntity(ctx);\n    }\n  }\n\n  /**\n   * Sets up message and reaction handlers for the bot.\n   * Configures event handlers to process incoming messages and reactions.\n   *\n   * @private\n   */\n  private setupMessageHandlers(): void {\n    // Regular message handler\n    this.bot.on('message', async (ctx) => {\n      try {\n        // Message handling is now simplified since all preprocessing is done by middleware\n        await this.messageManager.handleMessage(ctx);\n      } catch (error) {\n        logger.error('Error handling message:', error);\n      }\n    });\n\n    // Reaction handler\n    this.bot.on('message_reaction', async (ctx) => {\n      try {\n        await this.messageManager.handleReaction(ctx);\n      } catch (error) {\n        logger.error('Error handling reaction:', error);\n      }\n    });\n  }\n\n  /**\n   * Checks if a group is authorized, based on the TELEGRAM_ALLOWED_CHATS setting.\n   * @param {Context} ctx - The context of the incoming update.\n   * @returns {Promise<boolean>} A Promise that resolves with a boolean indicating if the group is authorized.\n   */\n  private async isGroupAuthorized(ctx: Context): Promise<boolean> {\n    const chatId = ctx.chat?.id.toString();\n    if (!chatId) return false;\n\n    const allowedChats = this.runtime.getSetting('TELEGRAM_ALLOWED_CHATS');\n    if (!allowedChats) {\n      return true;\n    }\n\n    try {\n      const allowedChatsList = JSON.parse(allowedChats as string);\n      return allowedChatsList.includes(chatId);\n    } catch (error) {\n      logger.error('Error parsing TELEGRAM_ALLOWED_CHATS:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Synchronizes an entity from a message context with the runtime system.\n   * This method handles three cases:\n   * 1. Message sender - most common case\n   * 2. New chat member - when a user joins the chat\n   * 3. Left chat member - when a user leaves the chat\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async syncEntity(ctx: Context): Promise<void> {\n    if (!ctx.chat) return;\n\n    const chat = ctx.chat;\n    const chatId = chat.id.toString();\n    const worldId = createUniqueUuid(this.runtime, chatId) as UUID;\n    const roomId = createUniqueUuid(\n      this.runtime,\n      ctx.message?.message_thread_id\n        ? `${ctx.chat.id}-${ctx.message.message_thread_id}`\n        : ctx.chat.id.toString()\n    ) as UUID;\n\n    // Handle all three entity sync cases separately for clarity\n    await this.syncMessageSender(ctx, worldId, roomId, chatId);\n    await this.syncNewChatMember(ctx, worldId, roomId, chatId);\n    await this.syncLeftChatMember(ctx);\n  }\n\n  /**\n   * Synchronizes the message sender entity with the runtime system.\n   * This is the most common entity sync case.\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @param {UUID} worldId - The ID of the world\n   * @param {UUID} roomId - The ID of the room\n   * @param {string} chatId - The ID of the chat\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async syncMessageSender(\n    ctx: Context,\n    worldId: UUID,\n    roomId: UUID,\n    chatId: string\n  ): Promise<void> {\n    // Handle message sender\n    if (ctx.from && !this.syncedEntityIds.has(ctx.from.id.toString())) {\n      const telegramId = ctx.from.id.toString();\n      const entityId = createUniqueUuid(this.runtime, telegramId) as UUID;\n\n      await this.runtime.ensureConnection({\n        entityId,\n        roomId: roomId,\n        userName: ctx.from.username,\n        userId: telegramId as UUID,\n        name: ctx.from.first_name || ctx.from.username || 'Unknown User',\n        source: 'telegram',\n        channelId: chatId,\n        serverId: chatId,\n        type: ChannelType.GROUP,\n        worldId: worldId,\n      });\n\n      this.syncedEntityIds.add(entityId);\n    }\n  }\n\n  /**\n   * Synchronizes a new chat member entity with the runtime system.\n   * Triggered when a user joins the chat.\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @param {UUID} worldId - The ID of the world\n   * @param {UUID} roomId - The ID of the room\n   * @param {string} chatId - The ID of the chat\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async syncNewChatMember(\n    ctx: Context,\n    worldId: UUID,\n    roomId: UUID,\n    chatId: string\n  ): Promise<void> {\n    // Handle new chat member\n    if (ctx.message && 'new_chat_member' in ctx.message) {\n      const newMember = ctx.message.new_chat_member as any;\n      const telegramId = newMember.id.toString();\n      const entityId = createUniqueUuid(this.runtime, telegramId) as UUID;\n\n      // Skip if we've already synced this entity\n      if (this.syncedEntityIds.has(telegramId)) return;\n\n      // We call ensure connection here for this user.\n      await this.runtime.ensureConnection({\n        entityId,\n        roomId: roomId,\n        userName: newMember.username,\n        userId: telegramId,\n        name: newMember.first_name || newMember.username || 'Unknown User',\n        source: 'telegram',\n        channelId: chatId,\n        serverId: chatId,\n        type: ChannelType.GROUP,\n        worldId: worldId,\n      });\n\n      this.syncedEntityIds.add(entityId);\n\n      this.runtime.emitEvent([TelegramEventTypes.ENTITY_JOINED], {\n        runtime: this.runtime,\n        entityId,\n        worldId,\n        newMember,\n        ctx,\n      });\n    }\n  }\n\n  /**\n   * Updates entity status when a user leaves the chat.\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async syncLeftChatMember(ctx: Context): Promise<void> {\n    // Handle left chat member\n    if (ctx.message && 'left_chat_member' in ctx.message) {\n      const leftMember = ctx.message.left_chat_member as any;\n      const telegramId = leftMember.id.toString();\n      const entityId = createUniqueUuid(this.runtime, telegramId) as UUID;\n\n      const existingEntity = await this.runtime.getEntityById(entityId);\n      if (existingEntity) {\n        existingEntity.metadata = {\n          ...existingEntity.metadata,\n          status: 'INACTIVE',\n          leftAt: Date.now(),\n        };\n        await this.runtime.updateEntity(existingEntity);\n      }\n    }\n  }\n\n  /**\n   * Handles forum topics by creating appropriate rooms in the runtime system.\n   * This enables proper conversation management for Telegram's forum feature.\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async handleForumTopic(ctx: Context): Promise<void> {\n    if (!ctx.chat || !ctx.message?.message_thread_id) return;\n\n    const chat = ctx.chat;\n    const chatId = chat.id.toString();\n    const worldId = createUniqueUuid(this.runtime, chatId) as UUID;\n\n    const room = await this.buildForumTopicRoom(ctx, worldId);\n    if (!room) return;\n\n    await this.runtime.ensureRoomExists(room);\n  }\n\n  /**\n   * Builds entity for message sender\n   */\n  private buildMsgSenderEntity(from: any): Entity | null {\n    if (!from) return null;\n\n    const userId = createUniqueUuid(this.runtime, from.id.toString()) as UUID;\n    const telegramId = from.id.toString();\n\n    return {\n      id: userId,\n      agentId: this.runtime.agentId,\n      names: [from.first_name || from.username || 'Unknown User'],\n      metadata: {\n        telegram: {\n          id: telegramId,\n          username: from.username,\n          name: from.first_name || from.username || 'Unknown User',\n        },\n      },\n    };\n  }\n\n  /**\n   * Handles new chat discovery and emits WORLD_JOINED event.\n   * This is a critical function that ensures new chats are properly\n   * registered in the runtime system and appropriate events are emitted.\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async handleNewChat(ctx: Context): Promise<void> {\n    if (!ctx.chat) return;\n\n    const chat = ctx.chat;\n    const chatId = chat.id.toString();\n\n    // Mark this chat as known\n    this.knownChats.set(chatId, chat);\n\n    // Get chat title and channel type\n    const { chatTitle, channelType } = this.getChatTypeInfo(chat);\n\n    const worldId = createUniqueUuid(this.runtime, chatId) as UUID;\n\n    const existingWorld = await this.runtime.getWorld(worldId);\n    if (existingWorld) {\n      return;\n    }\n\n    const userId = ctx.from\n      ? (createUniqueUuid(this.runtime, ctx.from.id.toString()) as UUID)\n      : null;\n\n    // Fetch admin information for proper role assignment\n    let admins = [];\n    let owner = null;\n    if (chat.type === 'group' || chat.type === 'supergroup' || chat.type === 'channel') {\n      try {\n        admins = await ctx.getChatAdministrators();\n        owner = admins.find((admin) => admin.status === 'creator');\n      } catch (error) {\n        logger.warn(`Could not get chat administrators: ${error.message}`);\n      }\n    }\n\n    let ownerId = userId;\n\n    if (owner) {\n      ownerId = createUniqueUuid(this.runtime, String(owner.user.id)) as UUID;\n    }\n\n    // Build world representation\n    const world: World = {\n      id: worldId,\n      name: chatTitle,\n      agentId: this.runtime.agentId,\n      serverId: chatId,\n      metadata: {\n        source: 'telegram',\n        ownership: { ownerId },\n        roles: ownerId\n          ? {\n              [ownerId]: Role.OWNER,\n            }\n          : {},\n        chatType: chat.type,\n        isForumEnabled: chat.type === 'supergroup' && chat.is_forum,\n      },\n    };\n\n    // Directly ensure world exists instead of using syncTelegram\n    await this.runtime.ensureWorldExists(world);\n\n    // Create the main room for the chat\n    const generalRoom: Room = {\n      id: createUniqueUuid(this.runtime, chatId) as UUID,\n      name: chatTitle,\n      source: 'telegram',\n      type: channelType,\n      channelId: chatId,\n      serverId: chatId,\n      worldId,\n    };\n\n    // Directly ensure room exists instead of using syncTelegram\n    await this.runtime.ensureRoomExists(generalRoom);\n\n    // Prepare the rooms array starting with the main room\n    const rooms = [generalRoom];\n\n    // If this is a message in a forum topic, add the topic room as well\n    if (chat.type === 'supergroup' && chat.is_forum && ctx.message?.message_thread_id) {\n      const topicRoom = await this.buildForumTopicRoom(ctx, worldId);\n      if (topicRoom) {\n        rooms.push(topicRoom);\n      }\n      await this.runtime.ensureRoomExists(topicRoom);\n    }\n\n    // Build entities from chat\n    const entities = await this.buildStandardizedEntities(chat);\n\n    // Add sender if not already in entities\n    if (ctx.from) {\n      const senderEntity = this.buildMsgSenderEntity(ctx.from);\n      if (senderEntity && !entities.some((e) => e.id === senderEntity.id)) {\n        entities.push(senderEntity);\n        this.syncedEntityIds.add(senderEntity.id);\n      }\n    }\n\n    // Use the new batch processing method for entities\n    await this.batchProcessEntities(\n      entities,\n      generalRoom.id,\n      generalRoom.channelId,\n      generalRoom.serverId,\n      generalRoom.type,\n      worldId\n    );\n\n    // Create payload for world events\n    const telegramWorldPayload: TelegramWorldPayload = {\n      runtime: this.runtime,\n      world,\n      rooms,\n      entities,\n      source: 'telegram',\n      chat,\n      botUsername: this.bot.botInfo.username,\n    };\n\n    // Emit telegram-specific world joined event\n    if (chat.type !== 'private') {\n      await this.runtime.emitEvent(TelegramEventTypes.WORLD_JOINED, telegramWorldPayload);\n    }\n\n    // Finally emit the standard WORLD_JOINED event\n    await this.runtime.emitEvent(EventType.WORLD_JOINED, {\n      runtime: this.runtime,\n      world,\n      rooms,\n      entities,\n      source: 'telegram',\n    });\n  }\n\n  /**\n   * Processes entities in batches to prevent overwhelming the system.\n   *\n   * @param {Entity[]} entities - The entities to process\n   * @param {UUID} roomId - The ID of the room to connect entities to\n   * @param {string} channelId - The channel ID\n   * @param {string} serverId - The server ID\n   * @param {ChannelType} roomType - The type of the room\n   * @param {UUID} worldId - The ID of the world\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async batchProcessEntities(\n    entities: Entity[],\n    roomId: UUID,\n    channelId: string,\n    serverId: string,\n    roomType: ChannelType,\n    worldId: UUID\n  ): Promise<void> {\n    const batchSize = 50;\n\n    for (let i = 0; i < entities.length; i += batchSize) {\n      const entityBatch = entities.slice(i, i + batchSize);\n\n      // Process each entity in the batch concurrently\n      await Promise.all(\n        entityBatch.map(async (entity: Entity) => {\n          try {\n            await this.runtime.ensureConnection({\n              entityId: entity.id,\n              roomId: roomId,\n              userName: entity.metadata?.telegram?.username,\n              name: entity.metadata?.telegram?.name,\n              userId: entity.metadata?.telegram?.id,\n              source: 'telegram',\n              channelId: channelId,\n              serverId: serverId,\n              type: roomType,\n              worldId: worldId,\n            });\n          } catch (err) {\n            logger.warn(`Failed to sync user ${entity.metadata?.telegram?.username}: ${err}`);\n          }\n        })\n      );\n\n      // Add a small delay between batches if not the last batch\n      if (i + batchSize < entities.length) {\n        await new Promise((resolve) => setTimeout(resolve, 500));\n      }\n    }\n  }\n\n  /**\n   * Gets chat title and channel type based on Telegram chat type.\n   * Maps Telegram-specific chat types to standardized system types.\n   *\n   * @param {any} chat - The Telegram chat object\n   * @returns {Object} Object containing chatTitle and channelType\n   * @private\n   */\n  private getChatTypeInfo(chat: any): { chatTitle: string; channelType: ChannelType } {\n    let chatTitle: string;\n    let channelType: ChannelType;\n\n    switch (chat.type) {\n      case 'private':\n        chatTitle = `Chat with ${chat.first_name || 'Unknown User'}`;\n        channelType = ChannelType.DM;\n        break;\n      case 'group':\n        chatTitle = chat.title || 'Unknown Group';\n        channelType = ChannelType.GROUP;\n        break;\n      case 'supergroup':\n        chatTitle = chat.title || 'Unknown Supergroup';\n        channelType = ChannelType.GROUP;\n        break;\n      case 'channel':\n        chatTitle = chat.title || 'Unknown Channel';\n        channelType = ChannelType.FEED;\n        break;\n      default:\n        chatTitle = 'Unknown Chat';\n        channelType = ChannelType.GROUP;\n    }\n\n    return { chatTitle, channelType };\n  }\n\n  /**\n   * Builds standardized entity representations from Telegram chat data.\n   * Transforms Telegram-specific user data into system-standard Entity objects.\n   *\n   * @param {any} chat - The Telegram chat object\n   * @returns {Promise<Entity[]>} Array of standardized Entity objects\n   * @private\n   */\n  private async buildStandardizedEntities(chat: any): Promise<Entity[]> {\n    const entities: Entity[] = [];\n\n    try {\n      // For private chats, add the user\n      if (chat.type === 'private' && chat.id) {\n        const userId = createUniqueUuid(this.runtime, chat.id.toString()) as UUID;\n        entities.push({\n          id: userId,\n          names: [chat.first_name || 'Unknown User'],\n          agentId: this.runtime.agentId,\n          metadata: {\n            telegram: {\n              id: chat.id.toString(),\n              username: chat.username || 'unknown',\n              name: chat.first_name || 'Unknown User',\n            },\n            source: 'telegram',\n          },\n        });\n        this.syncedEntityIds.add(userId);\n      } else if (chat.type === 'group' || chat.type === 'supergroup') {\n        // For groups and supergroups, try to get member information\n        try {\n          // Get chat administrators (this is what's available through the Bot API)\n          const admins = await this.bot.telegram.getChatAdministrators(chat.id);\n\n          if (admins && admins.length > 0) {\n            for (const admin of admins) {\n              const userId = createUniqueUuid(this.runtime, admin.user.id.toString()) as UUID;\n              entities.push({\n                id: userId,\n                names: [admin.user.first_name || admin.user.username || 'Unknown Admin'],\n                agentId: this.runtime.agentId,\n                metadata: {\n                  telegram: {\n                    id: admin.user.id.toString(),\n                    username: admin.user.username || 'unknown',\n                    name: admin.user.first_name || 'Unknown Admin',\n                    isAdmin: true,\n                    adminTitle:\n                      admin.custom_title || (admin.status === 'creator' ? 'Owner' : 'Admin'),\n                  },\n                  source: 'telegram',\n                  roles: [admin.status === 'creator' ? Role.OWNER : Role.ADMIN],\n                },\n              });\n              this.syncedEntityIds.add(userId);\n            }\n          }\n        } catch (error) {\n          logger.warn(`Could not fetch administrators for chat ${chat.id}: ${error}`);\n        }\n      }\n    } catch (error) {\n      logger.error(\n        `Error building standardized entities: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n\n    return entities;\n  }\n\n  /**\n   * Extracts and builds the room object for a forum topic from a message context.\n   * This refactored method can be used both in middleware and when handling new chats.\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @param {UUID} worldId - The ID of the world the topic belongs to\n   * @returns {Promise<Room | null>} A Promise that resolves with the room or null if not a topic\n   * @private\n   */\n  private async buildForumTopicRoom(ctx: Context, worldId: UUID): Promise<Room | null> {\n    if (!ctx.chat || !ctx.message?.message_thread_id) return null;\n    if (ctx.chat.type !== 'supergroup' || !ctx.chat.is_forum) return null;\n\n    const chat = ctx.chat;\n    const chatId = chat.id.toString();\n    const threadId = ctx.message.message_thread_id.toString();\n    const roomId = createUniqueUuid(this.runtime, `${chatId}-${threadId}`) as UUID;\n\n    try {\n      // Ensure the message object is fully initialized\n      const replyMessage = JSON.parse(JSON.stringify(ctx.message));\n\n      // Default topic name\n      let topicName = `Topic #${threadId}`;\n\n      // Check if forum_topic_created exists directly in the message\n      if (\n        replyMessage &&\n        typeof replyMessage === 'object' &&\n        'forum_topic_created' in replyMessage &&\n        replyMessage.forum_topic_created\n      ) {\n        const topicCreated = replyMessage.forum_topic_created;\n        if (topicCreated && typeof topicCreated === 'object' && 'name' in topicCreated) {\n          topicName = topicCreated.name;\n        }\n      }\n      // Check if forum_topic_created exists in reply_to_message\n      else if (\n        replyMessage &&\n        typeof replyMessage === 'object' &&\n        'reply_to_message' in replyMessage &&\n        replyMessage.reply_to_message &&\n        typeof replyMessage.reply_to_message === 'object' &&\n        'forum_topic_created' in replyMessage.reply_to_message &&\n        replyMessage.reply_to_message.forum_topic_created\n      ) {\n        const topicCreated = replyMessage.reply_to_message.forum_topic_created;\n        if (topicCreated && typeof topicCreated === 'object' && 'name' in topicCreated) {\n          topicName = topicCreated.name;\n        }\n      }\n\n      // Create a room for this topic\n      const room: Room = {\n        id: roomId,\n        name: topicName,\n        source: 'telegram',\n        type: ChannelType.GROUP,\n        channelId: `${chatId}-${threadId}`,\n        serverId: chatId,\n        worldId,\n        metadata: {\n          threadId: threadId,\n          isForumTopic: true,\n          parentChatId: chatId,\n        },\n      };\n\n      return room;\n    } catch (error) {\n      logger.error(\n        `Error building forum topic room: ${error instanceof Error ? error.message : String(error)}`\n      );\n      return null;\n    }\n  }\n}\n","import type { IAgentRuntime } from '@elizaos/core';\nimport { z } from 'zod';\n\nexport const telegramEnvSchema = z.object({\n  TELEGRAM_BOT_TOKEN: z.string().min(1, 'Telegram bot token is required'),\n});\n\n/**\n * Represents the type definition for configuring a Telegram bot based on the inferred schema.\n */\nexport type TelegramConfig = z.infer<typeof telegramEnvSchema>;\n\n/**\n * Validates the Telegram configuration by retrieving the Telegram bot token from the runtime settings or environment variables.\n *\n * @param {IAgentRuntime} runtime - The agent runtime used to get the setting.\n * @returns {Promise<TelegramConfig>} A promise that resolves with the validated Telegram configuration.\n */\nexport async function validateTelegramConfig(runtime: IAgentRuntime): Promise<TelegramConfig> {\n  try {\n    const config = {\n      TELEGRAM_BOT_TOKEN:\n        runtime.getSetting('TELEGRAM_BOT_TOKEN') || process.env.TELEGRAM_BOT_TOKEN,\n    };\n\n    return telegramEnvSchema.parse(config);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      const errorMessages = error.errors\n        .map((err) => `${err.path.join('.')}: ${err.message}`)\n        .join('\\n');\n      throw new Error(`Telegram configuration validation failed:\\n${errorMessages}`);\n    }\n    throw error;\n  }\n}\n","import {\n  ChannelType,\n  type Content,\n  EventType,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Media,\n  type Memory,\n  ModelType,\n  type UUID,\n  createUniqueUuid,\n  logger,\n} from '@elizaos/core';\nimport type { Chat, Message, ReactionType, Update } from '@telegraf/types';\nimport type { Context, NarrowedContext, Telegraf } from 'telegraf';\nimport {\n  TelegramContent,\n  TelegramEventTypes,\n  type TelegramMessageReceivedPayload,\n  type TelegramMessageSentPayload,\n  type TelegramReactionReceivedPayload,\n} from './types';\nimport { convertToTelegramButtons, escapeMarkdown } from './utils';\nimport { Markup } from 'telegraf';\n\nimport fs from 'node:fs';\n\n/**\n * Enum representing different types of media.\n * @enum { string }\n * @readonly\n */\nexport enum MediaType {\n  PHOTO = 'photo',\n  VIDEO = 'video',\n  DOCUMENT = 'document',\n  AUDIO = 'audio',\n  ANIMATION = 'animation',\n}\n\nconst MAX_MESSAGE_LENGTH = 4096; // Telegram's max message length\n\nconst getChannelType = (chat: Chat): ChannelType => {\n  if (chat.type === 'private') return ChannelType.DM;\n  if (chat.type === 'supergroup') return ChannelType.GROUP;\n  if (chat.type === 'channel') return ChannelType.GROUP;\n  if (chat.type === 'group') return ChannelType.GROUP;\n};\n\n/**\n * Class representing a message manager.\n * @class\n */\nexport class MessageManager {\n  public bot: Telegraf<Context>;\n  protected runtime: IAgentRuntime;\n\n  /**\n   * Constructor for creating a new instance of a BotAgent.\n   *\n   * @param {Telegraf<Context>} bot - The Telegraf instance used for interacting with the bot platform.\n   * @param {IAgentRuntime} runtime - The runtime environment for the agent.\n   */\n  constructor(bot: Telegraf<Context>, runtime: IAgentRuntime) {\n    this.bot = bot;\n    this.runtime = runtime;\n  }\n\n  // Process image messages and generate descriptions\n  /**\n   * Process an image from a Telegram message to extract the image URL and description.\n   *\n   * @param {Message} message - The Telegram message object containing the image.\n   * @returns {Promise<{ description: string } | null>} The description of the processed image or null if no image found.\n   */\n  async processImage(message: Message): Promise<{ description: string } | null> {\n    try {\n      let imageUrl: string | null = null;\n\n      logger.info(`Telegram Message: ${message}`);\n\n      if ('photo' in message && message.photo?.length > 0) {\n        const photo = message.photo[message.photo.length - 1];\n        const fileLink = await this.bot.telegram.getFileLink(photo.file_id);\n        imageUrl = fileLink.toString();\n      } else if ('document' in message && message.document?.mime_type?.startsWith('image/')) {\n        const fileLink = await this.bot.telegram.getFileLink(message.document.file_id);\n        imageUrl = fileLink.toString();\n      }\n\n      if (imageUrl) {\n        const { title, description } = await this.runtime.useModel(\n          ModelType.IMAGE_DESCRIPTION,\n          imageUrl\n        );\n        return { description: `[Image: ${title}\\n${description}]` };\n      }\n    } catch (error) {\n      console.error('‚ùå Error processing image:', error);\n    }\n\n    return null;\n  }\n\n  // Send long messages in chunks\n  /**\n   * Sends a message in chunks, handling attachments and splitting the message if necessary\n   *\n   * @param {Context} ctx - The context object representing the current state of the bot\n   * @param {TelegramContent} content - The content of the message to be sent\n   * @param {number} [replyToMessageId] - The ID of the message to reply to, if any\n   * @returns {Promise<Message.TextMessage[]>} - An array of TextMessage objects representing the messages sent\n   */\n  async sendMessageInChunks(\n    ctx: Context,\n    content: TelegramContent,\n    replyToMessageId?: number\n  ): Promise<Message.TextMessage[]> {\n    if (content.attachments && content.attachments.length > 0) {\n      content.attachments.map(async (attachment: Media) => {\n        const typeMap: { [key: string]: MediaType } = {\n          'image/gif': MediaType.ANIMATION,\n          image: MediaType.PHOTO,\n          doc: MediaType.DOCUMENT,\n          video: MediaType.VIDEO,\n          audio: MediaType.AUDIO,\n        };\n\n        let mediaType: MediaType | undefined = undefined;\n\n        for (const prefix in typeMap) {\n          if (attachment.contentType.startsWith(prefix)) {\n            mediaType = typeMap[prefix];\n            break;\n          }\n        }\n\n        if (!mediaType) {\n          throw new Error(\n            `Unsupported Telegram attachment content type: ${attachment.contentType}`\n          );\n        }\n\n        await this.sendMedia(ctx, attachment.url, mediaType, attachment.description);\n      });\n    } else {\n      const chunks = this.splitMessage(content.text);\n      const sentMessages: Message.TextMessage[] = [];\n\n      const telegramButtons = convertToTelegramButtons(content.buttons ?? []);\n\n      await ctx.telegram.sendChatAction(ctx.chat.id, 'typing');\n\n      for (let i = 0; i < chunks.length; i++) {\n        const chunk = escapeMarkdown(chunks[i]);\n        const sentMessage = (await ctx.telegram.sendMessage(ctx.chat.id, chunk, {\n          reply_parameters:\n            i === 0 && replyToMessageId ? { message_id: replyToMessageId } : undefined,\n          parse_mode: 'Markdown',\n          ...Markup.inlineKeyboard(telegramButtons),\n        })) as Message.TextMessage;\n\n        sentMessages.push(sentMessage);\n      }\n\n      return sentMessages;\n    }\n  }\n\n  /**\n   * Sends media to a chat using the Telegram API.\n   *\n   * @param {Context} ctx - The context object containing information about the current chat.\n   * @param {string} mediaPath - The path to the media to be sent, either a URL or a local file path.\n   * @param {MediaType} type - The type of media being sent (PHOTO, VIDEO, DOCUMENT, AUDIO, or ANIMATION).\n   * @param {string} [caption] - Optional caption for the media being sent.\n   *\n   * @returns {Promise<void>} A Promise that resolves when the media is successfully sent.\n   */\n  async sendMedia(\n    ctx: Context,\n    mediaPath: string,\n    type: MediaType,\n    caption?: string\n  ): Promise<void> {\n    try {\n      const isUrl = /^(http|https):\\/\\//.test(mediaPath);\n      const sendFunctionMap: Record<MediaType, Function> = {\n        [MediaType.PHOTO]: ctx.telegram.sendPhoto.bind(ctx.telegram),\n        [MediaType.VIDEO]: ctx.telegram.sendVideo.bind(ctx.telegram),\n        [MediaType.DOCUMENT]: ctx.telegram.sendDocument.bind(ctx.telegram),\n        [MediaType.AUDIO]: ctx.telegram.sendAudio.bind(ctx.telegram),\n        [MediaType.ANIMATION]: ctx.telegram.sendAnimation.bind(ctx.telegram),\n      };\n\n      const sendFunction = sendFunctionMap[type];\n\n      if (!sendFunction) {\n        throw new Error(`Unsupported media type: ${type}`);\n      }\n\n      if (isUrl) {\n        // Handle HTTP URLs\n        await sendFunction(ctx.chat.id, mediaPath, { caption });\n      } else {\n        // Handle local file paths\n        if (!fs.existsSync(mediaPath)) {\n          throw new Error(`File not found at path: ${mediaPath}`);\n        }\n\n        const fileStream = fs.createReadStream(mediaPath);\n\n        try {\n          await sendFunction(ctx.chat.id, { source: fileStream }, { caption });\n        } finally {\n          fileStream.destroy();\n        }\n      }\n\n      logger.info(\n        `${type.charAt(0).toUpperCase() + type.slice(1)} sent successfully: ${mediaPath}`\n      );\n    } catch (error) {\n      logger.error(`Failed to send ${type}. Path: ${mediaPath}. Error: ${error.message}`);\n      logger.debug(error.stack);\n      throw error;\n    }\n  }\n\n  // Split message into smaller parts\n  /**\n   * Splits a given text into an array of strings based on the maximum message length.\n   *\n   * @param {string} text - The text to split into chunks.\n   * @returns {string[]} An array of strings with each element representing a chunk of the original text.\n   */\n  private splitMessage(text: string): string[] {\n    const chunks: string[] = [];\n    let currentChunk = '';\n\n    const lines = text.split('\\n');\n    for (const line of lines) {\n      if (currentChunk.length + line.length + 1 <= MAX_MESSAGE_LENGTH) {\n        currentChunk += (currentChunk ? '\\n' : '') + line;\n      } else {\n        if (currentChunk) chunks.push(currentChunk);\n        currentChunk = line;\n      }\n    }\n\n    if (currentChunk) chunks.push(currentChunk);\n    return chunks;\n  }\n\n  // Main handler for incoming messages\n  /**\n   * Handle incoming messages from Telegram and process them accordingly.\n   * @param {Context} ctx - The context object containing information about the message.\n   * @returns {Promise<void>}\n   */\n  public async handleMessage(ctx: Context): Promise<void> {\n    // Type guard to ensure message exists\n    if (!ctx.message || !ctx.from) return;\n\n    const message = ctx.message as Message.TextMessage;\n\n    try {\n      // Convert IDs to UUIDs\n      const entityId = createUniqueUuid(this.runtime, ctx.from.id.toString()) as UUID;\n\n      const threadId =\n        'is_topic_message' in message && message.is_topic_message\n          ? message.message_thread_id?.toString()\n          : undefined;\n\n      // Generate room ID based on whether this is in a forum topic\n      const roomId = createUniqueUuid(\n        this.runtime,\n        threadId ? `${ctx.chat.id}-${threadId}` : ctx.chat.id.toString()\n      ) as UUID;\n\n      // Get message ID\n      const messageId = createUniqueUuid(this.runtime, message?.message_id?.toString());\n\n      // Handle images\n      const imageInfo = await this.processImage(message);\n\n      // Get message text - use type guards for safety\n      let messageText = '';\n      if ('text' in message && message.text) {\n        messageText = message.text;\n      } else if ('caption' in message && message.caption) {\n        messageText = message.caption as string;\n      }\n\n      // Combine text and image description\n      const fullText = imageInfo ? `${messageText} ${imageInfo.description}` : messageText;\n      if (!fullText) return;\n\n      // Get chat type and determine channel type\n      const chat = message.chat as Chat;\n      const channelType = getChannelType(chat);\n\n      // Create the memory object\n      const memory: Memory = {\n        id: messageId,\n        entityId,\n        agentId: this.runtime.agentId,\n        roomId,\n        content: {\n          text: fullText,\n          source: 'telegram',\n          channelType: channelType,\n          inReplyTo:\n            'reply_to_message' in message && message.reply_to_message\n              ? createUniqueUuid(this.runtime, message.reply_to_message.message_id.toString())\n              : undefined,\n        },\n        createdAt: message.date * 1000,\n      };\n\n      // Create callback for handling responses\n      const callback: HandlerCallback = async (content: Content, _files?: string[]) => {\n        try {\n          // If response is from reasoning do not send it.\n          if (!content.text) return [];\n\n          const sentMessages = await this.sendMessageInChunks(ctx, content, message.message_id);\n\n          if (!sentMessages) return [];\n\n          const memories: Memory[] = [];\n          for (let i = 0; i < sentMessages.length; i++) {\n            const sentMessage = sentMessages[i];\n            const _isLastMessage = i === sentMessages.length - 1;\n\n            const responseMemory: Memory = {\n              id: createUniqueUuid(this.runtime, sentMessage.message_id.toString()),\n              entityId: this.runtime.agentId,\n              agentId: this.runtime.agentId,\n              roomId,\n              content: {\n                ...content,\n                text: sentMessage.text,\n                inReplyTo: messageId,\n                channelType: channelType,\n              },\n              createdAt: sentMessage.date * 1000,\n            };\n\n            await this.runtime.createMemory(responseMemory, 'messages');\n            memories.push(responseMemory);\n          }\n\n          return memories;\n        } catch (error) {\n          logger.error('Error in message callback:', error);\n          return [];\n        }\n      };\n\n      // Let the bootstrap plugin handle the message\n      this.runtime.emitEvent(EventType.MESSAGE_RECEIVED, {\n        runtime: this.runtime,\n        message: memory,\n        callback,\n        source: 'telegram',\n      });\n\n      // Also emit the platform-specific event\n      this.runtime.emitEvent(TelegramEventTypes.MESSAGE_RECEIVED, {\n        runtime: this.runtime,\n        message: memory,\n        callback,\n        source: 'telegram',\n        ctx,\n        originalMessage: message,\n      } as TelegramMessageReceivedPayload);\n    } catch (error) {\n      logger.error('Error handling Telegram message:', {\n        error,\n        chatId: ctx.chat?.id,\n        messageId: ctx.message?.message_id,\n        from: ctx.from?.username || ctx.from?.id,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Handles the reaction event triggered by a user reacting to a message.\n   * @param {NarrowedContext<Context<Update>, Update.MessageReactionUpdate>} ctx The context of the message reaction update\n   * @returns {Promise<void>} A Promise that resolves when the reaction handling is complete\n   */\n  public async handleReaction(\n    ctx: NarrowedContext<Context<Update>, Update.MessageReactionUpdate>\n  ): Promise<void> {\n    // Ensure we have the necessary data\n    if (!ctx.update.message_reaction || !ctx.from) return;\n\n    const reaction = ctx.update.message_reaction;\n    const reactionType = reaction.new_reaction[0].type;\n    const reactionEmoji = (reaction.new_reaction[0] as ReactionType).type;\n\n    try {\n      const entityId = createUniqueUuid(this.runtime, ctx.from.id.toString()) as UUID;\n      const roomId = createUniqueUuid(this.runtime, ctx.chat.id.toString());\n\n      const reactionId = createUniqueUuid(\n        this.runtime,\n        `${reaction.message_id}-${ctx.from.id}-${Date.now()}`\n      );\n\n      // Create reaction memory\n      const memory: Memory = {\n        id: reactionId,\n        entityId,\n        agentId: this.runtime.agentId,\n        roomId,\n        content: {\n          channelType: getChannelType(reaction.chat as Chat),\n          text: `Reacted with: ${reactionType === 'emoji' ? reactionEmoji : reactionType}`,\n          source: 'telegram',\n          inReplyTo: createUniqueUuid(this.runtime, reaction.message_id.toString()),\n        },\n        createdAt: Date.now(),\n      };\n\n      // Create callback for handling reaction responses\n      const callback: HandlerCallback = async (content: Content) => {\n        try {\n          const sentMessage = await ctx.reply(content.text);\n          const responseMemory: Memory = {\n            id: createUniqueUuid(this.runtime, sentMessage.message_id.toString()),\n            entityId: this.runtime.agentId,\n            agentId: this.runtime.agentId,\n            roomId,\n            content: {\n              ...content,\n              inReplyTo: reactionId,\n            },\n            createdAt: sentMessage.date * 1000,\n          };\n          return [responseMemory];\n        } catch (error) {\n          logger.error('Error in reaction callback:', error);\n          return [];\n        }\n      };\n\n      // Let the bootstrap plugin handle the reaction\n      this.runtime.emitEvent(EventType.REACTION_RECEIVED, {\n        runtime: this.runtime,\n        message: memory,\n        callback,\n        source: 'telegram',\n      });\n\n      // Also emit the platform-specific event\n      this.runtime.emitEvent(TelegramEventTypes.REACTION_RECEIVED, {\n        runtime: this.runtime,\n        message: memory,\n        callback,\n        source: 'telegram',\n        ctx,\n        reactionString: reactionType === 'emoji' ? reactionEmoji : reactionType,\n        originalReaction: reaction.new_reaction[0] as ReactionType,\n      } as TelegramReactionReceivedPayload);\n    } catch (error) {\n      logger.error('Error handling reaction:', error);\n    }\n  }\n\n  /**\n   * Sends a message to a Telegram chat and emits appropriate events\n   * @param {number | string} chatId - The Telegram chat ID to send the message to\n   * @param {Content} content - The content to send\n   * @param {number} [replyToMessageId] - Optional message ID to reply to\n   * @returns {Promise<Message.TextMessage[]>} The sent messages\n   */\n  public async sendMessage(\n    chatId: number | string,\n    content: Content,\n    replyToMessageId?: number\n  ): Promise<Message.TextMessage[]> {\n    try {\n      // Create a context-like object for sending\n      const ctx = {\n        chat: { id: chatId },\n        telegram: this.bot.telegram,\n      };\n\n      const sentMessages = await this.sendMessageInChunks(\n        ctx as Context,\n        content,\n        replyToMessageId\n      );\n\n      if (!sentMessages?.length) return [];\n\n      // Create room ID\n      const roomId = createUniqueUuid(this.runtime, chatId.toString());\n\n      // Create memories for the sent messages\n      const memories: Memory[] = [];\n      for (const sentMessage of sentMessages) {\n        const memory: Memory = {\n          id: createUniqueUuid(this.runtime, sentMessage.message_id.toString()),\n          entityId: this.runtime.agentId,\n          agentId: this.runtime.agentId,\n          roomId,\n          content: {\n            ...content,\n            text: sentMessage.text,\n            source: 'telegram',\n            channelType: getChannelType({\n              id: typeof chatId === 'string' ? Number.parseInt(chatId, 10) : chatId,\n              type: 'private', // Default to private, will be overridden if in context\n            } as Chat),\n          },\n          createdAt: sentMessage.date * 1000,\n        };\n\n        await this.runtime.createMemory(memory, 'messages');\n        memories.push(memory);\n      }\n\n      // Emit both generic and platform-specific message sent events\n      this.runtime.emitEvent(EventType.MESSAGE_SENT, {\n        runtime: this.runtime,\n        message: {\n          content: content,\n        },\n        roomId,\n        source: 'telegram',\n      });\n\n      // Also emit platform-specific event\n      this.runtime.emitEvent(TelegramEventTypes.MESSAGE_SENT, {\n        originalMessages: sentMessages,\n        chatId,\n      } as TelegramMessageSentPayload);\n\n      return sentMessages;\n    } catch (error) {\n      logger.error('Error sending message to Telegram:', error);\n      return [];\n    }\n  }\n}\n","import { Markup } from 'telegraf';\nimport { InlineKeyboardButton } from '@telegraf/types';\nimport { Button } from './types';\n\n/**\n * Escapes Markdown special characters in the given text, excluding code blocks.\n * @param {string} text - The text to escape Markdown characters from.\n * @returns {string} The text with escaped Markdown characters.\n */\nexport function escapeMarkdown(text: string): string {\n  // Don't escape if it's a code block\n  if (text.startsWith('```') && text.endsWith('```')) {\n    return text;\n  }\n\n  // Split the text by code blocks\n  const parts = text.split(/(```[\\s\\S]*?```)/g);\n\n  return parts\n    .map((part, index) => {\n      // If it's a code block (odd indices in the split result will be code blocks)\n      if (index % 2 === 1) {\n        return part;\n      }\n      // For regular text, only escape characters that need escaping in Markdown\n      return (\n        part\n          // First preserve any intended inline code spans\n          .replace(/`.*?`/g, (match) => match)\n          // Then only escape the minimal set of special characters that need escaping in Markdown mode\n          .replace(/([*_`\\\\])/g, '\\\\$1')\n      );\n    })\n    .join('');\n}\n\n/**\n * Splits a message into chunks that fit within Telegram's message length limit\n */\n/**\n * Splits a text message into chunks based on a maximum length for each chunk.\n *\n * @param {string} text - The text message to split.\n * @param {number} maxLength - The maximum length for each chunk (default is 4096).\n * @returns {string[]} An array containing the text message split into chunks.\n */\nexport function splitMessage(text: string, maxLength = 4096): string[] {\n  const chunks: string[] = [];\n  let currentChunk = '';\n\n  const lines = text.split('\\n');\n  for (const line of lines) {\n    if (currentChunk.length + line.length + 1 <= maxLength) {\n      currentChunk += (currentChunk ? '\\n' : '') + line;\n    } else {\n      if (currentChunk) chunks.push(currentChunk);\n      currentChunk = line;\n    }\n  }\n\n  if (currentChunk) chunks.push(currentChunk);\n  return chunks;\n}\n\n/**\n * Converts Eliza buttons into Telegram buttons\n * @param {Button[]} buttons - The buttons from Eliza content\n * @returns {InlineKeyboardButton[]} Array of Telegram buttons\n */\nexport function convertToTelegramButtons(buttons?: Button[] | null): InlineKeyboardButton[] {\n  if (!buttons) return [];\n  return buttons.map((button: Button) => {\n    switch (button.kind) {\n      case 'login':\n        return Markup.button.login(button.text, button.url);\n      case 'url':\n        return Markup.button.url(button.text, button.url);\n    }\n  });\n}\n","import { type IAgentRuntime, type TestSuite, logger } from '@elizaos/core';\nimport type { Chat, User } from '@telegraf/types';\nimport type { Telegraf } from 'telegraf';\nimport type { Context } from 'telegraf';\nimport type { MessageManager } from './messageManager';\nimport type { TelegramService } from './service';\n\nconst TEST_IMAGE_URL =\n  'https://github.com/elizaOS/awesome-eliza/blob/main/assets/eliza-logo.jpg?raw=true';\n\n/**\n * Represents a test suite for testing Telegram functionality.\n *\n * This test suite includes methods to initialize and validate a Telegram bot connection,\n * send basic text messages to a Telegram chat, send text messages with image attachments,\n * handle and process incoming Telegram messages, and process and validate image attachments\n * in incoming messages.\n *\n * @implements {TestSuite}\n */\n\nexport class TelegramTestSuite implements TestSuite {\n  name = 'telegram';\n  private telegramClient: TelegramService = null;\n  private bot: Telegraf<Context> | null = null;\n  private messageManager: MessageManager | null = null;\n  tests: { name: string; fn: (runtime: IAgentRuntime) => Promise<void> }[];\n\n  /**\n   * Constructor for initializing a set of test cases for a Telegram bot.\n   *\n   * @constructor\n   * @property {Array<Object>} tests - An array of test cases with name and corresponding test functions.\n   * @property {string} tests.name - The name of the test case.\n   * @property {function} tests.fn - The test function to be executed.\n   */\n  constructor() {\n    this.tests = [\n      {\n        name: 'Initialize and Validate Telegram Bot Connection',\n        fn: this.testCreatingTelegramBot.bind(this),\n      },\n      {\n        name: 'Send Basic Text Message to Telegram Chat',\n        fn: this.testSendingTextMessage.bind(this),\n      },\n      {\n        name: 'Send Text Message with an Image Attachment',\n        fn: this.testSendingMessageWithAttachment.bind(this),\n      },\n      {\n        name: 'Handle and Process Incoming Telegram Messages',\n        fn: this.testHandlingMessage.bind(this),\n      },\n      {\n        name: 'Process and Validate Image Attachments in Incoming Messages',\n        fn: this.testProcessingImages.bind(this),\n      },\n    ];\n  }\n\n  /**\n   * Retrieves the Telegram test chat ID from environment variables.\n   *\n   * Reference on getting the Telegram chat ID:\n   * https://stackoverflow.com/a/32572159\n   */\n  /**\n   * Validates the chat ID by checking if it is set in the runtime settings or environment variables.\n   * If not set, an error is thrown with a message instructing to provide a valid chat ID.\n   * @param {IAgentRuntime} runtime - The runtime object that provides access to the settings and environment variables.\n   * @throws {Error} If TELEGRAM_TEST_CHAT_ID is not set in the runtime settings or environment variables.\n   * @returns {string} The validated chat ID.\n   */\n  validateChatId(runtime: IAgentRuntime) {\n    const testChatId =\n      runtime.getSetting('TELEGRAM_TEST_CHAT_ID') || process.env.TELEGRAM_TEST_CHAT_ID;\n    if (!testChatId) {\n      throw new Error(\n        'TELEGRAM_TEST_CHAT_ID is not set. Please provide a valid chat ID in the environment variables.'\n      );\n    }\n    return testChatId;\n  }\n\n  async getChatInfo(runtime: IAgentRuntime): Promise<Context['chat']> {\n    try {\n      const chatId = this.validateChatId(runtime);\n      const chat = await this.bot.telegram.getChat(chatId);\n      logger.log(`Fetched real chat: ${JSON.stringify(chat)}`);\n      return chat;\n    } catch (error) {\n      throw new Error(`Error fetching real Telegram chat: ${error}`);\n    }\n  }\n\n  async testCreatingTelegramBot(runtime: IAgentRuntime) {\n    this.telegramClient = runtime.getService('telegram') as TelegramService;\n    this.bot = this.telegramClient.messageManager.bot;\n    this.messageManager = this.telegramClient.messageManager;\n    logger.debug('Telegram bot initialized successfully.');\n  }\n\n  async testSendingTextMessage(runtime: IAgentRuntime) {\n    try {\n      if (!this.bot) throw new Error('Bot not initialized.');\n\n      const chatId = this.validateChatId(runtime);\n      await this.bot.telegram.sendMessage(chatId, 'Testing Telegram message!');\n      logger.debug('Message sent successfully.');\n    } catch (error) {\n      throw new Error(`Error sending Telegram message: ${error}`);\n    }\n  }\n\n  async testSendingMessageWithAttachment(runtime: IAgentRuntime) {\n    try {\n      if (!this.messageManager) throw new Error('MessageManager not initialized.');\n\n      const chat = await this.getChatInfo(runtime);\n      const mockContext: Partial<Context> = {\n        chat,\n        from: { id: 123, username: 'TestUser' } as User,\n        telegram: this.bot.telegram,\n      };\n\n      const messageContent = {\n        text: 'Here is an image attachment:',\n        attachments: [\n          {\n            id: '123',\n            title: 'Sample Image',\n            source: TEST_IMAGE_URL,\n            text: 'Sample Image',\n            url: TEST_IMAGE_URL,\n            contentType: 'image/png',\n            description: 'Sample Image',\n          },\n        ],\n      };\n\n      await this.messageManager.sendMessageInChunks(mockContext as Context, messageContent);\n\n      logger.success('Message with image attachment sent successfully.');\n    } catch (error) {\n      throw new Error(`Error sending Telegram message with attachment: ${error}`);\n    }\n  }\n\n  async testHandlingMessage(runtime: IAgentRuntime) {\n    try {\n      const chat = await this.getChatInfo(runtime);\n      const mockContext: Partial<Context> = {\n        chat,\n        from: {\n          id: 123,\n          username: 'TestUser',\n          is_bot: false,\n          first_name: 'Test',\n          last_name: 'User',\n        } as User,\n        message: {\n          message_id: undefined,\n          text: `@${this.bot.botInfo?.username}! Hello!`,\n          date: Math.floor(Date.now() / 1000),\n          chat,\n        } as any,\n        telegram: this.bot.telegram,\n      };\n\n      try {\n        await this.messageManager.handleMessage(mockContext as Context);\n      } catch (error) {\n        throw new Error(`Error handling Telegram message: ${error}`);\n      }\n    } catch (error) {\n      throw new Error(`Error handling Telegram message: ${error}`);\n    }\n  }\n\n  async testProcessingImages(runtime: IAgentRuntime) {\n    try {\n      const chatId = this.validateChatId(runtime);\n      const fileId = await this.getFileId(chatId, TEST_IMAGE_URL);\n\n      const mockMessage = {\n        message_id: undefined,\n        chat: { id: chatId } as Chat,\n        date: Math.floor(Date.now() / 1000),\n        photo: [{ file_id: fileId }],\n        text: `@${this.bot.botInfo?.username}!`,\n      };\n\n      const { description } = await this.messageManager.processImage(mockMessage);\n      if (!description) {\n        throw new Error('Error processing Telegram image');\n      }\n      logger.log(`Processing Telegram image successfully: ${description}`);\n    } catch (error) {\n      throw new Error(`Error processing Telegram image: ${error}`);\n    }\n  }\n\n  async getFileId(chatId: string, imageUrl: string) {\n    try {\n      const message = await this.bot.telegram.sendPhoto(chatId, imageUrl);\n      return message.photo[message.photo.length - 1].file_id;\n    } catch (error) {\n      logger.error(`Error sending image: ${error}`);\n      throw error;\n    }\n  }\n}\n","import type { Plugin } from '@elizaos/core';\nimport { TELEGRAM_SERVICE_NAME } from './constants';\nimport { TelegramService } from './service';\nimport { TelegramTestSuite } from './tests';\n\nconst telegramPlugin: Plugin = {\n  name: TELEGRAM_SERVICE_NAME,\n  description: 'Telegram client plugin',\n  services: [TelegramService],\n  tests: [new TelegramTestSuite()],\n};\nexport default telegramPlugin;\n"],"mappings":";AAAO,IAAM,oBAAoB;AAAA,EAC/B,cAAc;AAAA,EACd,sBAAsB;AAAA,EACtB,oBAAoB;AAAA,EACpB,8BAA8B;AAAA,EAC9B,yCAAyC;AAAA,EACzC,qBAAqB,IAAI,KAAK;AAAA;AAAA,EAC9B,wBAAwB,IAAI,KAAK;AAAA;AACnC;AAEO,IAAM,wBAAwB;;;ACVrC;AAAA,EACE,eAAAA;AAAA,EAEA,aAAAC;AAAA,EAEA;AAAA,EAEA;AAAA,EAIA,oBAAAC;AAAA,EACA,UAAAC;AAAA,OACK;AACP,SAAuB,gBAAgB;;;ACbvC,SAAS,SAAS;AAEX,IAAM,oBAAoB,EAAE,OAAO;AAAA,EACxC,oBAAoB,EAAE,OAAO,EAAE,IAAI,GAAG,gCAAgC;AACxE,CAAC;AAaD,eAAsB,uBAAuB,SAAiD;AAC5F,MAAI;AACF,UAAM,SAAS;AAAA,MACb,oBACE,QAAQ,WAAW,oBAAoB,KAAK,QAAQ,IAAI;AAAA,IAC5D;AAEA,WAAO,kBAAkB,MAAM,MAAM;AAAA,EACvC,SAAS,OAAO;AACd,QAAI,iBAAiB,EAAE,UAAU;AAC/B,YAAM,gBAAgB,MAAM,OACzB,IAAI,CAAC,QAAQ,GAAG,IAAI,KAAK,KAAK,GAAG,CAAC,KAAK,IAAI,OAAO,EAAE,EACpD,KAAK,IAAI;AACZ,YAAM,IAAI,MAAM;AAAA,EAA8C,aAAa,EAAE;AAAA,IAC/E;AACA,UAAM;AAAA,EACR;AACF;;;ACnCA;AAAA,EACE;AAAA,EAEA;AAAA,EAKA;AAAA,EAEA;AAAA,EACA;AAAA,OACK;;;ACZP,SAAS,cAAc;AAShB,SAAS,eAAe,MAAsB;AAEnD,MAAI,KAAK,WAAW,KAAK,KAAK,KAAK,SAAS,KAAK,GAAG;AAClD,WAAO;AAAA,EACT;AAGA,QAAM,QAAQ,KAAK,MAAM,mBAAmB;AAE5C,SAAO,MACJ,IAAI,CAAC,MAAM,UAAU;AAEpB,QAAI,QAAQ,MAAM,GAAG;AACnB,aAAO;AAAA,IACT;AAEA,WACE,KAEG,QAAQ,UAAU,CAAC,UAAU,KAAK,EAElC,QAAQ,cAAc,MAAM;AAAA,EAEnC,CAAC,EACA,KAAK,EAAE;AACZ;AAmCO,SAAS,yBAAyB,SAAmD;AAC1F,MAAI,CAAC,QAAS,QAAO,CAAC;AACtB,SAAO,QAAQ,IAAI,CAAC,WAAmB;AACrC,YAAQ,OAAO,MAAM;AAAA,MACnB,KAAK;AACH,eAAO,OAAO,OAAO,MAAM,OAAO,MAAM,OAAO,GAAG;AAAA,MACpD,KAAK;AACH,eAAO,OAAO,OAAO,IAAI,OAAO,MAAM,OAAO,GAAG;AAAA,IACpD;AAAA,EACF,CAAC;AACH;;;ADxDA,SAAS,UAAAC,eAAc;AAEvB,OAAO,QAAQ;AAef,IAAM,qBAAqB;AAE3B,IAAM,iBAAiB,CAAC,SAA4B;AAClD,MAAI,KAAK,SAAS,UAAW,QAAO,YAAY;AAChD,MAAI,KAAK,SAAS,aAAc,QAAO,YAAY;AACnD,MAAI,KAAK,SAAS,UAAW,QAAO,YAAY;AAChD,MAAI,KAAK,SAAS,QAAS,QAAO,YAAY;AAChD;AAMO,IAAM,iBAAN,MAAqB;AAAA,EACnB;AAAA,EACG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQV,YAAY,KAAwB,SAAwB;AAC1D,SAAK,MAAM;AACX,SAAK,UAAU;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,aAAa,SAA2D;AA3EhF;AA4EI,QAAI;AACF,UAAI,WAA0B;AAE9B,aAAO,KAAK,qBAAqB,OAAO,EAAE;AAE1C,UAAI,WAAW,aAAW,aAAQ,UAAR,mBAAe,UAAS,GAAG;AACnD,cAAM,QAAQ,QAAQ,MAAM,QAAQ,MAAM,SAAS,CAAC;AACpD,cAAM,WAAW,MAAM,KAAK,IAAI,SAAS,YAAY,MAAM,OAAO;AAClE,mBAAW,SAAS,SAAS;AAAA,MAC/B,WAAW,cAAc,aAAW,mBAAQ,aAAR,mBAAkB,cAAlB,mBAA6B,WAAW,YAAW;AACrF,cAAM,WAAW,MAAM,KAAK,IAAI,SAAS,YAAY,QAAQ,SAAS,OAAO;AAC7E,mBAAW,SAAS,SAAS;AAAA,MAC/B;AAEA,UAAI,UAAU;AACZ,cAAM,EAAE,OAAO,YAAY,IAAI,MAAM,KAAK,QAAQ;AAAA,UAChD,UAAU;AAAA,UACV;AAAA,QACF;AACA,eAAO,EAAE,aAAa,WAAW,KAAK;AAAA,EAAK,WAAW,IAAI;AAAA,MAC5D;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,kCAA6B,KAAK;AAAA,IAClD;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAM,oBACJ,KACA,SACA,kBACgC;AAChC,QAAI,QAAQ,eAAe,QAAQ,YAAY,SAAS,GAAG;AACzD,cAAQ,YAAY,IAAI,OAAO,eAAsB;AACnD,cAAM,UAAwC;AAAA,UAC5C,aAAa;AAAA,UACb,OAAO;AAAA,UACP,KAAK;AAAA,UACL,OAAO;AAAA,UACP,OAAO;AAAA,QACT;AAEA,YAAI,YAAmC;AAEvC,mBAAW,UAAU,SAAS;AAC5B,cAAI,WAAW,YAAY,WAAW,MAAM,GAAG;AAC7C,wBAAY,QAAQ,MAAM;AAC1B;AAAA,UACF;AAAA,QACF;AAEA,YAAI,CAAC,WAAW;AACd,gBAAM,IAAI;AAAA,YACR,iDAAiD,WAAW,WAAW;AAAA,UACzE;AAAA,QACF;AAEA,cAAM,KAAK,UAAU,KAAK,WAAW,KAAK,WAAW,WAAW,WAAW;AAAA,MAC7E,CAAC;AAAA,IACH,OAAO;AACL,YAAM,SAAS,KAAK,aAAa,QAAQ,IAAI;AAC7C,YAAM,eAAsC,CAAC;AAE7C,YAAM,kBAAkB,yBAAyB,QAAQ,WAAW,CAAC,CAAC;AAEtE,YAAM,IAAI,SAAS,eAAe,IAAI,KAAK,IAAI,QAAQ;AAEvD,eAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,cAAM,QAAQ,eAAe,OAAO,CAAC,CAAC;AACtC,cAAM,cAAe,MAAM,IAAI,SAAS,YAAY,IAAI,KAAK,IAAI,OAAO;AAAA,UACtE,kBACE,MAAM,KAAK,mBAAmB,EAAE,YAAY,iBAAiB,IAAI;AAAA,UACnE,YAAY;AAAA,UACZ,GAAGC,QAAO,eAAe,eAAe;AAAA,QAC1C,CAAC;AAED,qBAAa,KAAK,WAAW;AAAA,MAC/B;AAEA,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAM,UACJ,KACA,WACA,MACA,SACe;AACf,QAAI;AACF,YAAM,QAAQ,qBAAqB,KAAK,SAAS;AACjD,YAAM,kBAA+C;AAAA,QACnD,CAAC,mBAAe,GAAG,IAAI,SAAS,UAAU,KAAK,IAAI,QAAQ;AAAA,QAC3D,CAAC,mBAAe,GAAG,IAAI,SAAS,UAAU,KAAK,IAAI,QAAQ;AAAA,QAC3D,CAAC,yBAAkB,GAAG,IAAI,SAAS,aAAa,KAAK,IAAI,QAAQ;AAAA,QACjE,CAAC,mBAAe,GAAG,IAAI,SAAS,UAAU,KAAK,IAAI,QAAQ;AAAA,QAC3D,CAAC,2BAAmB,GAAG,IAAI,SAAS,cAAc,KAAK,IAAI,QAAQ;AAAA,MACrE;AAEA,YAAM,eAAe,gBAAgB,IAAI;AAEzC,UAAI,CAAC,cAAc;AACjB,cAAM,IAAI,MAAM,2BAA2B,IAAI,EAAE;AAAA,MACnD;AAEA,UAAI,OAAO;AAET,cAAM,aAAa,IAAI,KAAK,IAAI,WAAW,EAAE,QAAQ,CAAC;AAAA,MACxD,OAAO;AAEL,YAAI,CAAC,GAAG,WAAW,SAAS,GAAG;AAC7B,gBAAM,IAAI,MAAM,2BAA2B,SAAS,EAAE;AAAA,QACxD;AAEA,cAAM,aAAa,GAAG,iBAAiB,SAAS;AAEhD,YAAI;AACF,gBAAM,aAAa,IAAI,KAAK,IAAI,EAAE,QAAQ,WAAW,GAAG,EAAE,QAAQ,CAAC;AAAA,QACrE,UAAE;AACA,qBAAW,QAAQ;AAAA,QACrB;AAAA,MACF;AAEA,aAAO;AAAA,QACL,GAAG,KAAK,OAAO,CAAC,EAAE,YAAY,IAAI,KAAK,MAAM,CAAC,CAAC,uBAAuB,SAAS;AAAA,MACjF;AAAA,IACF,SAAS,OAAO;AACd,aAAO,MAAM,kBAAkB,IAAI,WAAW,SAAS,YAAY,MAAM,OAAO,EAAE;AAClF,aAAO,MAAM,MAAM,KAAK;AACxB,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,aAAa,MAAwB;AAC3C,UAAM,SAAmB,CAAC;AAC1B,QAAI,eAAe;AAEnB,UAAM,QAAQ,KAAK,MAAM,IAAI;AAC7B,eAAW,QAAQ,OAAO;AACxB,UAAI,aAAa,SAAS,KAAK,SAAS,KAAK,oBAAoB;AAC/D,yBAAiB,eAAe,OAAO,MAAM;AAAA,MAC/C,OAAO;AACL,YAAI,aAAc,QAAO,KAAK,YAAY;AAC1C,uBAAe;AAAA,MACjB;AAAA,IACF;AAEA,QAAI,aAAc,QAAO,KAAK,YAAY;AAC1C,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAa,cAAc,KAA6B;AApQ1D;AAsQI,QAAI,CAAC,IAAI,WAAW,CAAC,IAAI,KAAM;AAE/B,UAAM,UAAU,IAAI;AAEpB,QAAI;AAEF,YAAM,WAAW,iBAAiB,KAAK,SAAS,IAAI,KAAK,GAAG,SAAS,CAAC;AAEtE,YAAM,WACJ,sBAAsB,WAAW,QAAQ,oBACrC,aAAQ,sBAAR,mBAA2B,aAC3B;AAGN,YAAM,SAAS;AAAA,QACb,KAAK;AAAA,QACL,WAAW,GAAG,IAAI,KAAK,EAAE,IAAI,QAAQ,KAAK,IAAI,KAAK,GAAG,SAAS;AAAA,MACjE;AAGA,YAAM,YAAY,iBAAiB,KAAK,UAAS,wCAAS,eAAT,mBAAqB,UAAU;AAGhF,YAAM,YAAY,MAAM,KAAK,aAAa,OAAO;AAGjD,UAAI,cAAc;AAClB,UAAI,UAAU,WAAW,QAAQ,MAAM;AACrC,sBAAc,QAAQ;AAAA,MACxB,WAAW,aAAa,WAAW,QAAQ,SAAS;AAClD,sBAAc,QAAQ;AAAA,MACxB;AAGA,YAAM,WAAW,YAAY,GAAG,WAAW,IAAI,UAAU,WAAW,KAAK;AACzE,UAAI,CAAC,SAAU;AAGf,YAAM,OAAO,QAAQ;AACrB,YAAM,cAAc,eAAe,IAAI;AAGvC,YAAM,SAAiB;AAAA,QACrB,IAAI;AAAA,QACJ;AAAA,QACA,SAAS,KAAK,QAAQ;AAAA,QACtB;AAAA,QACA,SAAS;AAAA,UACP,MAAM;AAAA,UACN,QAAQ;AAAA,UACR;AAAA,UACA,WACE,sBAAsB,WAAW,QAAQ,mBACrC,iBAAiB,KAAK,SAAS,QAAQ,iBAAiB,WAAW,SAAS,CAAC,IAC7E;AAAA,QACR;AAAA,QACA,WAAW,QAAQ,OAAO;AAAA,MAC5B;AAGA,YAAM,WAA4B,OAAO,SAAkB,WAAsB;AAC/E,YAAI;AAEF,cAAI,CAAC,QAAQ,KAAM,QAAO,CAAC;AAE3B,gBAAM,eAAe,MAAM,KAAK,oBAAoB,KAAK,SAAS,QAAQ,UAAU;AAEpF,cAAI,CAAC,aAAc,QAAO,CAAC;AAE3B,gBAAM,WAAqB,CAAC;AAC5B,mBAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,kBAAM,cAAc,aAAa,CAAC;AAClC,kBAAM,iBAAiB,MAAM,aAAa,SAAS;AAEnD,kBAAM,iBAAyB;AAAA,cAC7B,IAAI,iBAAiB,KAAK,SAAS,YAAY,WAAW,SAAS,CAAC;AAAA,cACpE,UAAU,KAAK,QAAQ;AAAA,cACvB,SAAS,KAAK,QAAQ;AAAA,cACtB;AAAA,cACA,SAAS;AAAA,gBACP,GAAG;AAAA,gBACH,MAAM,YAAY;AAAA,gBAClB,WAAW;AAAA,gBACX;AAAA,cACF;AAAA,cACA,WAAW,YAAY,OAAO;AAAA,YAChC;AAEA,kBAAM,KAAK,QAAQ,aAAa,gBAAgB,UAAU;AAC1D,qBAAS,KAAK,cAAc;AAAA,UAC9B;AAEA,iBAAO;AAAA,QACT,SAAS,OAAO;AACd,iBAAO,MAAM,8BAA8B,KAAK;AAChD,iBAAO,CAAC;AAAA,QACV;AAAA,MACF;AAGA,WAAK,QAAQ,UAAU,UAAU,kBAAkB;AAAA,QACjD,SAAS,KAAK;AAAA,QACd,SAAS;AAAA,QACT;AAAA,QACA,QAAQ;AAAA,MACV,CAAC;AAGD,WAAK,QAAQ,8DAA+C;AAAA,QAC1D,SAAS,KAAK;AAAA,QACd,SAAS;AAAA,QACT;AAAA,QACA,QAAQ;AAAA,QACR;AAAA,QACA,iBAAiB;AAAA,MACnB,CAAmC;AAAA,IACrC,SAAS,OAAO;AACd,aAAO,MAAM,oCAAoC;AAAA,QAC/C;AAAA,QACA,SAAQ,SAAI,SAAJ,mBAAU;AAAA,QAClB,YAAW,SAAI,YAAJ,mBAAa;AAAA,QACxB,QAAM,SAAI,SAAJ,mBAAU,eAAY,SAAI,SAAJ,mBAAU;AAAA,MACxC,CAAC;AACD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,eACX,KACe;AAEf,QAAI,CAAC,IAAI,OAAO,oBAAoB,CAAC,IAAI,KAAM;AAE/C,UAAM,WAAW,IAAI,OAAO;AAC5B,UAAM,eAAe,SAAS,aAAa,CAAC,EAAE;AAC9C,UAAM,gBAAiB,SAAS,aAAa,CAAC,EAAmB;AAEjE,QAAI;AACF,YAAM,WAAW,iBAAiB,KAAK,SAAS,IAAI,KAAK,GAAG,SAAS,CAAC;AACtE,YAAM,SAAS,iBAAiB,KAAK,SAAS,IAAI,KAAK,GAAG,SAAS,CAAC;AAEpE,YAAM,aAAa;AAAA,QACjB,KAAK;AAAA,QACL,GAAG,SAAS,UAAU,IAAI,IAAI,KAAK,EAAE,IAAI,KAAK,IAAI,CAAC;AAAA,MACrD;AAGA,YAAM,SAAiB;AAAA,QACrB,IAAI;AAAA,QACJ;AAAA,QACA,SAAS,KAAK,QAAQ;AAAA,QACtB;AAAA,QACA,SAAS;AAAA,UACP,aAAa,eAAe,SAAS,IAAY;AAAA,UACjD,MAAM,iBAAiB,iBAAiB,UAAU,gBAAgB,YAAY;AAAA,UAC9E,QAAQ;AAAA,UACR,WAAW,iBAAiB,KAAK,SAAS,SAAS,WAAW,SAAS,CAAC;AAAA,QAC1E;AAAA,QACA,WAAW,KAAK,IAAI;AAAA,MACtB;AAGA,YAAM,WAA4B,OAAO,YAAqB;AAC5D,YAAI;AACF,gBAAM,cAAc,MAAM,IAAI,MAAM,QAAQ,IAAI;AAChD,gBAAM,iBAAyB;AAAA,YAC7B,IAAI,iBAAiB,KAAK,SAAS,YAAY,WAAW,SAAS,CAAC;AAAA,YACpE,UAAU,KAAK,QAAQ;AAAA,YACvB,SAAS,KAAK,QAAQ;AAAA,YACtB;AAAA,YACA,SAAS;AAAA,cACP,GAAG;AAAA,cACH,WAAW;AAAA,YACb;AAAA,YACA,WAAW,YAAY,OAAO;AAAA,UAChC;AACA,iBAAO,CAAC,cAAc;AAAA,QACxB,SAAS,OAAO;AACd,iBAAO,MAAM,+BAA+B,KAAK;AACjD,iBAAO,CAAC;AAAA,QACV;AAAA,MACF;AAGA,WAAK,QAAQ,UAAU,UAAU,mBAAmB;AAAA,QAClD,SAAS,KAAK;AAAA,QACd,SAAS;AAAA,QACT;AAAA,QACA,QAAQ;AAAA,MACV,CAAC;AAGD,WAAK,QAAQ,gEAAgD;AAAA,QAC3D,SAAS,KAAK;AAAA,QACd,SAAS;AAAA,QACT;AAAA,QACA,QAAQ;AAAA,QACR;AAAA,QACA,gBAAgB,iBAAiB,UAAU,gBAAgB;AAAA,QAC3D,kBAAkB,SAAS,aAAa,CAAC;AAAA,MAC3C,CAAoC;AAAA,IACtC,SAAS,OAAO;AACd,aAAO,MAAM,4BAA4B,KAAK;AAAA,IAChD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAa,YACX,QACA,SACA,kBACgC;AAChC,QAAI;AAEF,YAAM,MAAM;AAAA,QACV,MAAM,EAAE,IAAI,OAAO;AAAA,QACnB,UAAU,KAAK,IAAI;AAAA,MACrB;AAEA,YAAM,eAAe,MAAM,KAAK;AAAA,QAC9B;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAEA,UAAI,EAAC,6CAAc,QAAQ,QAAO,CAAC;AAGnC,YAAM,SAAS,iBAAiB,KAAK,SAAS,OAAO,SAAS,CAAC;AAG/D,YAAM,WAAqB,CAAC;AAC5B,iBAAW,eAAe,cAAc;AACtC,cAAM,SAAiB;AAAA,UACrB,IAAI,iBAAiB,KAAK,SAAS,YAAY,WAAW,SAAS,CAAC;AAAA,UACpE,UAAU,KAAK,QAAQ;AAAA,UACvB,SAAS,KAAK,QAAQ;AAAA,UACtB;AAAA,UACA,SAAS;AAAA,YACP,GAAG;AAAA,YACH,MAAM,YAAY;AAAA,YAClB,QAAQ;AAAA,YACR,aAAa,eAAe;AAAA,cAC1B,IAAI,OAAO,WAAW,WAAW,OAAO,SAAS,QAAQ,EAAE,IAAI;AAAA,cAC/D,MAAM;AAAA;AAAA,YACR,CAAS;AAAA,UACX;AAAA,UACA,WAAW,YAAY,OAAO;AAAA,QAChC;AAEA,cAAM,KAAK,QAAQ,aAAa,QAAQ,UAAU;AAClD,iBAAS,KAAK,MAAM;AAAA,MACtB;AAGA,WAAK,QAAQ,UAAU,UAAU,cAAc;AAAA,QAC7C,SAAS,KAAK;AAAA,QACd,SAAS;AAAA,UACP;AAAA,QACF;AAAA,QACA;AAAA,QACA,QAAQ;AAAA,MACV,CAAC;AAGD,WAAK,QAAQ,sDAA2C;AAAA,QACtD,kBAAkB;AAAA,QAClB;AAAA,MACF,CAA+B;AAE/B,aAAO;AAAA,IACT,SAAS,OAAO;AACd,aAAO,MAAM,sCAAsC,KAAK;AACxD,aAAO,CAAC;AAAA,IACV;AAAA,EACF;AACF;;;AFtgBO,IAAM,kBAAN,MAAM,yBAAwB,QAAQ;AAAA,EAC3C,OAAO,cAAc;AAAA,EACrB,wBAAwB;AAAA,EAChB;AAAA,EACD;AAAA,EACC;AAAA,EACA,aAA+B,oBAAI,IAAI;AAAA,EACvC,kBAA+B,oBAAI,IAAY;AAAA;AAAA;AAAA;AAAA;AAAA,EAMvD,YAAY,SAAwB;AAClC,UAAM,OAAO;AACb,IAAAC,QAAO,IAAI,+CAAwC;AACnD,SAAK,UAAU;AAAA,MACb,UAAU;AAAA,QACR,SACE,QAAQ,WAAW,mBAAmB,KACtC,QAAQ,IAAI,qBACZ;AAAA,MACJ;AAAA,IACF;AACA,UAAM,WAAW,QAAQ,WAAW,oBAAoB;AACxD,SAAK,MAAM,IAAI,SAAS,UAAU,KAAK,OAAO;AAC9C,SAAK,iBAAiB,IAAI,eAAe,KAAK,KAAK,KAAK,OAAO;AAC/D,IAAAA,QAAO,IAAI,8CAAyC;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,aAAa,MAAM,SAAkD;AACnE,UAAM,uBAAuB,OAAO;AAEpC,UAAM,aAAa;AACnB,QAAI,aAAa;AACjB,QAAI,YAA0B;AAE9B,WAAO,aAAa,YAAY;AAC9B,UAAI;AACF,cAAM,UAAU,IAAI,iBAAgB,OAAO;AAE3C,QAAAA,QAAO;AAAA,UACL,6DAAwD,QAAQ,UAAU,IAAI;AAAA,QAChF;AAEA,QAAAA,QAAO,IAAI,oCAA6B;AACxC,cAAM,QAAQ,cAAc;AAG5B,gBAAQ,iBAAiB;AAGzB,gBAAQ,qBAAqB;AAG7B,cAAM,QAAQ,IAAI,SAAS,MAAM;AAEjC,eAAO;AAAA,MACT,SAAS,OAAO;AACd,oBAAY,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,KAAK,CAAC;AACpE,QAAAA,QAAO;AAAA,UACL,mCAAmC,aAAa,CAAC,YAAY,UAAU,OAAO;AAAA,QAChF;AACA;AAEA,YAAI,aAAa,YAAY;AAC3B,gBAAM,QAAQ,KAAK,aAAa;AAChC,UAAAA,QAAO,KAAK,uCAAuC,QAAQ,GAAI,aAAa;AAC5E,gBAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,KAAK,CAAC;AAAA,QAC3D;AAAA,MACF;AAAA,IACF;AAEA,UAAM,IAAI;AAAA,MACR,wCAAwC,UAAU,0BAA0B,uCAAW,OAAO;AAAA,IAChG;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,aAAa,KAAK,SAAwB;AAExC,UAAM,WAAW,QAAQ,WAAW,qBAAqB;AACzD,QAAI,UAAU;AACZ,YAAM,SAAS,KAAK;AAAA,IACtB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,OAAsB;AAC1B,SAAK,IAAI,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAc,gBAA+B;AAC3C,SAAK,IAAI,OAAO;AAAA,MACd,oBAAoB;AAAA,MACpB,gBAAgB,CAAC,WAAW,kBAAkB;AAAA,IAChD,CAAC;AAGD,UAAM,UAAU,MAAM,KAAK,IAAI,SAAS,MAAM;AAC9C,IAAAA,QAAO,IAAI,aAAa,KAAK,UAAU,OAAO,CAAC,EAAE;AAGjD,YAAQ,KAAK,UAAU,MAAM,KAAK,IAAI,KAAK,QAAQ,CAAC;AACpD,YAAQ,KAAK,WAAW,MAAM,KAAK,IAAI,KAAK,SAAS,CAAC;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBQ,mBAAyB;AAE/B,SAAK,IAAI,IAAI,KAAK,wBAAwB,KAAK,IAAI,CAAC;AAGpD,SAAK,IAAI,IAAI,KAAK,wBAAwB,KAAK,IAAI,CAAC;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAc,wBAAwB,KAAc,MAA+B;AACjF,QAAI,CAAE,MAAM,KAAK,kBAAkB,GAAG,GAAI;AAExC,MAAAA,QAAO,MAAM,kDAAkD;AAC/D;AAAA,IACF;AACA,UAAM,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAc,wBAAwB,KAAc,MAA+B;AACjF,QAAI,CAAC,IAAI,KAAM,QAAO,KAAK;AAE3B,UAAM,SAAS,IAAI,KAAK,GAAG,SAAS;AAGpC,QAAI,CAAC,KAAK,WAAW,IAAI,MAAM,GAAG;AAEhC,YAAM,KAAK,cAAc,GAAG;AAE5B,aAAO,KAAK;AAAA,IACd;AAGA,UAAM,KAAK,oBAAoB,GAAG;AAElC,UAAM,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAc,oBAAoB,KAA6B;AAzOjE;AA0OI,QAAI,CAAC,IAAI,KAAM;AAEf,UAAM,OAAO,IAAI;AAGjB,QAAI,KAAK,SAAS,gBAAgB,KAAK,cAAY,SAAI,YAAJ,mBAAa,oBAAmB;AACjF,UAAI;AACF,cAAM,KAAK,iBAAiB,GAAG;AAAA,MACjC,SAAS,OAAO;AACd,QAAAA,QAAO,MAAM,+BAA+B,KAAK,EAAE;AAAA,MACrD;AAAA,IACF;AAGA,QAAI,IAAI,QAAQ,IAAI,KAAK,SAAS,WAAW;AAC3C,YAAM,KAAK,WAAW,GAAG;AAAA,IAC3B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,uBAA6B;AAEnC,SAAK,IAAI,GAAG,WAAW,OAAO,QAAQ;AACpC,UAAI;AAEF,cAAM,KAAK,eAAe,cAAc,GAAG;AAAA,MAC7C,SAAS,OAAO;AACd,QAAAA,QAAO,MAAM,2BAA2B,KAAK;AAAA,MAC/C;AAAA,IACF,CAAC;AAGD,SAAK,IAAI,GAAG,oBAAoB,OAAO,QAAQ;AAC7C,UAAI;AACF,cAAM,KAAK,eAAe,eAAe,GAAG;AAAA,MAC9C,SAAS,OAAO;AACd,QAAAA,QAAO,MAAM,4BAA4B,KAAK;AAAA,MAChD;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAc,kBAAkB,KAAgC;AA7RlE;AA8RI,UAAM,UAAS,SAAI,SAAJ,mBAAU,GAAG;AAC5B,QAAI,CAAC,OAAQ,QAAO;AAEpB,UAAM,eAAe,KAAK,QAAQ,WAAW,wBAAwB;AACrE,QAAI,CAAC,cAAc;AACjB,aAAO;AAAA,IACT;AAEA,QAAI;AACF,YAAM,mBAAmB,KAAK,MAAM,YAAsB;AAC1D,aAAO,iBAAiB,SAAS,MAAM;AAAA,IACzC,SAAS,OAAO;AACd,MAAAA,QAAO,MAAM,yCAAyC,KAAK;AAC3D,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAc,WAAW,KAA6B;AA1TxD;AA2TI,QAAI,CAAC,IAAI,KAAM;AAEf,UAAM,OAAO,IAAI;AACjB,UAAM,SAAS,KAAK,GAAG,SAAS;AAChC,UAAM,UAAUC,kBAAiB,KAAK,SAAS,MAAM;AACrD,UAAM,SAASA;AAAA,MACb,KAAK;AAAA,QACL,SAAI,YAAJ,mBAAa,qBACT,GAAG,IAAI,KAAK,EAAE,IAAI,IAAI,QAAQ,iBAAiB,KAC/C,IAAI,KAAK,GAAG,SAAS;AAAA,IAC3B;AAGA,UAAM,KAAK,kBAAkB,KAAK,SAAS,QAAQ,MAAM;AACzD,UAAM,KAAK,kBAAkB,KAAK,SAAS,QAAQ,MAAM;AACzD,UAAM,KAAK,mBAAmB,GAAG;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAc,kBACZ,KACA,SACA,QACA,QACe;AAEf,QAAI,IAAI,QAAQ,CAAC,KAAK,gBAAgB,IAAI,IAAI,KAAK,GAAG,SAAS,CAAC,GAAG;AACjE,YAAM,aAAa,IAAI,KAAK,GAAG,SAAS;AACxC,YAAM,WAAWA,kBAAiB,KAAK,SAAS,UAAU;AAE1D,YAAM,KAAK,QAAQ,iBAAiB;AAAA,QAClC;AAAA,QACA;AAAA,QACA,UAAU,IAAI,KAAK;AAAA,QACnB,QAAQ;AAAA,QACR,MAAM,IAAI,KAAK,cAAc,IAAI,KAAK,YAAY;AAAA,QAClD,QAAQ;AAAA,QACR,WAAW;AAAA,QACX,UAAU;AAAA,QACV,MAAMC,aAAY;AAAA,QAClB;AAAA,MACF,CAAC;AAED,WAAK,gBAAgB,IAAI,QAAQ;AAAA,IACnC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAc,kBACZ,KACA,SACA,QACA,QACe;AAEf,QAAI,IAAI,WAAW,qBAAqB,IAAI,SAAS;AACnD,YAAM,YAAY,IAAI,QAAQ;AAC9B,YAAM,aAAa,UAAU,GAAG,SAAS;AACzC,YAAM,WAAWD,kBAAiB,KAAK,SAAS,UAAU;AAG1D,UAAI,KAAK,gBAAgB,IAAI,UAAU,EAAG;AAG1C,YAAM,KAAK,QAAQ,iBAAiB;AAAA,QAClC;AAAA,QACA;AAAA,QACA,UAAU,UAAU;AAAA,QACpB,QAAQ;AAAA,QACR,MAAM,UAAU,cAAc,UAAU,YAAY;AAAA,QACpD,QAAQ;AAAA,QACR,WAAW;AAAA,QACX,UAAU;AAAA,QACV,MAAMC,aAAY;AAAA,QAClB;AAAA,MACF,CAAC;AAED,WAAK,gBAAgB,IAAI,QAAQ;AAEjC,WAAK,QAAQ,UAAU,6CAAiC,GAAG;AAAA,QACzD,SAAS,KAAK;AAAA,QACd;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAc,mBAAmB,KAA6B;AAE5D,QAAI,IAAI,WAAW,sBAAsB,IAAI,SAAS;AACpD,YAAM,aAAa,IAAI,QAAQ;AAC/B,YAAM,aAAa,WAAW,GAAG,SAAS;AAC1C,YAAM,WAAWD,kBAAiB,KAAK,SAAS,UAAU;AAE1D,YAAM,iBAAiB,MAAM,KAAK,QAAQ,cAAc,QAAQ;AAChE,UAAI,gBAAgB;AAClB,uBAAe,WAAW;AAAA,UACxB,GAAG,eAAe;AAAA,UAClB,QAAQ;AAAA,UACR,QAAQ,KAAK,IAAI;AAAA,QACnB;AACA,cAAM,KAAK,QAAQ,aAAa,cAAc;AAAA,MAChD;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAc,iBAAiB,KAA6B;AA1c9D;AA2cI,QAAI,CAAC,IAAI,QAAQ,GAAC,SAAI,YAAJ,mBAAa,mBAAmB;AAElD,UAAM,OAAO,IAAI;AACjB,UAAM,SAAS,KAAK,GAAG,SAAS;AAChC,UAAM,UAAUA,kBAAiB,KAAK,SAAS,MAAM;AAErD,UAAM,OAAO,MAAM,KAAK,oBAAoB,KAAK,OAAO;AACxD,QAAI,CAAC,KAAM;AAEX,UAAM,KAAK,QAAQ,iBAAiB,IAAI;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKQ,qBAAqB,MAA0B;AACrD,QAAI,CAAC,KAAM,QAAO;AAElB,UAAM,SAASA,kBAAiB,KAAK,SAAS,KAAK,GAAG,SAAS,CAAC;AAChE,UAAM,aAAa,KAAK,GAAG,SAAS;AAEpC,WAAO;AAAA,MACL,IAAI;AAAA,MACJ,SAAS,KAAK,QAAQ;AAAA,MACtB,OAAO,CAAC,KAAK,cAAc,KAAK,YAAY,cAAc;AAAA,MAC1D,UAAU;AAAA,QACR,UAAU;AAAA,UACR,IAAI;AAAA,UACJ,UAAU,KAAK;AAAA,UACf,MAAM,KAAK,cAAc,KAAK,YAAY;AAAA,QAC5C;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAc,cAAc,KAA6B;AAvf3D;AAwfI,QAAI,CAAC,IAAI,KAAM;AAEf,UAAM,OAAO,IAAI;AACjB,UAAM,SAAS,KAAK,GAAG,SAAS;AAGhC,SAAK,WAAW,IAAI,QAAQ,IAAI;AAGhC,UAAM,EAAE,WAAW,YAAY,IAAI,KAAK,gBAAgB,IAAI;AAE5D,UAAM,UAAUA,kBAAiB,KAAK,SAAS,MAAM;AAErD,UAAM,gBAAgB,MAAM,KAAK,QAAQ,SAAS,OAAO;AACzD,QAAI,eAAe;AACjB;AAAA,IACF;AAEA,UAAM,SAAS,IAAI,OACdA,kBAAiB,KAAK,SAAS,IAAI,KAAK,GAAG,SAAS,CAAC,IACtD;AAGJ,QAAI,SAAS,CAAC;AACd,QAAI,QAAQ;AACZ,QAAI,KAAK,SAAS,WAAW,KAAK,SAAS,gBAAgB,KAAK,SAAS,WAAW;AAClF,UAAI;AACF,iBAAS,MAAM,IAAI,sBAAsB;AACzC,gBAAQ,OAAO,KAAK,CAAC,UAAU,MAAM,WAAW,SAAS;AAAA,MAC3D,SAAS,OAAO;AACd,QAAAD,QAAO,KAAK,sCAAsC,MAAM,OAAO,EAAE;AAAA,MACnE;AAAA,IACF;AAEA,QAAI,UAAU;AAEd,QAAI,OAAO;AACT,gBAAUC,kBAAiB,KAAK,SAAS,OAAO,MAAM,KAAK,EAAE,CAAC;AAAA,IAChE;AAGA,UAAM,QAAe;AAAA,MACnB,IAAI;AAAA,MACJ,MAAM;AAAA,MACN,SAAS,KAAK,QAAQ;AAAA,MACtB,UAAU;AAAA,MACV,UAAU;AAAA,QACR,QAAQ;AAAA,QACR,WAAW,EAAE,QAAQ;AAAA,QACrB,OAAO,UACH;AAAA,UACE,CAAC,OAAO,GAAG,KAAK;AAAA,QAClB,IACA,CAAC;AAAA,QACL,UAAU,KAAK;AAAA,QACf,gBAAgB,KAAK,SAAS,gBAAgB,KAAK;AAAA,MACrD;AAAA,IACF;AAGA,UAAM,KAAK,QAAQ,kBAAkB,KAAK;AAG1C,UAAM,cAAoB;AAAA,MACxB,IAAIA,kBAAiB,KAAK,SAAS,MAAM;AAAA,MACzC,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,WAAW;AAAA,MACX,UAAU;AAAA,MACV;AAAA,IACF;AAGA,UAAM,KAAK,QAAQ,iBAAiB,WAAW;AAG/C,UAAM,QAAQ,CAAC,WAAW;AAG1B,QAAI,KAAK,SAAS,gBAAgB,KAAK,cAAY,SAAI,YAAJ,mBAAa,oBAAmB;AACjF,YAAM,YAAY,MAAM,KAAK,oBAAoB,KAAK,OAAO;AAC7D,UAAI,WAAW;AACb,cAAM,KAAK,SAAS;AAAA,MACtB;AACA,YAAM,KAAK,QAAQ,iBAAiB,SAAS;AAAA,IAC/C;AAGA,UAAM,WAAW,MAAM,KAAK,0BAA0B,IAAI;AAG1D,QAAI,IAAI,MAAM;AACZ,YAAM,eAAe,KAAK,qBAAqB,IAAI,IAAI;AACvD,UAAI,gBAAgB,CAAC,SAAS,KAAK,CAAC,MAAM,EAAE,OAAO,aAAa,EAAE,GAAG;AACnE,iBAAS,KAAK,YAAY;AAC1B,aAAK,gBAAgB,IAAI,aAAa,EAAE;AAAA,MAC1C;AAAA,IACF;AAGA,UAAM,KAAK;AAAA,MACT;AAAA,MACA,YAAY;AAAA,MACZ,YAAY;AAAA,MACZ,YAAY;AAAA,MACZ,YAAY;AAAA,MACZ;AAAA,IACF;AAGA,UAAM,uBAA6C;AAAA,MACjD,SAAS,KAAK;AAAA,MACd;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAQ;AAAA,MACR;AAAA,MACA,aAAa,KAAK,IAAI,QAAQ;AAAA,IAChC;AAGA,QAAI,KAAK,SAAS,WAAW;AAC3B,YAAM,KAAK,QAAQ,sDAA2C,oBAAoB;AAAA,IACpF;AAGA,UAAM,KAAK,QAAQ,UAAUE,WAAU,cAAc;AAAA,MACnD,SAAS,KAAK;AAAA,MACd;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAQ;AAAA,IACV,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,MAAc,qBACZ,UACA,QACA,WACA,UACA,UACA,SACe;AACf,UAAM,YAAY;AAElB,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK,WAAW;AACnD,YAAM,cAAc,SAAS,MAAM,GAAG,IAAI,SAAS;AAGnD,YAAM,QAAQ;AAAA,QACZ,YAAY,IAAI,OAAO,WAAmB;AA3pBlD;AA4pBU,cAAI;AACF,kBAAM,KAAK,QAAQ,iBAAiB;AAAA,cAClC,UAAU,OAAO;AAAA,cACjB;AAAA,cACA,WAAU,kBAAO,aAAP,mBAAiB,aAAjB,mBAA2B;AAAA,cACrC,OAAM,kBAAO,aAAP,mBAAiB,aAAjB,mBAA2B;AAAA,cACjC,SAAQ,kBAAO,aAAP,mBAAiB,aAAjB,mBAA2B;AAAA,cACnC,QAAQ;AAAA,cACR;AAAA,cACA;AAAA,cACA,MAAM;AAAA,cACN;AAAA,YACF,CAAC;AAAA,UACH,SAAS,KAAK;AACZ,YAAAH,QAAO,KAAK,wBAAuB,kBAAO,aAAP,mBAAiB,aAAjB,mBAA2B,QAAQ,KAAK,GAAG,EAAE;AAAA,UAClF;AAAA,QACF,CAAC;AAAA,MACH;AAGA,UAAI,IAAI,YAAY,SAAS,QAAQ;AACnC,cAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,GAAG,CAAC;AAAA,MACzD;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUQ,gBAAgB,MAA4D;AAClF,QAAI;AACJ,QAAI;AAEJ,YAAQ,KAAK,MAAM;AAAA,MACjB,KAAK;AACH,oBAAY,aAAa,KAAK,cAAc,cAAc;AAC1D,sBAAcE,aAAY;AAC1B;AAAA,MACF,KAAK;AACH,oBAAY,KAAK,SAAS;AAC1B,sBAAcA,aAAY;AAC1B;AAAA,MACF,KAAK;AACH,oBAAY,KAAK,SAAS;AAC1B,sBAAcA,aAAY;AAC1B;AAAA,MACF,KAAK;AACH,oBAAY,KAAK,SAAS;AAC1B,sBAAcA,aAAY;AAC1B;AAAA,MACF;AACE,oBAAY;AACZ,sBAAcA,aAAY;AAAA,IAC9B;AAEA,WAAO,EAAE,WAAW,YAAY;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAc,0BAA0B,MAA8B;AACpE,UAAM,WAAqB,CAAC;AAE5B,QAAI;AAEF,UAAI,KAAK,SAAS,aAAa,KAAK,IAAI;AACtC,cAAM,SAASD,kBAAiB,KAAK,SAAS,KAAK,GAAG,SAAS,CAAC;AAChE,iBAAS,KAAK;AAAA,UACZ,IAAI;AAAA,UACJ,OAAO,CAAC,KAAK,cAAc,cAAc;AAAA,UACzC,SAAS,KAAK,QAAQ;AAAA,UACtB,UAAU;AAAA,YACR,UAAU;AAAA,cACR,IAAI,KAAK,GAAG,SAAS;AAAA,cACrB,UAAU,KAAK,YAAY;AAAA,cAC3B,MAAM,KAAK,cAAc;AAAA,YAC3B;AAAA,YACA,QAAQ;AAAA,UACV;AAAA,QACF,CAAC;AACD,aAAK,gBAAgB,IAAI,MAAM;AAAA,MACjC,WAAW,KAAK,SAAS,WAAW,KAAK,SAAS,cAAc;AAE9D,YAAI;AAEF,gBAAM,SAAS,MAAM,KAAK,IAAI,SAAS,sBAAsB,KAAK,EAAE;AAEpE,cAAI,UAAU,OAAO,SAAS,GAAG;AAC/B,uBAAW,SAAS,QAAQ;AAC1B,oBAAM,SAASA,kBAAiB,KAAK,SAAS,MAAM,KAAK,GAAG,SAAS,CAAC;AACtE,uBAAS,KAAK;AAAA,gBACZ,IAAI;AAAA,gBACJ,OAAO,CAAC,MAAM,KAAK,cAAc,MAAM,KAAK,YAAY,eAAe;AAAA,gBACvE,SAAS,KAAK,QAAQ;AAAA,gBACtB,UAAU;AAAA,kBACR,UAAU;AAAA,oBACR,IAAI,MAAM,KAAK,GAAG,SAAS;AAAA,oBAC3B,UAAU,MAAM,KAAK,YAAY;AAAA,oBACjC,MAAM,MAAM,KAAK,cAAc;AAAA,oBAC/B,SAAS;AAAA,oBACT,YACE,MAAM,iBAAiB,MAAM,WAAW,YAAY,UAAU;AAAA,kBAClE;AAAA,kBACA,QAAQ;AAAA,kBACR,OAAO,CAAC,MAAM,WAAW,YAAY,KAAK,QAAQ,KAAK,KAAK;AAAA,gBAC9D;AAAA,cACF,CAAC;AACD,mBAAK,gBAAgB,IAAI,MAAM;AAAA,YACjC;AAAA,UACF;AAAA,QACF,SAAS,OAAO;AACd,UAAAD,QAAO,KAAK,2CAA2C,KAAK,EAAE,KAAK,KAAK,EAAE;AAAA,QAC5E;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,MAAAA,QAAO;AAAA,QACL,yCAAyC,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,MACjG;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAc,oBAAoB,KAAc,SAAqC;AA3yBvF;AA4yBI,QAAI,CAAC,IAAI,QAAQ,GAAC,SAAI,YAAJ,mBAAa,mBAAmB,QAAO;AACzD,QAAI,IAAI,KAAK,SAAS,gBAAgB,CAAC,IAAI,KAAK,SAAU,QAAO;AAEjE,UAAM,OAAO,IAAI;AACjB,UAAM,SAAS,KAAK,GAAG,SAAS;AAChC,UAAM,WAAW,IAAI,QAAQ,kBAAkB,SAAS;AACxD,UAAM,SAASC,kBAAiB,KAAK,SAAS,GAAG,MAAM,IAAI,QAAQ,EAAE;AAErE,QAAI;AAEF,YAAM,eAAe,KAAK,MAAM,KAAK,UAAU,IAAI,OAAO,CAAC;AAG3D,UAAI,YAAY,UAAU,QAAQ;AAGlC,UACE,gBACA,OAAO,iBAAiB,YACxB,yBAAyB,gBACzB,aAAa,qBACb;AACA,cAAM,eAAe,aAAa;AAClC,YAAI,gBAAgB,OAAO,iBAAiB,YAAY,UAAU,cAAc;AAC9E,sBAAY,aAAa;AAAA,QAC3B;AAAA,MACF,WAGE,gBACA,OAAO,iBAAiB,YACxB,sBAAsB,gBACtB,aAAa,oBACb,OAAO,aAAa,qBAAqB,YACzC,yBAAyB,aAAa,oBACtC,aAAa,iBAAiB,qBAC9B;AACA,cAAM,eAAe,aAAa,iBAAiB;AACnD,YAAI,gBAAgB,OAAO,iBAAiB,YAAY,UAAU,cAAc;AAC9E,sBAAY,aAAa;AAAA,QAC3B;AAAA,MACF;AAGA,YAAM,OAAa;AAAA,QACjB,IAAI;AAAA,QACJ,MAAM;AAAA,QACN,QAAQ;AAAA,QACR,MAAMC,aAAY;AAAA,QAClB,WAAW,GAAG,MAAM,IAAI,QAAQ;AAAA,QAChC,UAAU;AAAA,QACV;AAAA,QACA,UAAU;AAAA,UACR;AAAA,UACA,cAAc;AAAA,UACd,cAAc;AAAA,QAChB;AAAA,MACF;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,MAAAF,QAAO;AAAA,QACL,oCAAoC,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,MAC5F;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;;;AI/2BA,SAA6C,UAAAI,eAAc;AAO3D,IAAM,iBACJ;AAaK,IAAM,oBAAN,MAA6C;AAAA,EAClD,OAAO;AAAA,EACC,iBAAkC;AAAA,EAClC,MAAgC;AAAA,EAChC,iBAAwC;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,cAAc;AACZ,SAAK,QAAQ;AAAA,MACX;AAAA,QACE,MAAM;AAAA,QACN,IAAI,KAAK,wBAAwB,KAAK,IAAI;AAAA,MAC5C;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,IAAI,KAAK,uBAAuB,KAAK,IAAI;AAAA,MAC3C;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,IAAI,KAAK,iCAAiC,KAAK,IAAI;AAAA,MACrD;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,IAAI,KAAK,oBAAoB,KAAK,IAAI;AAAA,MACxC;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,IAAI,KAAK,qBAAqB,KAAK,IAAI;AAAA,MACzC;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,eAAe,SAAwB;AACrC,UAAM,aACJ,QAAQ,WAAW,uBAAuB,KAAK,QAAQ,IAAI;AAC7D,QAAI,CAAC,YAAY;AACf,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,YAAY,SAAkD;AAClE,QAAI;AACF,YAAM,SAAS,KAAK,eAAe,OAAO;AAC1C,YAAM,OAAO,MAAM,KAAK,IAAI,SAAS,QAAQ,MAAM;AACnD,MAAAA,QAAO,IAAI,sBAAsB,KAAK,UAAU,IAAI,CAAC,EAAE;AACvD,aAAO;AAAA,IACT,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,sCAAsC,KAAK,EAAE;AAAA,IAC/D;AAAA,EACF;AAAA,EAEA,MAAM,wBAAwB,SAAwB;AACpD,SAAK,iBAAiB,QAAQ,WAAW,UAAU;AACnD,SAAK,MAAM,KAAK,eAAe,eAAe;AAC9C,SAAK,iBAAiB,KAAK,eAAe;AAC1C,IAAAA,QAAO,MAAM,wCAAwC;AAAA,EACvD;AAAA,EAEA,MAAM,uBAAuB,SAAwB;AACnD,QAAI;AACF,UAAI,CAAC,KAAK,IAAK,OAAM,IAAI,MAAM,sBAAsB;AAErD,YAAM,SAAS,KAAK,eAAe,OAAO;AAC1C,YAAM,KAAK,IAAI,SAAS,YAAY,QAAQ,2BAA2B;AACvE,MAAAA,QAAO,MAAM,4BAA4B;AAAA,IAC3C,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,mCAAmC,KAAK,EAAE;AAAA,IAC5D;AAAA,EACF;AAAA,EAEA,MAAM,iCAAiC,SAAwB;AAC7D,QAAI;AACF,UAAI,CAAC,KAAK,eAAgB,OAAM,IAAI,MAAM,iCAAiC;AAE3E,YAAM,OAAO,MAAM,KAAK,YAAY,OAAO;AAC3C,YAAM,cAAgC;AAAA,QACpC;AAAA,QACA,MAAM,EAAE,IAAI,KAAK,UAAU,WAAW;AAAA,QACtC,UAAU,KAAK,IAAI;AAAA,MACrB;AAEA,YAAM,iBAAiB;AAAA,QACrB,MAAM;AAAA,QACN,aAAa;AAAA,UACX;AAAA,YACE,IAAI;AAAA,YACJ,OAAO;AAAA,YACP,QAAQ;AAAA,YACR,MAAM;AAAA,YACN,KAAK;AAAA,YACL,aAAa;AAAA,YACb,aAAa;AAAA,UACf;AAAA,QACF;AAAA,MACF;AAEA,YAAM,KAAK,eAAe,oBAAoB,aAAwB,cAAc;AAEpF,MAAAA,QAAO,QAAQ,kDAAkD;AAAA,IACnE,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,mDAAmD,KAAK,EAAE;AAAA,IAC5E;AAAA,EACF;AAAA,EAEA,MAAM,oBAAoB,SAAwB;AArJpD;AAsJI,QAAI;AACF,YAAM,OAAO,MAAM,KAAK,YAAY,OAAO;AAC3C,YAAM,cAAgC;AAAA,QACpC;AAAA,QACA,MAAM;AAAA,UACJ,IAAI;AAAA,UACJ,UAAU;AAAA,UACV,QAAQ;AAAA,UACR,YAAY;AAAA,UACZ,WAAW;AAAA,QACb;AAAA,QACA,SAAS;AAAA,UACP,YAAY;AAAA,UACZ,MAAM,KAAI,UAAK,IAAI,YAAT,mBAAkB,QAAQ;AAAA,UACpC,MAAM,KAAK,MAAM,KAAK,IAAI,IAAI,GAAI;AAAA,UAClC;AAAA,QACF;AAAA,QACA,UAAU,KAAK,IAAI;AAAA,MACrB;AAEA,UAAI;AACF,cAAM,KAAK,eAAe,cAAc,WAAsB;AAAA,MAChE,SAAS,OAAO;AACd,cAAM,IAAI,MAAM,oCAAoC,KAAK,EAAE;AAAA,MAC7D;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,oCAAoC,KAAK,EAAE;AAAA,IAC7D;AAAA,EACF;AAAA,EAEA,MAAM,qBAAqB,SAAwB;AApLrD;AAqLI,QAAI;AACF,YAAM,SAAS,KAAK,eAAe,OAAO;AAC1C,YAAM,SAAS,MAAM,KAAK,UAAU,QAAQ,cAAc;AAE1D,YAAM,cAAc;AAAA,QAClB,YAAY;AAAA,QACZ,MAAM,EAAE,IAAI,OAAO;AAAA,QACnB,MAAM,KAAK,MAAM,KAAK,IAAI,IAAI,GAAI;AAAA,QAClC,OAAO,CAAC,EAAE,SAAS,OAAO,CAAC;AAAA,QAC3B,MAAM,KAAI,UAAK,IAAI,YAAT,mBAAkB,QAAQ;AAAA,MACtC;AAEA,YAAM,EAAE,YAAY,IAAI,MAAM,KAAK,eAAe,aAAa,WAAW;AAC1E,UAAI,CAAC,aAAa;AAChB,cAAM,IAAI,MAAM,iCAAiC;AAAA,MACnD;AACA,MAAAA,QAAO,IAAI,2CAA2C,WAAW,EAAE;AAAA,IACrE,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,oCAAoC,KAAK,EAAE;AAAA,IAC7D;AAAA,EACF;AAAA,EAEA,MAAM,UAAU,QAAgB,UAAkB;AAChD,QAAI;AACF,YAAM,UAAU,MAAM,KAAK,IAAI,SAAS,UAAU,QAAQ,QAAQ;AAClE,aAAO,QAAQ,MAAM,QAAQ,MAAM,SAAS,CAAC,EAAE;AAAA,IACjD,SAAS,OAAO;AACd,MAAAA,QAAO,MAAM,wBAAwB,KAAK,EAAE;AAC5C,YAAM;AAAA,IACR;AAAA,EACF;AACF;;;AC/MA,IAAM,iBAAyB;AAAA,EAC7B,MAAM;AAAA,EACN,aAAa;AAAA,EACb,UAAU,CAAC,eAAe;AAAA,EAC1B,OAAO,CAAC,IAAI,kBAAkB,CAAC;AACjC;AACA,IAAO,gBAAQ;","names":["ChannelType","EventType","createUniqueUuid","logger","Markup","Markup","logger","createUniqueUuid","ChannelType","EventType","logger"]}