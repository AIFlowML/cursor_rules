---
description: "AGNO step creation patterns, naming conventions, and step organization best practices for maintainable workflows"

alwaysApply: false
---

> You are an expert in AGNO Workflows 2.0 step creation and organization. You design well-structured, maintainable workflows with clear step definitions, intuitive naming patterns, and optimal step organization for complex multi-step processes.

## Step Creation and Naming Patterns

```
┌─────────────────────┐    ┌──────────────────────┐    ┌─────────────────────┐
│   Step Definition   │───▶│   Naming Convention   │───▶│  Step Organization  │
│                     │    │                      │    │                     │
│ • Step Constructor  │    │ • Descriptive Names  │    │ • Logical Grouping  │
│ • Executor Types    │    │ • Consistent Patterns│    │ • Sequential Flow   │
│ • Descriptions      │    │ • Action-Oriented    │    │ • Reusable Components│
│ • Metadata Config   │    │ • Context-Aware      │    │ • Maintainable Code │
└─────────────────────┘    └──────────────────────┘    └─────────────────────┘
```

## Instant Step Patterns

### Quick Start - Basic Step Creation

```python
from agno.agent import Agent
from agno.models.openai import OpenAIChat
from agno.workflow.v2.step import Step
from agno.workflow.v2.workflow import Workflow

# Define agent for step
research_agent = Agent(
    name="Research Specialist",
    model=OpenAIChat(id="gpt-4o-mini"),
    role="Conduct thorough research and analysis"
)

# Create step with clear naming and description
research_step = Step(
    name="initial_market_research",  # Clear, descriptive name
    agent=research_agent,
    description="Conduct comprehensive initial market research and competitive analysis"
)

# Create step with custom function
def data_processing_function(step_input):
    """Process and structure research data"""
    # Processing logic here
    return step_input

processing_step = Step(
    name="data_structure_and_validation",
    executor=data_processing_function,
    description="Structure and validate research data for analysis pipeline"
)

# Simple workflow with well-named steps
research_workflow = Workflow(
    name="Market Research Pipeline",
    description="Structured market research with data processing",
    steps=[research_step, processing_step]
)

research_workflow.run("AI startups in healthcare sector")
```

### Production Ready - Advanced Step Organization

```python
from agno.agent import Agent
from agno.models.openai import OpenAIChat
from agno.team import Team
from agno.tools.duckduckgo import DuckDuckGoTools
from agno.workflow.v2.step import Step, StepInput, StepOutput
from agno.workflow.v2.workflow import Workflow
from agno.storage.sqlite import SqliteStorage
from typing import List, Dict, Any
import logging

# Configure logging for step tracking
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Define specialized agents with clear roles
primary_researcher = Agent(
    name="Primary Market Researcher",
    model=OpenAIChat(id="gpt-4o"),
    tools=[DuckDuckGoTools()],
    role="Lead comprehensive market research and data collection",
    instructions=[
        "Focus on quantitative market data and industry reports",
        "Identify key market trends and growth indicators",
        "Analyze competitive landscape and market positioning"
    ]
)

competitive_analyst = Agent(
    name="Competitive Intelligence Analyst",
    model=OpenAIChat(id="gpt-4o-mini"),
    role="Analyze competitive landscape and market positioning",
    instructions=[
        "Identify key competitors and market players",
        "Analyze competitive strategies and positioning",
        "Assess competitive advantages and weaknesses"
    ]
)

financial_analyst = Agent(
    name="Financial Market Analyst",
    model=OpenAIChat(id="gpt-4o"),
    role="Analyze financial aspects and market valuation",
    instructions=[
        "Analyze market size and revenue potential",
        "Assess financial trends and funding patterns",
        "Evaluate business model viability and scalability"
    ]
)

strategic_synthesizer = Agent(
    name="Strategic Synthesis Expert",
    model=OpenAIChat(id="gpt-4o"),
    role="Synthesize research into strategic insights and recommendations",
    instructions=[
        "Integrate findings from all research phases",
        "Identify strategic opportunities and risks",
        "Develop actionable business recommendations"
    ]
)

# Define team for collaborative analysis
research_team = Team(
    name="Market Intelligence Team",
    mode="coordinate",
    members=[primary_researcher, competitive_analyst],
    instructions="Collaborate on comprehensive market intelligence gathering"
)

class StepFactory:
    """Factory class for creating well-structured workflow steps"""

    @staticmethod
    def create_research_step(
        step_name: str,
        agent_or_team,
        research_focus: str,
        step_description: str = None
    ) -> Step:
        """Create standardized research step with consistent naming"""

        # Generate description if not provided
        if not step_description:
            step_description = f"Execute {research_focus} research using {type(agent_or_team).__name__.lower()}"

        # Create step with metadata
        step = Step(
            name=step_name,
            agent=agent_or_team if hasattr(agent_or_team, 'run') and not hasattr(agent_or_team, 'members') else None,
            team=agent_or_team if hasattr(agent_or_team, 'members') else None,
            description=step_description
        )

        logger.info(f"Created research step: {step_name} - {step_description}")
        return step

    @staticmethod
    def create_processing_step(
        step_name: str,
        processor_function,
        processing_type: str,
        step_description: str = None
    ) -> Step:
        """Create standardized processing step with consistent naming"""

        if not step_description:
            step_description = f"Execute {processing_type} processing with custom logic"

        step = Step(
            name=step_name,
            executor=processor_function,
            description=step_description
        )

        logger.info(f"Created processing step: {step_name} - {step_description}")
        return step

    @staticmethod
    def create_analysis_step(
        step_name: str,
        analyst_agent: Agent,
        analysis_type: str,
        step_description: str = None
    ) -> Step:
        """Create standardized analysis step with consistent naming"""

        if not step_description:
            step_description = f"Perform {analysis_type} analysis using specialized analyst"

        step = Step(
            name=step_name,
            agent=analyst_agent,
            description=step_description
        )

        logger.info(f"Created analysis step: {step_name} - {step_description}")
        return step

# Define custom processing functions with clear naming
def initial_data_collection_processor(step_input: StepInput) -> StepOutput:
    """
    Initial data collection and preprocessing

    Naming Convention: [phase]_[data_type]_[action]_[processor/function]
    """
    try:
        logger.info("Executing initial data collection processing")

        # Extract and validate input
        research_topic = step_input.message
        context_data = step_input.previous_step_content

        # Data collection logic
        collection_metadata = {
            "topic": research_topic,
            "context_available": bool(context_data),
            "context_length": len(context_data) if context_data else 0,
            "processing_stage": "initial_collection"
        }

        # Prepare structured input for next stage
        structured_research_prompt = f"""
        MARKET RESEARCH DATA COLLECTION:

        Research Topic: {research_topic}
        Context: {context_data[:300] if context_data else "No previous context"}

        Collection Requirements:
        1. Market size and growth projections
        2. Key market segments and demographics
        3. Industry trends and driving factors
        4. Regulatory environment and constraints
        5. Technology adoption patterns

        Provide comprehensive market data collection results.
        """

        # Execute data collection with research team
        collection_result = research_team.run(structured_research_prompt)

        # Structure output with metadata
        processed_output = f"""
        # Initial Data Collection Results

        **Collection Metadata**
        - Research Topic: {research_topic}
        - Processing Stage: Initial Collection
        - Team Coordination: ✓ Market Intelligence Team
        - Data Structure: Enhanced for analysis pipeline

        ## Collected Market Data
        {collection_result.content}

        ## Collection Quality Metrics
        - Data Sources: Multiple validated sources
        - Coverage: Comprehensive market dimensions
        - Reliability: High-confidence data points
        - Processing Status: Ready for competitive analysis
        """

        return StepOutput(
            content=processed_output,
            response=collection_result,
            metadata=collection_metadata
        )

    except Exception as e:
        logger.error(f"Initial data collection failed: {e}")
        return StepOutput(
            content=f"Data collection processing failed: {str(e)}",
            success=False,
            error=str(e)
        )

def competitive_landscape_analyzer(step_input: StepInput) -> StepOutput:
    """
    Competitive landscape analysis and market positioning

    Naming Convention: [analysis_type]_[domain]_[analyzer/processor]
    """
    try:
        logger.info("Executing competitive landscape analysis")

        research_topic = step_input.message
        market_data = step_input.previous_step_content or ""

        # Competitive analysis prompt
        competitive_analysis_prompt = f"""
        COMPETITIVE LANDSCAPE ANALYSIS:

        Market Focus: {research_topic}
        Market Data Context: {market_data[:500]}...

        Competitive Analysis Framework:
        1. Identify top 5-10 key competitors
        2. Analyze competitive positioning and differentiation
        3. Assess market share and competitive dynamics
        4. Evaluate competitive strengths and weaknesses
        5. Identify competitive gaps and opportunities

        Provide structured competitive intelligence report.
        """

        # Execute analysis
        competitive_result = competitive_analyst.run(competitive_analysis_prompt)

        # Structure competitive analysis output
        analysis_output = f"""
        # Competitive Landscape Analysis

        **Analysis Metadata**
        - Market Focus: {research_topic}
        - Analysis Type: Competitive Intelligence
        - Analyst: {competitive_analyst.name}
        - Data Integration: ✓ Market data integrated

        ## Competitive Intelligence Report
        {competitive_result.content}

        ## Analysis Quality Indicators
        - Competitor Coverage: Comprehensive top-tier analysis
        - Market Position Mapping: Complete competitive positioning
        - Gap Analysis: Strategic opportunities identified
        - Processing Status: Ready for financial analysis
        """

        return StepOutput(
            content=analysis_output,
            response=competitive_result,
            metadata={
                "analysis_type": "competitive_landscape",
                "analyst": competitive_analyst.name,
                "market_focus": research_topic,
                "processing_stage": "competitive_analysis"
            }
        )

    except Exception as e:
        logger.error(f"Competitive analysis failed: {e}")
        return StepOutput(
            content=f"Competitive landscape analysis failed: {str(e)}",
            success=False,
            error=str(e)
        )

def financial_viability_assessor(step_input: StepInput) -> StepOutput:
    """
    Financial viability assessment and market valuation

    Naming Convention: [assessment_type]_[domain]_[assessor/evaluator]
    """
    try:
        logger.info("Executing financial viability assessment")

        research_topic = step_input.message
        combined_analysis = step_input.previous_step_content or ""

        # Financial analysis prompt
        financial_assessment_prompt = f"""
        FINANCIAL VIABILITY ASSESSMENT:

        Market Opportunity: {research_topic}
        Market & Competitive Context: {combined_analysis[:800]}...

        Financial Assessment Framework:
        1. Market size and revenue potential analysis
        2. Business model viability assessment
        3. Financial trends and funding landscape
        4. Cost structure and profitability analysis
        5. Investment requirements and ROI projections

        Provide comprehensive financial viability assessment.
        """

        # Execute financial analysis
        financial_result = financial_analyst.run(financial_assessment_prompt)

        # Structure financial assessment output
        assessment_output = f"""
        # Financial Viability Assessment

        **Assessment Metadata**
        - Market Opportunity: {research_topic}
        - Assessment Type: Financial Viability
        - Analyst: {financial_analyst.name}
        - Context Integration: ✓ Market and competitive data integrated

        ## Financial Viability Report
        {financial_result.content}

        ## Assessment Quality Metrics
        - Revenue Analysis: Comprehensive market sizing
        - Viability Scoring: Multi-factor assessment
        - Risk Evaluation: Financial and market risks identified
        - Processing Status: Ready for strategic synthesis
        """

        return StepOutput(
            content=assessment_output,
            response=financial_result,
            metadata={
                "assessment_type": "financial_viability",
                "analyst": financial_analyst.name,
                "market_opportunity": research_topic,
                "processing_stage": "financial_assessment"
            }
        )

    except Exception as e:
        logger.error(f"Financial assessment failed: {e}")
        return StepOutput(
            content=f"Financial viability assessment failed: {str(e)}",
            success=False,
            error=str(e)
        )

def strategic_synthesis_orchestrator(step_input: StepInput) -> StepOutput:
    """
    Strategic synthesis and final recommendations

    Naming Convention: [output_type]_[synthesis/orchestrator]_[coordinator]
    """
    try:
        logger.info("Executing strategic synthesis orchestration")

        research_topic = step_input.message
        comprehensive_analysis = step_input.previous_step_content or ""

        # Strategic synthesis prompt
        synthesis_prompt = f"""
        STRATEGIC SYNTHESIS AND RECOMMENDATIONS:

        Research Focus: {research_topic}

        Comprehensive Analysis Input:
        {comprehensive_analysis[:1200]}...

        Strategic Synthesis Requirements:
        1. Integrate all research dimensions (market, competitive, financial)
        2. Identify key strategic insights and patterns
        3. Develop prioritized strategic recommendations
        4. Create actionable implementation roadmap
        5. Assess overall market opportunity rating

        Deliverable: Executive-ready strategic synthesis with clear recommendations.
        """

        # Execute strategic synthesis
        synthesis_result = strategic_synthesizer.run(synthesis_prompt)

        # Create final comprehensive output
        final_output = f"""
        # Strategic Market Analysis - Executive Summary

        **Synthesis Metadata**
        - Research Focus: {research_topic}
        - Synthesis Type: Multi-dimensional Strategic Analysis
        - Synthesizer: {strategic_synthesizer.name}
        - Analysis Integration: ✓ Complete research pipeline

        ## Executive Strategic Synthesis
        {synthesis_result.content}

        ## Research Pipeline Summary
        - **Phase 1**: Initial Data Collection ✓
        - **Phase 2**: Competitive Landscape Analysis ✓
        - **Phase 3**: Financial Viability Assessment ✓
        - **Phase 4**: Strategic Synthesis ✓

        ## Quality Assurance Metrics
        - Research Depth: Comprehensive multi-phase analysis
        - Data Integration: Complete cross-phase synthesis
        - Strategic Value: Executive-ready recommendations
        - Pipeline Status: Successfully completed
        """

        return StepOutput(
            content=final_output,
            response=synthesis_result,
            metadata={
                "synthesis_type": "strategic_comprehensive",
                "synthesizer": strategic_synthesizer.name,
                "research_focus": research_topic,
                "processing_stage": "final_synthesis",
                "pipeline_completion": True
            }
        )

    except Exception as e:
        logger.error(f"Strategic synthesis failed: {e}")
        return StepOutput(
            content=f"Strategic synthesis orchestration failed: {str(e)}",
            success=False,
            error=str(e)
        )

# Create workflow steps using factory and naming conventions
step_factory = StepFactory()

# Phase 1: Data Collection Steps
initial_data_collection = step_factory.create_processing_step(
    step_name="phase1_market_data_collection_processor",
    processor_function=initial_data_collection_processor,
    processing_type="initial market data collection",
    step_description="Collect and structure initial market research data using team coordination"
)

# Phase 2: Competitive Analysis Steps
competitive_analysis = step_factory.create_processing_step(
    step_name="phase2_competitive_landscape_analyzer",
    processor_function=competitive_landscape_analyzer,
    processing_type="competitive landscape analysis",
    step_description="Analyze competitive landscape and market positioning dynamics"
)

# Phase 3: Financial Assessment Steps
financial_assessment = step_factory.create_processing_step(
    step_name="phase3_financial_viability_assessor",
    processor_function=financial_viability_assessor,
    processing_type="financial viability assessment",
    step_description="Assess financial viability and market opportunity value"
)

# Phase 4: Strategic Synthesis Steps
strategic_synthesis = step_factory.create_processing_step(
    step_name="phase4_strategic_synthesis_orchestrator",
    processor_function=strategic_synthesis_orchestrator,
    processing_type="strategic synthesis orchestration",
    step_description="Orchestrate comprehensive strategic synthesis and final recommendations"
)

# Create production workflow with comprehensive step organization
comprehensive_research_workflow = Workflow(
    name="Comprehensive Market Research Pipeline",
    description="Multi-phase market research workflow with strategic synthesis",
    storage=SqliteStorage(
        table_name="comprehensive_research",
        db_file="comprehensive_research.db",
        mode="workflow_v2"
    ),
    steps=[
        initial_data_collection,      # Phase 1: Data Collection
        competitive_analysis,         # Phase 2: Competitive Analysis
        financial_assessment,         # Phase 3: Financial Assessment
        strategic_synthesis          # Phase 4: Strategic Synthesis
    ]
)

# Execute with comprehensive monitoring
if __name__ == "__main__":
    try:
        logger.info("Starting comprehensive market research workflow")

        result = comprehensive_research_workflow.run(
            message="AI-powered personalized learning platforms for K-12 education",
            stream=False
        )

        print("Comprehensive research workflow completed successfully")
        logger.info("All workflow phases completed successfully")

        # Print step execution summary
        step_names = [step.name for step in comprehensive_research_workflow.steps]
        print(f"Executed steps: {' → '.join(step_names)}")

    except Exception as e:
        logger.error(f"Comprehensive workflow execution failed: {e}")
        print(f"Workflow failed: {e}")
```

## Advanced Step Organization Patterns

### Step Naming Conventions

```python
class StepNamingConventions:
    """Standardized naming patterns for workflow steps"""

    # Pattern 1: Phase-Based Naming
    # Format: phase[N]_[domain]_[action]_[type]
    PHASE_BASED = {
        "research": "phase1_market_research_collector",
        "analysis": "phase2_competitive_analysis_processor",
        "synthesis": "phase3_strategic_synthesis_orchestrator"
    }

    # Pattern 2: Action-Oriented Naming
    # Format: [action]_[domain]_[target]
    ACTION_ORIENTED = {
        "collect": "collect_market_intelligence",
        "analyze": "analyze_competitive_landscape",
        "synthesize": "synthesize_strategic_insights"
    }

    # Pattern 3: Domain-Specific Naming
    # Format: [domain]_[specialization]_[processor]
    DOMAIN_SPECIFIC = {
        "financial": "financial_viability_assessor",
        "technical": "technical_feasibility_evaluator",
        "market": "market_opportunity_analyzer"
    }

    # Pattern 4: Sequential Naming
    # Format: step[N]_[descriptive_name]
    SEQUENTIAL = {
        "step1": "step01_initial_research_collection",
        "step2": "step02_competitive_intelligence_analysis",
        "step3": "step03_financial_viability_assessment"
    }

def create_named_step_sequence(base_name: str, step_configs: List[Dict]) -> List[Step]:
    """Create sequence of steps with consistent naming pattern"""

    steps = []
    for i, config in enumerate(step_configs, 1):
        step_name = f"{base_name}_step{i:02d}_{config['suffix']}"

        step = Step(
            name=step_name,
            agent=config.get('agent'),
            team=config.get('team'),
            executor=config.get('executor'),
            description=config.get('description', f"Execute step {i} in {base_name} sequence")
        )

        steps.append(step)
        logger.info(f"Created sequential step: {step_name}")

    return steps

# Usage example
research_sequence_configs = [
    {
        'suffix': 'market_data_collection',
        'agent': primary_researcher,
        'description': 'Collect comprehensive market data and industry insights'
    },
    {
        'suffix': 'competitive_intelligence',
        'agent': competitive_analyst,
        'description': 'Analyze competitive landscape and positioning'
    },
    {
        'suffix': 'strategic_synthesis',
        'agent': strategic_synthesizer,
        'description': 'Synthesize research into strategic recommendations'
    }
]

research_steps = create_named_step_sequence("market_research", research_sequence_configs)
```

### Step Categorization and Grouping

```python
from enum import Enum
from typing import List, Dict, Optional
from dataclasses import dataclass

class StepCategory(Enum):
    """Categorize steps for better organization"""
    DATA_COLLECTION = "data_collection"
    ANALYSIS = "analysis"
    PROCESSING = "processing"
    SYNTHESIS = "synthesis"
    VALIDATION = "validation"
    OUTPUT = "output"

class StepPriority(Enum):
    """Priority levels for step execution"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"

@dataclass
class StepMetadata:
    """Enhanced metadata for step organization"""
    category: StepCategory
    priority: StepPriority
    estimated_duration: Optional[int] = None  # seconds
    dependencies: List[str] = None
    tags: List[str] = None
    version: str = "1.0"

class OrganizedStepBuilder:
    """Builder for creating well-organized workflow steps"""

    def __init__(self):
        self.steps: List[Step] = []
        self.step_metadata: Dict[str, StepMetadata] = {}

    def add_step(
        self,
        name: str,
        executor,  # agent, team, or function
        category: StepCategory,
        priority: StepPriority = StepPriority.MEDIUM,
        description: str = None,
        estimated_duration: int = None,
        dependencies: List[str] = None,
        tags: List[str] = None
    ) -> 'OrganizedStepBuilder':
        """Add step with comprehensive metadata"""

        # Create step based on executor type
        if hasattr(executor, 'run') and not hasattr(executor, 'members'):
            # Agent
            step = Step(name=name, agent=executor, description=description)
        elif hasattr(executor, 'members'):
            # Team
            step = Step(name=name, team=executor, description=description)
        else:
            # Function
            step = Step(name=name, executor=executor, description=description)

        # Store metadata
        metadata = StepMetadata(
            category=category,
            priority=priority,
            estimated_duration=estimated_duration,
            dependencies=dependencies or [],
            tags=tags or [],
        )

        self.steps.append(step)
        self.step_metadata[name] = metadata

        logger.info(f"Added organized step: {name} ({category.value}, {priority.value})")
        return self

    def get_steps_by_category(self, category: StepCategory) -> List[Step]:
        """Get all steps in a specific category"""
        return [
            step for step in self.steps
            if self.step_metadata[step.name].category == category
        ]

    def get_steps_by_priority(self, priority: StepPriority) -> List[Step]:
        """Get all steps with specific priority"""
        return [
            step for step in self.steps
            if self.step_metadata[step.name].priority == priority
        ]

    def validate_dependencies(self) -> bool:
        """Validate that all step dependencies exist"""
        step_names = {step.name for step in self.steps}

        for step in self.steps:
            metadata = self.step_metadata[step.name]
            for dependency in metadata.dependencies:
                if dependency not in step_names:
                    logger.error(f"Step {step.name} has missing dependency: {dependency}")
                    return False

        return True

    def get_execution_plan(self) -> Dict[str, Any]:
        """Generate execution plan with step organization"""
        return {
            "total_steps": len(self.steps),
            "by_category": {
                cat.value: len(self.get_steps_by_category(cat))
                for cat in StepCategory
            },
            "by_priority": {
                pri.value: len(self.get_steps_by_priority(pri))
                for pri in StepPriority
            },
            "estimated_duration": sum(
                metadata.estimated_duration or 60
                for metadata in self.step_metadata.values()
            ),
            "dependencies_valid": self.validate_dependencies()
        }

    def build(self) -> List[Step]:
        """Build final step sequence with validation"""
        if not self.validate_dependencies():
            raise ValueError("Step dependencies validation failed")

        logger.info(f"Built organized workflow with {len(self.steps)} steps")
        return self.steps

# Usage example
builder = OrganizedStepBuilder()

# Data Collection Phase
builder.add_step(
    name="initial_market_data_collection",
    executor=primary_researcher,
    category=StepCategory.DATA_COLLECTION,
    priority=StepPriority.CRITICAL,
    description="Collect initial market research data",
    estimated_duration=180,
    tags=["market", "research", "data"]
)

# Analysis Phase
builder.add_step(
    name="competitive_landscape_analysis",
    executor=competitive_analyst,
    category=StepCategory.ANALYSIS,
    priority=StepPriority.HIGH,
    description="Analyze competitive landscape",
    estimated_duration=150,
    dependencies=["initial_market_data_collection"],
    tags=["competitive", "analysis"]
)

# Synthesis Phase
builder.add_step(
    name="strategic_synthesis_generation",
    executor=strategic_synthesizer,
    category=StepCategory.SYNTHESIS,
    priority=StepPriority.CRITICAL,
    description="Generate strategic synthesis",
    estimated_duration=120,
    dependencies=["competitive_landscape_analysis"],
    tags=["synthesis", "strategy"]
)

organized_steps = builder.build()
execution_plan = builder.get_execution_plan()

logger.info(f"Execution plan: {execution_plan}")
```

### Dynamic Step Creation

```python
def create_adaptive_workflow_steps(
    research_topic: str,
    complexity_level: str = "medium",
    time_constraint: int = 300  # seconds
) -> List[Step]:
    """Create workflow steps dynamically based on requirements"""

    steps = []

    if complexity_level == "high":
        # High complexity - comprehensive analysis
        steps.extend([
            Step(
                name=f"detailed_market_research_{hash(research_topic) % 1000}",
                agent=primary_researcher,
                description=f"Detailed market research for {research_topic}"
            ),
            Step(
                name=f"comprehensive_competitive_analysis_{hash(research_topic) % 1000}",
                team=research_team,
                description=f"Comprehensive competitive analysis for {research_topic}"
            ),
            Step(
                name=f"financial_modeling_analysis_{hash(research_topic) % 1000}",
                agent=financial_analyst,
                description=f"Financial modeling and analysis for {research_topic}"
            )
        ])

    elif complexity_level == "medium":
        # Medium complexity - balanced analysis
        steps.extend([
            Step(
                name=f"market_research_{hash(research_topic) % 1000}",
                agent=primary_researcher,
                description=f"Market research for {research_topic}"
            ),
            Step(
                name=f"competitive_analysis_{hash(research_topic) % 1000}",
                agent=competitive_analyst,
                description=f"Competitive analysis for {research_topic}"
            )
        ])

    else:  # low complexity
        # Low complexity - basic analysis
        steps.append(
            Step(
                name=f"basic_research_{hash(research_topic) % 1000}",
                agent=primary_researcher,
                description=f"Basic research for {research_topic}"
            )
        )

    # Add synthesis step for all complexity levels
    steps.append(
        Step(
            name=f"synthesis_{complexity_level}_{hash(research_topic) % 1000}",
            agent=strategic_synthesizer,
            description=f"Strategic synthesis for {research_topic}"
        )
    )

    logger.info(f"Created {len(steps)} adaptive steps for {complexity_level} complexity")
    return steps
```

## Speed Tips

### Step Creation Optimization

- **Naming Consistency**: Use consistent naming patterns across all workflows
- **Clear Descriptions**: Write descriptive step descriptions for maintainability
- **Metadata Usage**: Include comprehensive metadata for tracking and debugging
- **Factory Patterns**: Use factory classes to standardize step creation
- **Step Reusability**: Design steps as reusable components across workflows
- **Dependency Management**: Clearly define and validate step dependencies

### Common Step Patterns

```python
# Pattern 1: Research Steps
research_step = Step(
    name="phase1_market_research_collector",
    agent=researcher,
    description="Collect comprehensive market research data"
)

# Pattern 2: Analysis Steps
analysis_step = Step(
    name="phase2_competitive_analysis_processor",
    agent=analyst,
    description="Process competitive landscape analysis"
)

# Pattern 3: Custom Function Steps
processing_step = Step(
    name="phase3_data_transformation_orchestrator",
    executor=transformation_function,
    description="Orchestrate complex data transformation pipeline"
)

# Pattern 4: Team Coordination Steps
team_step = Step(
    name="phase4_collaborative_synthesis_coordinator",
    team=synthesis_team,
    description="Coordinate team-based synthesis process"
)
```

## Common Pitfalls (CRITICAL)

### Naming Anti-patterns

```python
# ❌ WRONG - Vague, non-descriptive names
bad_step1 = Step(name="step1", agent=agent)  # What does step1 do?
bad_step2 = Step(name="process", agent=agent)  # Process what?
bad_step3 = Step(name="analyze_stuff", agent=agent)  # What stuff?

# ✅ CORRECT - Clear, descriptive names
good_step1 = Step(
    name="initial_market_research_collection",
    agent=researcher,
    description="Collect initial market research data and industry analysis"
)
good_step2 = Step(
    name="competitive_landscape_analysis",
    agent=analyst,
    description="Analyze competitive positioning and market dynamics"
)
good_step3 = Step(
    name="strategic_synthesis_generation",
    agent=synthesizer,
    description="Generate strategic recommendations from research findings"
)

# ❌ WRONG - Inconsistent naming patterns
inconsistent_steps = [
    Step(name="research", agent=agent1),
    Step(name="step_2_analysis", agent=agent2),  # Different format
    Step(name="final-synthesis", agent=agent3)   # Different separator
]

# ✅ CORRECT - Consistent naming patterns
consistent_steps = [
    Step(name="phase1_research_collection", agent=agent1),
    Step(name="phase2_analysis_processing", agent=agent2),
    Step(name="phase3_synthesis_generation", agent=agent3)
]
```

### Step Organization Issues

```python
# ❌ WRONG - No clear step organization or flow
disorganized_workflow = Workflow(
    name="Messy Workflow",
    steps=[
        Step(name="random_step", agent=agent1),
        Step(name="another_step", agent=agent2),
        Step(name="final_step", agent=agent3)
    ]
)

# ✅ CORRECT - Clear organization and flow
organized_workflow = Workflow(
    name="Organized Research Pipeline",
    description="Structured multi-phase research workflow",
    steps=[
        # Phase 1: Data Collection
        Step(
            name="phase1_initial_data_collection",
            agent=data_collector,
            description="Collect and structure initial research data"
        ),
        # Phase 2: Analysis
        Step(
            name="phase2_competitive_analysis",
            agent=analyst,
            description="Analyze competitive landscape and positioning"
        ),
        # Phase 3: Synthesis
        Step(
            name="phase3_strategic_synthesis",
            agent=synthesizer,
            description="Synthesize findings into strategic recommendations"
        )
    ]
)

# ❌ WRONG - Missing descriptions and metadata
minimal_step = Step(name="research", agent=agent)  # No description!

# ✅ CORRECT - Comprehensive step definition
comprehensive_step = Step(
    name="comprehensive_market_research",
    agent=researcher,
    description="Conduct comprehensive market research including industry analysis, competitor mapping, and trend identification"
)
```

### Step Dependency Management

```python
# ❌ WRONG - Implicit dependencies without documentation
undocumented_workflow = [
    Step(name="step1", agent=agent1),  # Relies on step2 output but not documented
    Step(name="step2", agent=agent2),  # Actually needs to run first
    Step(name="step3", agent=agent3)   # Depends on both but unclear
]

# ✅ CORRECT - Explicit dependency documentation
documented_workflow = [
    Step(
        name="phase1_data_collection",
        agent=collector,
        description="Independent data collection - no dependencies"
    ),
    Step(
        name="phase2_analysis_processing",
        agent=processor,
        description="Process data from phase1_data_collection"
    ),
    Step(
        name="phase3_synthesis_generation",
        agent=synthesizer,
        description="Synthesize results from phase1 and phase2"
    )
]
```

## Best Practices Summary

- **Naming Convention**: Use consistent, descriptive naming patterns across all steps
- **Clear Descriptions**: Write comprehensive descriptions for each step's purpose and function
- **Logical Organization**: Group steps into logical phases or categories
- **Dependency Documentation**: Clearly document step dependencies and execution order
- **Metadata Usage**: Include rich metadata for tracking, debugging, and monitoring
- **Reusability**: Design steps as reusable components that can work across workflows
- **Factory Patterns**: Use factory classes to standardize step creation and ensure consistency
- **Validation**: Validate step configurations and dependencies before workflow execution
